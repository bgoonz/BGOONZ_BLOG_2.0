<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>What is Memoization?</title><style>
</head><body><article class="h-entry">
<header>
<h1 class="p-name">What is Memoization?</h1>
</header>
<section data-field="subtitle" class="p-summary">
And why this programming paradigm shouldn’t make you cringe.
</section>
<section data-field="body" class="e-content">
<section name="271c" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1fec" id="1fec" class="graf graf--h3 graf--leading graf--title">What is Memoization?</h3><h4 name="3970" id="3970" class="graf graf--h4 graf-after--h3 graf--subtitle">And why this programming paradigm shouldn’t make you cringe.</h4><h3 name="a1dd" id="a1dd" class="graf graf--h3 graf-after--h4">The following animated gifs were taken from:</h3><h4 name="84b6" id="84b6" class="graf graf--h4 graf-after--h3"><a href="https://www.deadcoderising.com/2017-06-13-why-pure-functions-4-benefits-to-embrace-2/" data-href="https://www.deadcoderising.com/2017-06-13-why-pure-functions-4-benefits-to-embrace-2/" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">Source</a></h4><div name="e416" id="e416" class="graf graf--mixtapeEmbed graf-after--h4"><a href="https://www.deadcoderising.com/" data-href="https://www.deadcoderising.com/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.deadcoderising.com/"><strong class="markup--strong markup--mixtapeEmbed-strong">Dead Code Rising</strong><br><em class="markup--em markup--mixtapeEmbed-em">The last couple of weeks I&#39;ve been using a lot of hours playing around with GatsbyJS, and it&#39;s been a blast! Gatsby is…</em>www.deadcoderising.com</a><a href="https://www.deadcoderising.com/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="634fe45af5ecc8b6636dce6510f91344" data-thumbnail-img-id="0*_lW2AcIRIPjXhY_5" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*_lW2AcIRIPjXhY_5);"></a></div><figure name="4e4a" id="4e4a" class="graf graf--figure graf-after--mixtapeEmbed"><img class="graf-image" data-image-id="1*Ey6rNclUY-Rp3iqM9Ytnag.gif" data-width="3661" data-height="2953" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Ey6rNclUY-Rp3iqM9Ytnag.gif"></figure><figure name="bd35" id="bd35" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="0*w0txnjkmBo2z0COv.png" data-width="2025" data-height="1392" src="https://cdn-images-1.medium.com/max/800/0*w0txnjkmBo2z0COv.png"></figure><p name="f6e8" id="f6e8" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Memoization</strong> is a design paradigm used to reduce the overall number of<br>calculations that can occur in algorithms that use recursive algorithms.</p><p name="9bc1" id="9bc1" class="graf graf--p graf-after--p">Recall that recursion solves a large problem by dividing it into smaller<br>sub-problems that are more manageable.</p><p name="bb4d" id="bb4d" class="graf graf--p graf-after--p">Memoization will store the results of the sub-problems in some other data structure, meaning that you avoid duplicate calculations and only “solve” each subproblem once.</p><p name="f1f7" id="f1f7" class="graf graf--p graf-after--p">This approach is near synonymous with another computer science term you may have heard before — caching. However, caching as a practice is not achieved exclusively by memoizing. Think of a cache as a little bucket where we will keep important information we don’t want to forget in the near future but that isn’t vitally important or part of the long-term makeup of our application. It’s less important than the things we need to store in memory but more important than a variable we can discard as soon as we use it once.</p><p name="4f8d" id="4f8d" class="graf graf--p graf-after--p">There are two features that comprise memoization:</p><ul class="postList"><li name="0b0b" id="0b0b" class="graf graf--li graf-after--p">The function is recursive.</li><li name="65a0" id="65a0" class="graf graf--li graf-after--li">The additional data structure used is typically an object (we refer to this as<br>the memo).</li></ul><p name="d308" id="d308" class="graf graf--p graf-after--li">This is a trade-off between the time it takes to run an algorithm (without<br>memoization) and the memory used to run the algorithm (with memoization).</p><p name="3b08" id="3b08" class="graf graf--p graf-after--p">Usually, memoization is a good trade-off when dealing with large data or<br>calculations.</p><p name="93da" id="93da" class="graf graf--p graf-after--p">You cannot always apply this technique to recursive problems. The problem must have an “overlapping subproblem structure” for memoization to be effective.</p><p name="c80f" id="c80f" class="graf graf--p graf-after--p">Generally speaking, computer memory is cheap and human time is incalculably valuable so we may opt for this approach even when the largest gains on paper can be made from converting RAM at the expense of execution speed.</p><p name="c1d1" id="c1d1" class="graf graf--p graf-after--p">Here’s an example of a problem that has such a structure:</p><blockquote name="3cb2" id="3cb2" class="graf graf--blockquote graf-after--p">Using pennies, nickels, dimes, and quarters, how many combinations<br>of coins are there that total 27 cents?</blockquote><p name="f734" id="f734" class="graf graf--p graf-after--blockquote">Along the way to calculating the possible coin combination of 27<br>cents, you should also calculate the smallest coin combination of 25 cents as well as 21 cents and any smaller total that comprises a fraction of the total combination of 27 (so long as there is a one-cent piece; if there are only nickels and up, the problem deviates from this approach on a technicality but in essence, it is still calculated in the same manner, that is to say as a component of that bigger problem).</p><p name="a0aa" id="a0aa" class="graf graf--p graf-after--p">Remember, a computer is stupid and must check every possibility exhaustively to ensure that no possible combination is missed (in reality, I may be oversimplifying the truth of the matter but for now, please bear with me).</p><p name="9cc7" id="9cc7" class="graf graf--p graf-after--p">This is the essence of a redundant subcomponent of the overall problem.</p><h3 name="b594" id="b594" class="graf graf--h3 graf-after--p">Memoizing factorial</h3><figure name="a119" id="a119" class="graf graf--figure graf--iframe graf-after--h3"><script src="https://gist.github.com/bgoonz/2d6ba2a328f9c04075dc094ca2c531f0.js"></script></figure><p name="4b01" id="4b01" class="graf graf--p graf-after--figure">From this plain <code class="markup--code markup--p-code">factorial</code> above, it is clear that every time you call<br><code class="markup--code markup--p-code">factorial(6)</code> you should get the same result of <code class="markup--code markup--p-code">720</code> each time. The code is<br>somewhat inefficient because you must go down the full recursive stack for each top-level call to <code class="markup--code markup--p-code">factorial(6)</code>.</p><p name="6ac3" id="6ac3" class="graf graf--p graf-after--p">If we can store the result of <code class="markup--code markup--p-code">factorial(6)</code> the first time you calculate it, then on subsequent calls to <code class="markup--code markup--p-code">factorial(6)</code> you simply fetch the stored result in constant time.</p><figure name="cc24" id="cc24" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/46d8b0feeee0f63d56dc2aa624d15df7.js"></script></figure><p name="e6ec" id="e6ec" class="graf graf--p graf-after--figure">The <code class="markup--code markup--p-code">memo</code> object above will map an argument of <code class="markup--code markup--p-code">factorial</code> to its return<br>value. That is, the keys will be arguments and their values will be the<br>corresponding results returned. By using the memo, you are able to avoid<br>duplicate recursive calls!</p><p name="55ee" id="55ee" class="graf graf--p graf-after--p">By the time your first call to <code class="markup--code markup--p-code">factorial(6) </code>returns, you will not have just the argument <code class="markup--code markup--p-code">6</code> stored in the memo. Rather, y<strong class="markup--strong markup--p-strong">ou will have <em class="markup--em markup--p-em">all</em> arguments 2 to 6 stored in the memo.</strong></p><p name="2240" id="2240" class="graf graf--p graf-after--p">Perhaps you’re not convinced because:</p><ul class="postList"><li name="9fd5" id="9fd5" class="graf graf--li graf-after--p">You didn’t improve the speed of the algorithm by an order of Big-O (it is<br>still O(n)).</li><li name="3867" id="3867" class="graf graf--li graf-after--li">The code uses some global variable, so it’s kind of ugly.</li></ul><h3 name="7545" id="7545" class="graf graf--h3 graf-after--li">Memoizing the Fibonacci generator</h3><p name="b42d" id="b42d" class="graf graf--p graf-after--h3">Here’s a <em class="markup--em markup--p-em">naive</em> implementation of a function that calculates the Fibonacci<br>number for a given input.</p><pre name="fcad" id="fcad" class="graf graf--pre graf-after--p">function fib(n) {<br>  if (n === 1 || n === 2) return 1;<br>  return fib(n - 1) + fib(n - 2);<br>}</pre><pre name="8605" id="8605" class="graf graf--pre graf-after--pre">fib(6);     // =&gt; 8</pre><p name="6dc7" id="6dc7" class="graf graf--p graf-after--pre">The time complexity of this function is not super intuitive to describe because<br>the code branches twice recursively. Fret not! You’ll find it useful to<br>visualize the calls needed to do this with a tree. When reasoning about the time complexity for recursive functions, draw a tree that helps you see the calls. Every node of the tree represents a call of the recursion:</p><figure name="874d" id="874d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*fS_yOCDL-4NyBLyj.png" data-width="803" data-height="720" src="https://cdn-images-1.medium.com/max/800/0*fS_yOCDL-4NyBLyj.png"></figure><ul class="postList"><li name="47ea" id="47ea" class="graf graf--li graf-after--figure"><em class="markup--em markup--li-em">n </em>, the height of this tree will be <code class="markup--code markup--li-code">n</code>. You derive this by following<br>the path going straight down the left side of the tree.</li><li name="855a" id="855a" class="graf graf--li graf-after--li">each internal node leads to two more nodes. Overall, this means that the tree will have roughly 2n nodes.</li><li name="df50" id="df50" class="graf graf--li graf-after--li">which is the same as saying that the <code class="markup--code markup--li-code">fib </code>function has an exponential time complexity of 2n.</li><li name="42df" id="42df" class="graf graf--li graf-after--li">That is very slow!</li></ul><p name="4bca" id="4bca" class="graf graf--p graf-after--li">See for yourself, try running <code class="markup--code markup--p-code">fib(50)</code> - you&#39;ll be waiting for quite a lot longer than you’ve gotten used to waiting for a program to run in the last decade.</p><p name="8712" id="8712" class="graf graf--p graf-after--p">The green regions highlighted above are repetitive.</p><p name="a5fd" id="a5fd" class="graf graf--p graf-after--p">As the <code class="markup--code markup--p-code">n</code> grows bigger, the number of duplicate sub-trees grows exponentially.</p><p name="0d07" id="0d07" class="graf graf--p graf-after--p">Luckily you can fix this using memoization by using a similar object strategy.</p><p name="b211" id="b211" class="graf graf--p graf-after--p">You can use some JavaScript default arguments `<code class="markup--code markup--p-code">memo={}</code><em class="markup--em markup--p-em">`</em>to clean things up:</p><figure name="ed77" id="ed77" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/53cfa037f5dea574fbfed77fc70e7718.js"></script></figure><p name="40bd" id="40bd" class="graf graf--p graf-after--figure">You can see the marked nodes (function calls) that access the memo in green.<br>It’s easy to see that this version of the Fibonacci generator will do far fewer<br>computations as <code class="markup--code markup--p-code">n</code> grows larger! In fact, this memoization has brought the time complexity down to linear <code class="markup--code markup--p-code">O(n)</code> time because the tree only branches on the left side. This is an enormous gain if you recall the complexity of class hierarchy.</p><h3 name="dc1a" id="dc1a" class="graf graf--h3 graf-after--p">The memoization formula</h3><p name="68e9" id="68e9" class="graf graf--p graf-after--h3">Now that you understand memoization, when should you apply it? Memoization is useful when attacking recursive problems that have many overlapping sub-problems.</p><p name="bb33" id="bb33" class="graf graf--p graf-after--p">You’ll find it most useful to draw out the visual tree first. If you notice duplicate sub-trees, time to memoize. Here are the hard and fast<br>rules you can use to memoize a slow algorithm:</p><ol class="postList"><li name="002b" id="002b" class="graf graf--li graf-after--p">Write the unoptimized, brute force recursion and make sure it works.</li><li name="d106" id="d106" class="graf graf--li graf-after--li">Add the memo object as an additional argument to the function. The keys will<br>represent unique arguments to the function, and their values will represent the results for those arguments.</li><li name="ab4e" id="ab4e" class="graf graf--li graf-after--li">Add a base case condition to the function that returns the stored value if<br>the function’s argument is in the memo.</li><li name="3e67" id="3e67" class="graf graf--li graf-after--li">Before you return the result of the recursive case, store it in the memo as a<br>value and make the function’s argument its key.</li></ol><p name="f1c1" id="f1c1" class="graf graf--p graf-after--li">Here’s the solution to the aforementioned coin problem:</p><figure name="4f85" id="4f85" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/16e4e3f983ae3cf0a7794a7864d0f529.js"></script></figure><figure name="0b7d" id="0b7d" class="graf graf--figure graf--iframe graf-after--figure"><iframe src="https://jsfiddle.net/bgoonz/m4qvgcno/embedded/" width="600" height="400" frameborder="0" scrolling="no"></iframe></figure><p name="cf9b" id="cf9b" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">More content at </em><a href="http://plainenglish.io/" data-href="http://plainenglish.io/" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank"><em class="markup--em markup--p-em">plainenglish.io</em></a></p><h3 name="d0ec" id="d0ec" class="graf graf--h3 graf-after--p">Discover More:</h3><div name="1e6c" id="1e6c" class="graf graf--mixtapeEmbed graf-after--h3 graf--trailing"><a href="https://bgoonz-blog.netlify.app/" data-href="https://bgoonz-blog.netlify.app/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://bgoonz-blog.netlify.app/"><strong class="markup--strong markup--mixtapeEmbed-strong">Web-Dev-Hub</strong><br><em class="markup--em markup--mixtapeEmbed-em">Memoization, Tabulation, and Sorting Algorithms by Example Why is looking at runtime not a reliable method of…</em>bgoonz-blog.netlify.app</a><a href="https://bgoonz-blog.netlify.app/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a2f1abe4ed6a87b0b90d28e55f930d20" data-thumbnail-img-id="0*yHs_xDis1qQ8JjWg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*yHs_xDis1qQ8JjWg);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bryanguner" class="p-author h-card">Bryan Guner</a> on <a href="https://medium.com/p/86685d811182"><time class="dt-published" datetime="2021-06-04T02:41:55.887Z">June 4, 2021</time></a>.</p><p><a href="https://medium.com/@bryanguner/memoization-86685d811182" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 10, 2021.</p></footer></article></body></html>