<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>The Complete JavaScript Reference Guide</title><style>
</head><body><article class="h-entry">
<header>
<h1 class="p-name">The Complete JavaScript Reference Guide</h1>
</header>
<section data-field="subtitle" class="p-summary">
You will want to bookmark this
</section>
<section data-field="body" class="e-content">
<section name="6a85" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8be9" id="8be9" class="graf graf--h3 graf--leading graf--title">The Complete JavaScript Reference Guide</h3><figure name="85b6" id="85b6" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*In5wB-29T0Ud_zs3.jpg" data-width="600" data-height="431" src="https://cdn-images-1.medium.com/max/800/0*In5wB-29T0Ud_zs3.jpg"></figure><h3 name="6610" id="6610" class="graf graf--h3 graf-after--figure">How to learn effectively</h3><p name="22c5" id="22c5" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Learning</strong>: The acquisition of skills and the ability to apply them in the future.</p><p name="2b6e" id="2b6e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What makes an Effective learner?</strong></p><ul class="postList"><li name="7504" id="7504" class="graf graf--li graf-after--p">They are active listeners.</li><li name="179b" id="179b" class="graf graf--li graf-after--li">They are engaged with the material.</li><li name="3193" id="3193" class="graf graf--li graf-after--li">They are receptive of feedback.</li><li name="17d8" id="17d8" class="graf graf--li graf-after--li">They are open to difficulty.</li></ul><p name="d1f4" id="d1f4" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Why do active learning techniques feel difficult?</strong></p><ul class="postList"><li name="7848" id="7848" class="graf graf--li graf-after--p">It feels difficult because you are constantly receiving feedback, and so you are constantly adapting and perfecting the material.</li></ul><p name="2f3a" id="2f3a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Desirable Difficulty</strong></p><ul class="postList"><li name="67c9" id="67c9" class="graf graf--li graf-after--p">The skills we wish to obtain is often a difficult one.</li><li name="c939" id="c939" class="graf graf--li graf-after--li">We want challenging but possible lessons based on current level of skill.</li></ul><p name="d5ff" id="d5ff" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Effective learners space their practice</strong></p><ul class="postList"><li name="59a4" id="59a4" class="graf graf--li graf-after--p graf--trailing">Consistent effort &gt; cramming =&gt; for <strong class="markup--strong markup--li-strong">durable knowledge</strong></li></ul></div></div></section><section name="bd60" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="98cc" id="98cc" class="graf graf--h3 graf--leading">Getting visual feedback in your programs</h3><p name="f1ec" id="f1ec" class="graf graf--p graf-after--h3">The first command we’ll learn in JavaScript is <code class="markup--code markup--p-code">console.log</code>. This command is used to <em class="markup--em markup--p-em">print</em> something onto the screen. As we write our first lines of code, we’ll be using <code class="markup--code markup--p-code">console.log</code> frequently as a way to visually see the output of our programs. Let’s write our first program:</p><pre name="e289" id="e289" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">console.log(&quot;hello world&quot;);<br>console.log(&quot;how are you?&quot;);</code></pre><p name="dd88" id="dd88" class="graf graf--p graf-after--pre">Executing the program above would print out the following:</p><pre name="ac39" id="ac39" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">hello world<br>how are you?</code></pre><p name="be82" id="be82" class="graf graf--p graf-after--pre">Nothing too ground breaking here, but pay close attention to the exact way we wrote the program. In particular, notice how we lay out the periods, parentheses, and quotation marks. We’ll also terminate lines with semicolons (;).</p><blockquote name="8b89" id="8b89" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Depending on how you structure your code, sometimes you’ll be able to omit semicolons at the end of lines. For now, you’ll want to include them just as we do.</em></blockquote><h3 name="2a8a" id="2a8a" class="graf graf--h3 graf-after--blockquote">Syntax</h3><p name="e7e2" id="e7e2" class="graf graf--p graf-after--h3">We refer to the exact arrangement of the symbols, characters, and keywords as <strong class="markup--strong markup--p-strong">syntax</strong>. These details matter — your computer will only be able to “understand” proper JavaScript syntax. A programming language is similar to a spoken language. A spoken language like English has grammar rules that we should follow in order to be understood by fellow speakers. In the same way, a programming language like JavaScript has syntax rules that we ought to follow!</p><p name="14b7" id="14b7" class="graf graf--p graf-after--p">As you write your first lines of code in this new language, you may make many syntax errors. Don’t get frustrated! This is normal — all new programmers go through this phase. Every time we recognize an error in our code, we have an opportunity to reinforce your understanding of correct syntax. Adopt a growth mindset and learn from your mistakes.</p><p name="3277" id="3277" class="graf graf--p graf-after--p">Additionally, one of the best things about programming is that we can get such immediate feedback from our creations. There is no penalty for making a mistake when programming. Write some code, run the code, read the errors, fix the errors, rinse and repeat!</p><h3 name="3ed2" id="3ed2" class="graf graf--h3 graf-after--p">Code comments</h3><p name="d005" id="d005" class="graf graf--p graf-after--h3">Occasionally we’ll want to leave <strong class="markup--strong markup--p-strong">comments</strong> or notes in our code. Commented lines will be ignored by our computer. This means that we can use comments to write plain english or temporarily avoid execution of some JavaScript lines. The proper <em class="markup--em markup--p-em">syntax</em> for writing a comment is to begin the line with double forward slashes (<code class="markup--code markup--p-code">//</code>):</p><pre name="f4e6" id="f4e6" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// let&#39;s write another program!!!<br>console.log(&quot;hello world&quot;);</code></pre><pre name="e986" id="e986" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// console.log(&quot;how are you?&quot;);</code></pre><pre name="3bc4" id="3bc4" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(&quot;goodbye moon&quot;);</code></pre><p name="dadb" id="dadb" class="graf graf--p graf-after--pre">The program above would only print:</p><pre name="bf40" id="bf40" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">hello world<br>goodbye moon</code></pre><p name="c221" id="c221" class="graf graf--p graf-after--pre">Comments are useful when annotating pieces of code to offer an explanation of how the code works. We’ll want to strive to write straightforward code that is self-explanatory when possible, but we can also use comments to add additional clarity. The real art of programming is to write code so elegantly that it is easy to follow.</p><p name="e47b" id="e47b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The Number Data Type</strong></p><p name="4c3e" id="4c3e" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">number</strong> data type in JS is used to represent any numerical values, including integers and decimal numbers.</p><p name="10b1" id="10b1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Basic Arithmetic Operators</strong></p><p name="c235" id="c235" class="graf graf--p graf-after--p">Operators are the symbols that perform particular operations.</p><ul class="postList"><li name="f533" id="f533" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">+</strong> (addition)</li><li name="5b9f" id="5b9f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">-</strong> (subtraction)</li><li name="b98b" id="b98b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">asterisk</strong> (multiplication)</li><li name="9a15" id="9a15" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">/</strong> (division)</li><li name="c752" id="c752" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">%</strong> (modulo)</li></ul><p name="181c" id="181c" class="graf graf--p graf-after--li">JS evaluates more complex expressions using the general math order of operations aka PEMDAS.</p><ul class="postList"><li name="b6e3" id="b6e3" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">PEMDAS</strong> : Parentheses, Exponents, Multiplication, Division, Modulo, Addition, Subtraction.</li><li name="9c25" id="9c25" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">To force a specific order of operation, use the group operator ( ) around a part of the expression.</em></li></ul><p name="ac24" id="ac24" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Modulo</strong> : Very useful operation to check divisibility of numbers, check for even &amp; odd, whether a number is prime, and much more! <em class="markup--em markup--p-em">(Discrete Math concept, circular problems can be solved with modulo)</em></p><ul class="postList"><li name="cf5b" id="cf5b" class="graf graf--li graf-after--p">Whenever you have a smaller number % a larger number, the answer will just be the initial small number. <br> console.log(7 % 10) // =&gt; 7;</li></ul><p name="1742" id="1742" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">The String Data Type</strong></p><p name="9a89" id="9a89" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">string</strong> data type is a primitive data type that used to represent textual data.</p><ul class="postList"><li name="e1b0" id="e1b0" class="graf graf--li graf-after--p">can be wrapped by either <strong class="markup--strong markup--li-strong">single</strong> or <strong class="markup--strong markup--li-strong">double</strong> quotation marks, <em class="markup--em markup--li-em">best to choose one and stick with it for consistency</em>.</li><li name="f8ad" id="f8ad" class="graf graf--li graf-after--li">If your string contains quotation marks inside, can layer single or double quotation marks to allow it to work.<br> “That’s a great string”; (valid)<br> <br> ‘Shakespeare wrote, “To be or not to be”’; (valid)<br> <br> ‘That’s a bad string’; (invalid)</li><li name="b2cb" id="b2cb" class="graf graf--li graf-after--li">Alt. way to add other quotes within strings is to use template literals.<br> `This is a temp’l’ate literal ${function}` // use ${} to invoke functions within.</li><li name="7b1a" id="7b1a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">.length</strong> : property that can be appended to data to return the length.</li><li name="f633" id="f633" class="graf graf--li graf-after--li">empty strings have a length of zero.</li><li name="0a07" id="0a07" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">indices</strong> : indexes of data that begin at 0, can call upon index by using the bracket notation [ ].<br> console.log(“bootcamp”[0]); // =&gt; “b”<br> console.log(“bootcamp”[10]); // =&gt; “undefined”<br> console.log(“boots”[1 * 2]); // =&gt; “o”<br> console.log(“boots”[“boot”.length-1]); // =&gt; “t”</li><li name="6482" id="6482" class="graf graf--li graf-after--li">we can pass expressions through the brackets as well since JS always evaluates expressions first.</li><li name="e2f5" id="e2f5" class="graf graf--li graf-after--li">The index of the last character of a string is always one less than it’s length.</li><li name="2271" id="2271" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">indexOf()</strong> : method used to find the first index of a given character within a string.<br> console.log(“bagel”.indexOf(“b”)); // =&gt; 0<br> console.log(“bagel”.indexOf(“z”)); // =&gt; -1</li><li name="8d68" id="8d68" class="graf graf--li graf-after--li">if the character inside the indexOf() search does not exist in the string, the output will be -1.</li><li name="d15e" id="d15e" class="graf graf--li graf-after--li">the indexOf() search will return the first instanced index of the the char in the string.</li><li name="a275" id="a275" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">concatenate</strong> : word to describe joining strings together into a single string.</li></ul><p name="fa5e" id="fa5e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">The Boolean Data Type</strong></p><p name="a909" id="a909" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">Boolean</strong> data type is the simplest data type since there are only two values: <strong class="markup--strong markup--p-strong">true</strong> and <strong class="markup--strong markup--p-strong">false</strong>.</p><ul class="postList"><li name="60da" id="60da" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Logical Operators</strong> (B<em class="markup--em markup--li-em">oolean Operators</em>) are used to establish logic in our code.</li><li name="139b" id="139b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">!</strong> (not) : reverses a Boolean value.<br> console.log(!true); // =&gt; false<br> console.log(!!false); // =&gt; false</li><li name="e412" id="e412" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Logical Order of Operations</strong> : JS will evaluate !, then &amp;&amp;, then ||.</li><li name="99ad" id="99ad" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Short-Circuit Evaluation</strong> : Because JS evalutes from left to right, expressions can “short-circuit”. For example if we have true on the left of an || logical comparison, it will stop evaluating and yield true instead of wasting resources on processing the rest of the statement.<br> console.log(true || !false) // =&gt; stops after it sees “true ||”</li></ul><p name="d6c3" id="d6c3" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Comparison Operators</strong></p><p name="76c7" id="76c7" class="graf graf--p graf-after--p">All comparison operators will result in a boolean output.</p><p name="3a93" id="3a93" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The relative comparators</strong></p><ul class="postList"><li name="6fee" id="6fee" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">&gt;</strong> (greater than)</li><li name="0437" id="0437" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">&lt;</strong> (less than)</li><li name="17ff" id="17ff" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">&gt;=</strong> (greater than or equal to)</li><li name="b2b4" id="b2b4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">&lt;=</strong> (less than or equal to)</li><li name="0c13" id="0c13" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">===</strong> (equal to)</li><li name="b73a" id="b73a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">!==</strong> (not equal to)</li></ul><p name="50be" id="50be" class="graf graf--p graf-after--li">Fun Fact: “a” &lt; “b” is considered valid JS Code because string comparisons are compared lexicographically (meaning dictionary order), so “a” is less than “b” because it appears earlier!</p><p name="a833" id="a833" class="graf graf--p graf-after--p">If there is ever a standstill comparison of two string lexicographically (i.e. app vs apple) the comparison will deem the shorter string lesser.</p><p name="9398" id="9398" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Difference between == and ===</strong></p><h4 name="b620" id="b620" class="graf graf--h4 graf-after--p">===</h4><p name="6010" id="6010" class="graf graf--p graf-after--h4">Strict Equality, will only return true if the two comparisons are entirely the same.</p><h4 name="38a2" id="38a2" class="graf graf--h4 graf-after--p">==</h4><p name="2ae2" id="2ae2" class="graf graf--p graf-after--h4">Loose Equality, will return true even if the values are of a different type, due to coercion. (Avoid using this)</p><p name="18bf" id="18bf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Variables</strong></p><p name="20d1" id="20d1" class="graf graf--p graf-after--p">Variables are used to store information to be referenced and manipulated in a program.</p><ul class="postList"><li name="c73d" id="c73d" class="graf graf--li graf-after--p">We initialize a variable by using the <strong class="markup--strong markup--li-strong">let</strong> keyword and a <strong class="markup--strong markup--li-strong">=</strong> single equals sign (assignment operator). <br> let bootcamp = “App Academy”;<br> console.log(bootcamp); // “App Academy”</li><li name="7849" id="7849" class="graf graf--li graf-after--li">JS variable names can contain any alphanumeric characters, underscores, or dollar signs (cannot being with a number).</li><li name="ad76" id="ad76" class="graf graf--li graf-after--li">If you do not declare a value for a variable, undefined is automatically set. <br> let bootcamp;<br> console.log(bootcamp); // undefined</li><li name="2188" id="2188" class="graf graf--li graf-after--li">We can change the value of a previously declared variable (let, not const) by re-assigning it another value.</li><li name="47ca" id="47ca" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">let</strong> is the updated version of <strong class="markup--strong markup--li-strong">var</strong>; there are some differences in terms of hoisting and global/block scope</li></ul><p name="63b9" id="63b9" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Assignment Shorthand</strong></p><p name="8d9f" id="8d9f" class="graf graf--p graf-after--p">let num = 0;<br> num += 10; // same as num = num + 10<br> num -= 2; // same as num = num — 2<br> num /= 4; // same as num = num / 4<br> num *= 7; // same as num = num * 7</p><ul class="postList"><li name="9c05" id="9c05" class="graf graf--li graf-after--p">In general, any nonsensical arithmetic will result in <strong class="markup--strong markup--li-strong">NaN</strong> ; usually operations that include undefined.</li></ul><p name="50e6" id="50e6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Functions</strong></p><p name="468d" id="468d" class="graf graf--p graf-after--p">A function is a procedure of code that will run when called. Functions are used so that we do not have to rewrite code to do the same thing over and over. (Think of them as ‘subprograms’)</p><ul class="postList"><li name="366f" id="366f" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Function Declaration</strong> : Process when we first initially write our function.</li><li name="676f" id="676f" class="graf graf--li graf-after--li">Includes three things:</li><li name="80c2" id="80c2" class="graf graf--li graf-after--li">Name of the function.</li><li name="f3a4" id="f3a4" class="graf graf--li graf-after--li">A list of <em class="markup--em markup--li-em">parameters</em> ()</li><li name="2b0e" id="2b0e" class="graf graf--li graf-after--li">The code to execute {}</li><li name="6879" id="6879" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Function Calls</strong> : We can call upon our function whenever and wherever* we want. (*wherever is only after the initial declaration)</li><li name="8374" id="8374" class="graf graf--li graf-after--li">JS evaluates code top down, left to right.</li><li name="2687" id="2687" class="graf graf--li graf-after--li">When we execute a declared function later on in our program we refer to this as <strong class="markup--strong markup--li-strong">invoking</strong> our function.</li><li name="0c3a" id="0c3a" class="graf graf--li graf-after--li">Every function in JS returns undefined unless otherwise specified.</li><li name="4207" id="4207" class="graf graf--li graf-after--li">When we hit a <strong class="markup--strong markup--li-strong">return</strong> statement in a function we immediately exit the function and return to where we called the function.</li><li name="e39f" id="e39f" class="graf graf--li graf-after--li">When naming functions in JS always use camelCase and name it something appropriate.</li></ul><p name="e4ad" id="e4ad" class="graf graf--p graf-after--li">Greate code reads like English and almost explains itself. Think: Elegant, readable, and maintainable!</p><p name="1728" id="1728" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Parameters and Arguments</strong></p><ul class="postList"><li name="e94e" id="e94e" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Parameters</strong> : Comma seperated variables specified as part of a function’s declaration.</li><li name="6740" id="6740" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Arguments</strong> : Values passed to the function when it is invoked.</li><li name="004c" id="004c" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">If the number of arguments passed during a function invocation is different than the number of paramters listed, it will still work.</em></li><li name="7da5" id="7da5" class="graf graf--li graf-after--li">However, is there are not enough arguments provided for parameters our function will likely yield <strong class="markup--strong markup--li-strong">Nan</strong>.</li></ul><h3 name="766c" id="766c" class="graf graf--h3 graf-after--li">Including Comments</h3><p name="44bb" id="44bb" class="graf graf--p graf-after--h3">Comments are important because they help other people understand what is going on in your code or remind you if you forgot something yourself. Keep in mind that they have to be marked properly so the browser won’t try to execute them.</p><p name="fc90" id="fc90" class="graf graf--p graf-after--p">In JavaScript you have two different options:</p><ul class="postList"><li name="356d" id="356d" class="graf graf--li graf-after--p">Single-line comments — To include a comment that is limited to a single line, precede it with <code class="markup--code markup--li-code">//</code></li><li name="ee3a" id="ee3a" class="graf graf--li graf-after--li">Multi-line comments — In case you want to write longer comments between several lines, wrap it in <code class="markup--code markup--li-code">/*</code> and <code class="markup--code markup--li-code">*/</code> to avoid it from being executed</li></ul><h3 name="0fae" id="0fae" class="graf graf--h3 graf-after--li">Variables in JavaScript</h3><p name="a118" id="a118" class="graf graf--p graf-after--h3">Variables are stand-in values that you can use to perform operations. You should be familiar with them from math class.</p><h3 name="c890" id="c890" class="graf graf--h3 graf-after--p">var, const, let</h3><p name="52c1" id="52c1" class="graf graf--p graf-after--h3">You have three different possibilities for declaring a variable in JavaScript, each with their own specialties:</p><ul class="postList"><li name="4b29" id="4b29" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">var</code> — The most common variable. It can be reassigned but only accessed within a function. Variables defined with <code class="markup--code markup--li-code">var</code> move to the top when the code is executed.</li><li name="d234" id="d234" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">const</code> — Can not be reassigned and not accessible before they appear within the code.</li><li name="0e3b" id="0e3b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">let</code> — Similar to <code class="markup--code markup--li-code">const</code>, the <code class="markup--code markup--li-code">let</code> variable can be reassigned but not re-declared.</li></ul><h3 name="523d" id="523d" class="graf graf--h3 graf-after--li">Data Types</h3><p name="b6f8" id="b6f8" class="graf graf--p graf-after--h3">Variables can contain different types of values and data types. You use <code class="markup--code markup--p-code">=</code> to assign them:</p><ul class="postList"><li name="b276" id="b276" class="graf graf--li graf-after--p">Numbers — <code class="markup--code markup--li-code">var age = 23</code></li><li name="5571" id="5571" class="graf graf--li graf-after--li">Variables — <code class="markup--code markup--li-code">var x</code></li><li name="e26c" id="e26c" class="graf graf--li graf-after--li">Text (strings) — <code class="markup--code markup--li-code">var a = &quot;init&quot;</code></li><li name="1312" id="1312" class="graf graf--li graf-after--li">Operations — <code class="markup--code markup--li-code">var b = 1 + 2 + 3</code></li><li name="9880" id="9880" class="graf graf--li graf-after--li">True or false statements — <code class="markup--code markup--li-code">var c = true</code></li><li name="335a" id="335a" class="graf graf--li graf-after--li">Constant numbers — <code class="markup--code markup--li-code">const PI = 3.14</code></li><li name="7221" id="7221" class="graf graf--li graf-after--li">Objects — <code class="markup--code markup--li-code">var name = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;}</code></li></ul><p name="3353" id="3353" class="graf graf--p graf-after--li">There are more possibilities. Note that variables are case sensitive. That means <code class="markup--code markup--p-code">lastname</code> and <code class="markup--code markup--p-code">lastName</code> will be handled as two different variables.</p><h3 name="9088" id="9088" class="graf graf--h3 graf-after--p">Objects</h3><p name="a5c8" id="a5c8" class="graf graf--p graf-after--h3">Objects are certain kinds of variables. They are variables that can have their own values and methods. The latter are actions that you can perform on objects.</p><p name="99ba" id="99ba" class="graf graf--p graf-after--p">var person = {</p><p name="c312" id="c312" class="graf graf--p graf-after--p">firstName:”John”,</p><p name="f94c" id="f94c" class="graf graf--p graf-after--p">lastName:”Doe”,</p><p name="1c03" id="1c03" class="graf graf--p graf-after--p">age:20,</p><p name="3956" id="3956" class="graf graf--p graf-after--p">nationality:”German”</p><p name="10ac" id="10ac" class="graf graf--p graf-after--p">};</p><h3 name="d6ff" id="d6ff" class="graf graf--h3 graf-after--p">The Next Level: Arrays</h3><p name="484a" id="484a" class="graf graf--p graf-after--h3">Next up in our JavaScript cheat sheet are arrays. Arrays are part of many different programming languages. They are a way of organizing variables and properties into groups. Here’s how to create one in JavaScript:</p><p name="962c" id="962c" class="graf graf--p graf-after--p">var fruit = [“Banana”, “Apple”, “Pear”];</p><p name="46fd" id="46fd" class="graf graf--p graf-after--p">Now you have an array called <code class="markup--code markup--p-code">fruit</code> which contains three items that you can use for future operations.</p><h3 name="106f" id="106f" class="graf graf--h3 graf-after--p">Array Methods</h3><p name="fc74" id="fc74" class="graf graf--p graf-after--h3">Once you have created arrays, there are a few things you can do with them:</p><ul class="postList"><li name="4e4b" id="4e4b" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">concat()</code> — Join several arrays into one</li><li name="5c02" id="5c02" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">indexOf()</code> — Returns the first position at which a given element appears in an array</li><li name="45cd" id="45cd" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">join()</code> — Combine elements of an array into a single string and return the string</li><li name="3a4e" id="3a4e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">lastIndexOf()</code> — Gives the last position at which a given element appears in an array</li><li name="8fbb" id="8fbb" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">pop()</code> — Removes the last element of an array</li><li name="28e4" id="28e4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">push()</code> — Add a new element at the end</li><li name="0be2" id="0be2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">reverse()</code> — Sort elements in a descending order</li><li name="775e" id="775e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">shift()</code> — Remove the first element of an array</li><li name="1063" id="1063" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">slice()</code> — Pulls a copy of a portion of an array into a new array</li><li name="53fd" id="53fd" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">sort()</code> — Sorts elements alphabetically</li><li name="f551" id="f551" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">splice()</code> — Adds elements in a specified way and position</li><li name="c46b" id="c46b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">toString()</code> — Converts elements to strings</li><li name="ef66" id="ef66" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">unshift()</code> —Adds a new element to the beginning</li><li name="4598" id="4598" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">valueOf()</code> — Returns the primitive value of the specified object</li></ul><h3 name="3d59" id="3d59" class="graf graf--h3 graf-after--li">Operators</h3><p name="4469" id="4469" class="graf graf--p graf-after--h3">If you have variables, you can use them to perform different kinds of operations. To do so, you need operators.</p><h3 name="bc32" id="bc32" class="graf graf--h3 graf-after--p">Basic Operators</h3><ul class="postList"><li name="5d34" id="5d34" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">+</code> — Addition</li><li name="5fd9" id="5fd9" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">-</code> — Subtraction</li><li name="3b13" id="3b13" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">*</code> — Multiplication</li><li name="521a" id="521a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">/</code> — Division</li><li name="cf0f" id="cf0f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">(...)</code> — Grouping operator, operations within brackets are executed earlier than those outside</li><li name="bb2a" id="bb2a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">%</code> — Modulus (remainder )</li><li name="e837" id="e837" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">++</code> — Increment numbers</li><li name="71ea" id="71ea" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">--</code> — Decrement numbers</li></ul><h3 name="5c56" id="5c56" class="graf graf--h3 graf-after--li">Comparison Operators</h3><ul class="postList"><li name="a2b0" id="a2b0" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">==</code> — Equal to</li><li name="5105" id="5105" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">===</code> — Equal value and equal type</li><li name="c79c" id="c79c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">!=</code> — Not equal</li><li name="1f7f" id="1f7f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">!==</code> — Not equal value or not equal type</li><li name="78c3" id="78c3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">&gt;</code> — Greater than</li><li name="d40b" id="d40b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">&lt;</code> — Less than</li><li name="081b" id="081b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">&gt;=</code> — Greater than or equal to</li><li name="d065" id="d065" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">&lt;=</code> — Less than or equal to</li><li name="174d" id="174d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">?</code> — Ternary operator</li></ul><h3 name="3394" id="3394" class="graf graf--h3 graf-after--li">Logical Operators</h3><ul class="postList"><li name="cb7b" id="cb7b" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">&amp;&amp;</code> — Logical and</li><li name="b1ee" id="b1ee" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">||</code> — Logical or</li><li name="96d4" id="96d4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">!</code> — Logical not</li></ul><h3 name="8145" id="8145" class="graf graf--h3 graf-after--li">Bitwise Operators</h3><ul class="postList"><li name="8cf7" id="8cf7" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">&amp;</code> — AND statement</li><li name="02d5" id="02d5" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">|</code> — OR statement</li><li name="e576" id="e576" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">~</code> — NOT</li><li name="9c66" id="9c66" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">^</code> — XOR</li><li name="b343" id="b343" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">&lt;&lt;</code> — Left shift</li><li name="52b1" id="52b1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">&gt;&gt;</code> — Right shift</li><li name="1b5c" id="1b5c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">&gt;&gt;&gt;</code> — Zero fill right shift</li></ul><h3 name="3ed3" id="3ed3" class="graf graf--h3 graf-after--li">Functions</h3><p name="329c" id="329c" class="graf graf--p graf-after--h3">JavaScript functions are blocks of code that perform a certain task. A basic function looks like this:</p><p name="7f2c" id="7f2c" class="graf graf--p graf-after--p">function name(parameter1, parameter2, parameter3) {</p><p name="909f" id="909f" class="graf graf--p graf-after--p">// what the function does</p><p name="e5e5" id="e5e5" class="graf graf--p graf-after--p">}</p><p name="0cf2" id="0cf2" class="graf graf--p graf-after--p">As you can see, it consists of the <code class="markup--code markup--p-code">function</code> keyword plus a name. The function’s parameters are in the brackets and you have curly brackets around what the function performs. You can create your own, but to make your life easier – there are also a number of default functions.</p><h3 name="c58d" id="c58d" class="graf graf--h3 graf-after--p">Outputting Data</h3><p name="6f3c" id="6f3c" class="graf graf--p graf-after--h3">A common application for functions is the output of data. For the output, you have the following options:</p><ul class="postList"><li name="a7a7" id="a7a7" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">alert()</code> — Output data in an alert box in the browser window</li><li name="0c44" id="0c44" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">confirm()</code> — Opens up a yes/no dialog and returns true/false depending on user click</li><li name="9690" id="9690" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">console.log()</code> — Writes information to the browser console, good for debugging purposes</li><li name="0d4d" id="0d4d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">document.write()</code> — Write directly to the HTML document</li><li name="16aa" id="16aa" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">prompt()</code> — Creates a dialogue for user input</li></ul><h3 name="6b28" id="6b28" class="graf graf--h3 graf-after--li">Global Functions</h3><p name="a069" id="a069" class="graf graf--p graf-after--h3">Global functions are functions built into every browser capable of running JavaScript.</p><ul class="postList"><li name="f4f1" id="f4f1" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">decodeURI()</code> — Decodes a <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier" data-href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier" class="markup--anchor markup--li-anchor" rel="noopener noreferrer noopener" target="_blank">Uniform Resource Identifier (URI)</a> created by <code class="markup--code markup--li-code">encodeURI</code> or similar</li><li name="c203" id="c203" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">decodeURIComponent()</code> — Decodes a URI component</li><li name="176a" id="176a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">encodeURI()</code> — Encodes a URI into UTF-8</li><li name="6720" id="6720" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">encodeURIComponent()</code> — Same but for URI components</li><li name="e97b" id="e97b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">eval()</code> — Evaluates JavaScript code represented as a string</li><li name="390b" id="390b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">isFinite()</code> — Determines whether a passed value is a finite number</li><li name="5d46" id="5d46" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">isNaN()</code> — Determines whether a value is NaN or not</li><li name="f668" id="f668" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Number()</code> —- Returns a number converted from its argument</li><li name="a5ff" id="a5ff" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">parseFloat()</code> — Parses an argument and returns a floating-point number</li><li name="a666" id="a666" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">parseInt()</code> — Parses its argument and returns an integer</li></ul><h3 name="a649" id="a649" class="graf graf--h3 graf-after--li">JavaScript Loops</h3><p name="6cff" id="6cff" class="graf graf--p graf-after--h3">Loops are part of most programming languages. They allow you to execute blocks of code desired number of times with different values:</p><p name="01bf" id="01bf" class="graf graf--p graf-after--p">for (before loop; condition <strong class="markup--strong markup--p-strong">for</strong> loop; execute after loop) {</p><p name="5eb2" id="5eb2" class="graf graf--p graf-after--p">// what to do during the loop</p><p name="e346" id="e346" class="graf graf--p graf-after--p">}</p><p name="ff25" id="ff25" class="graf graf--p graf-after--p">You have several parameters to create loops:</p><ul class="postList"><li name="ff62" id="ff62" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">for</code> — The most common way to create a loop in JavaScript</li><li name="7ad1" id="7ad1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">while</code> — Sets up conditions under which a loop executes</li><li name="c2f4" id="c2f4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">do while</code> — Similar to the <code class="markup--code markup--li-code">while</code> loop but it executes at least once and performs a check at the end to see if the condition is met to execute again</li><li name="7157" id="7157" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">break</code> —Used to stop and exit the cycle at certain conditions</li><li name="f5c0" id="f5c0" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">continue</code> — Skip parts of the cycle if certain conditions are met</li></ul><h3 name="ba4b" id="ba4b" class="graf graf--h3 graf-after--li">If — Else Statements</h3><p name="d781" id="d781" class="graf graf--p graf-after--h3">These types of statements are easy to understand. Using them, you can set conditions for when your code is executed. If certain conditions apply, something is done, if not — something else is executed.</p><p name="c7b4" id="c7b4" class="graf graf--p graf-after--p">if (condition) {</p><p name="a1cb" id="a1cb" class="graf graf--p graf-after--p">// what to do if condition is met</p><p name="6c77" id="6c77" class="graf graf--p graf-after--p">} <strong class="markup--strong markup--p-strong">else</strong> {</p><p name="99e2" id="99e2" class="graf graf--p graf-after--p">// what to do if condition is not met</p><p name="5fed" id="5fed" class="graf graf--p graf-after--p">}</p><p name="2f4c" id="2f4c" class="graf graf--p graf-after--p">A similar concept to <code class="markup--code markup--p-code">if else</code> is the <code class="markup--code markup--p-code">switch</code> statement. However, using the switch you select one of several code blocks to execute.</p><h3 name="f11b" id="f11b" class="graf graf--h3 graf-after--p">Strings</h3><p name="749a" id="749a" class="graf graf--p graf-after--h3">Strings are what JavaScript calls to text that does not perform a function but can appear on the screen.</p><p name="e87c" id="e87c" class="graf graf--p graf-after--p">var person = “John Doe”;</p><p name="c838" id="c838" class="graf graf--p graf-after--p">In this case, <code class="markup--code markup--p-code">John Doe</code> is the string.</p><h3 name="1169" id="1169" class="graf graf--h3 graf-after--p">Escape Characters</h3><p name="19ce" id="19ce" class="graf graf--p graf-after--h3">In JavaScript, strings are marked with single or double-quotes. If you want to use quotation marks in a string, you need to use special characters:</p><ul class="postList"><li name="b4b1" id="b4b1" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">\&#39;</code> — Single quote</li><li name="3b22" id="3b22" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\&quot;</code> — Double quote</li></ul><p name="d76f" id="d76f" class="graf graf--p graf-after--li">Aside from that you also have additional escape characters:</p><ul class="postList"><li name="b412" id="b412" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">\\</code> — Backslash</li><li name="1592" id="1592" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\b</code> — Backspace</li><li name="3a72" id="3a72" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\f</code> — Form feed</li><li name="145a" id="145a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\n</code> — New line</li><li name="1416" id="1416" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\r</code> — Carriage return</li><li name="95d4" id="95d4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\t</code> — Horizontal tabulator</li><li name="d962" id="d962" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\v</code> — Vertical tabulator</li></ul><h3 name="8f75" id="8f75" class="graf graf--h3 graf-after--li">String Methods</h3><p name="733b" id="733b" class="graf graf--p graf-after--h3">There are many different ways to work with strings:</p><ul class="postList"><li name="2021" id="2021" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">charAt()</code> — Returns a character at a specified position inside a string</li><li name="d3e5" id="d3e5" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">charCodeAt()</code> — Gives you the Unicode of a character at that position</li><li name="fdd1" id="fdd1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">concat()</code> — Concatenates (joins) two or more strings into one</li><li name="009c" id="009c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">fromCharCode()</code> — Returns a string created from the specified sequence of UTF-16 code units</li><li name="7ed3" id="7ed3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">indexOf()</code> — Provides the position of the first occurrence of a specified text within a string</li><li name="2937" id="2937" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">lastIndexOf()</code> — Same as <code class="markup--code markup--li-code">indexOf()</code> but with the last occurrence, searching backward</li><li name="142d" id="142d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">match()</code> — Retrieves the matches of a string against a search pattern</li><li name="6c18" id="6c18" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">replace()</code> — Find and replace specified text in a string</li><li name="e279" id="e279" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">search()</code> — Executes a search for a matching text and returns its position</li><li name="6bcd" id="6bcd" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">slice()</code> — Extracts a section of a string and returns it as a new string</li><li name="e4ee" id="e4ee" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">split()</code> — Splits a string object into an array of strings at a specified position</li><li name="3a27" id="3a27" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">substr()</code> — Similar to <code class="markup--code markup--li-code">slice()</code> but extracts a substring depending on a specified number of characters</li><li name="3d14" id="3d14" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">substring()</code> — Also similar to <code class="markup--code markup--li-code">slice()</code> but can’t accept negative indices</li><li name="fa33" id="fa33" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">toLowerCase()</code> — Convert strings to lower case</li><li name="3485" id="3485" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">toUpperCase()</code> — Convert strings to upper case</li><li name="4f96" id="4f96" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">valueOf()</code> — Returns the primitive value (that has no properties or methods) of a string object</li></ul><h3 name="cde1" id="cde1" class="graf graf--h3 graf-after--li">Regular Expression Syntax</h3><p name="85dc" id="85dc" class="graf graf--p graf-after--h3">Regular expressions are search patterns used to match character combinations in strings. The search pattern can be used for text search and text to replace operations.</p><h3 name="1a51" id="1a51" class="graf graf--h3 graf-after--p">Pattern Modifiers</h3><ul class="postList"><li name="bb29" id="bb29" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">e</code> — Evaluate replacement</li><li name="b6b8" id="b6b8" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">i</code> — Perform case-insensitive matching</li><li name="4f50" id="4f50" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">g</code> — Perform global matching</li><li name="4add" id="4add" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">m</code> — Perform multiple line matching</li><li name="a073" id="a073" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">s</code> — Treat strings as a single line</li><li name="482b" id="482b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">x</code> — Allow comments and whitespace in the pattern</li><li name="f6ad" id="f6ad" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">U</code> — Ungreedy pattern</li></ul><h3 name="f430" id="f430" class="graf graf--h3 graf-after--li">Brackets</h3><ul class="postList"><li name="aae1" id="aae1" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">[abc]</code> — Find any of the characters between the brackets</li><li name="e048" id="e048" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">[^abc]</code> — Find any character which is not in the brackets</li><li name="f9b5" id="f9b5" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">[0-9]</code> — Used to find any digit from 0 to 9</li><li name="ac71" id="ac71" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">[A-z]</code> — Find any character from uppercase A to lowercase z</li><li name="6fce" id="6fce" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">(a|b|c)</code> — Find any of the alternatives separated with <code class="markup--code markup--li-code">|</code></li></ul><h3 name="ef6e" id="ef6e" class="graf graf--h3 graf-after--li">Metacharacters</h3><ul class="postList"><li name="dcd6" id="dcd6" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">.</code> — Find a single character, except newline or line terminator</li><li name="e944" id="e944" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\w</code> — Word character</li><li name="c4bf" id="c4bf" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\W</code> — Non-word character</li><li name="7b81" id="7b81" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\d</code> — A digit</li><li name="a533" id="a533" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\D</code> — A non-digit character</li><li name="1fcc" id="1fcc" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\s</code> — Whitespace character</li><li name="374c" id="374c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\S</code> — Non-whitespace character</li><li name="72d0" id="72d0" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\b</code> — Find a match at the beginning/end of a word</li><li name="2d38" id="2d38" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\B</code> — A match not at the beginning/end of a word</li><li name="859b" id="859b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\0</code> — NUL character</li><li name="df4d" id="df4d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\n</code> — A new line character</li><li name="5acd" id="5acd" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\f</code> — Form feed character</li><li name="833f" id="833f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\r</code> — Carriage return character</li><li name="4f31" id="4f31" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\t</code> — Tab character</li><li name="e618" id="e618" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\v</code> — Vertical tab character</li><li name="dcfc" id="dcfc" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\xxx</code> — The character specified by an octal number xxx</li><li name="cf5e" id="cf5e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\xdd</code> — Character specified by a hexadecimal number dd</li><li name="978f" id="978f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\uxxxx</code> — The Unicode character specified by a hexadecimal number XXXX</li></ul><h3 name="ab62" id="ab62" class="graf graf--h3 graf-after--li">Quantifiers</h3><ul class="postList"><li name="e4cf" id="e4cf" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">n+</code> — Matches any string that contains at least one n</li><li name="be07" id="be07" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">n*</code> — Any string that contains zero or more occurrences of n</li><li name="4a93" id="4a93" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">n?</code> — A string that contains zero or one occurrence of n</li><li name="91f0" id="91f0" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">n{X}</code> — String that contains a sequence of X n’s</li><li name="097b" id="097b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">n{X,Y}</code> — Strings that contain a sequence of X to Y n’s</li><li name="e9f2" id="e9f2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">n{X,}</code> — Matches any string that contains a sequence of at least X n’s</li><li name="15b3" id="15b3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">n$</code> — Any string with n at the end of it</li><li name="5fc9" id="5fc9" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">^n</code> — String with n at the beginning of it</li><li name="2b42" id="2b42" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">?=n</code> — Any string that is followed by a specific string n</li><li name="6ffa" id="6ffa" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">?!n</code> — String that is not followed by a specific string ni</li></ul><h3 name="20fa" id="20fa" class="graf graf--h3 graf-after--li">Numbers and Math</h3><p name="54b2" id="54b2" class="graf graf--p graf-after--h3">In JavaScript, you can also work with numbers, constants and perform mathematical functions.</p><h3 name="2440" id="2440" class="graf graf--h3 graf-after--p">Number Properties</h3><ul class="postList"><li name="3554" id="3554" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">MAX_VALUE</code> — The maximum numeric value representable in JavaScript</li><li name="c55d" id="c55d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">MIN_VALUE</code> — Smallest positive numeric value representable in JavaScript</li><li name="49e0" id="49e0" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">NaN</code> — The “Not-a-Number” value</li><li name="3024" id="3024" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">NEGATIVE_INFINITY</code> — The negative Infinity value</li><li name="0bf4" id="0bf4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">POSITIVE_INFINITY</code> — Positive Infinity value</li></ul><h3 name="7d65" id="7d65" class="graf graf--h3 graf-after--li">Number Methods</h3><ul class="postList"><li name="9478" id="9478" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">toExponential()</code> — Returns the string with a rounded number written as exponential notation</li><li name="2ad0" id="2ad0" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">toFixed()</code> — Returns the string of a number with a specified number of decimals</li><li name="d464" id="d464" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">toPrecision()</code> — String of a number written with a specified length</li><li name="2244" id="2244" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">toString()</code> — Returns a number as a string</li><li name="bc1e" id="bc1e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">valueOf()</code> — Returns a number as a number</li></ul><h3 name="08ba" id="08ba" class="graf graf--h3 graf-after--li">Math Properties</h3><ul class="postList"><li name="9f68" id="9f68" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">E</code> — Euler’s number</li><li name="a4df" id="a4df" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">LN2</code> — The natural logarithm of 2</li><li name="0f06" id="0f06" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">LN10</code> — Natural logarithm of 10</li><li name="1a92" id="1a92" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">LOG2E</code> — Base 2 logarithm of E</li><li name="42e7" id="42e7" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">LOG10E</code> — Base 10 logarithm of E</li><li name="1fbe" id="1fbe" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">PI</code> — The number PI</li><li name="2a56" id="2a56" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">SQRT1_2</code> — Square root of 1/2</li><li name="aab4" id="aab4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">SQRT2</code> — The square root of 2</li></ul><h3 name="75f9" id="75f9" class="graf graf--h3 graf-after--li">Math Methods</h3><ul class="postList"><li name="8836" id="8836" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">abs(x)</code> — Returns the absolute (positive) value of x</li><li name="ddb9" id="ddb9" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">acos(x)</code> — The arccosine of x, in radians</li><li name="a0c3" id="a0c3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">asin(x)</code> — Arcsine of x, in radians</li><li name="c2ca" id="c2ca" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">atan(x)</code> — The arctangent of x as a numeric value</li><li name="8b93" id="8b93" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">atan2(y,x)</code> — Arctangent of the quotient of its arguments</li><li name="b103" id="b103" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ceil(x)</code> — Value of x rounded up to its nearest integer</li><li name="c68a" id="c68a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">cos(x)</code> — The cosine of x (x is in radians)</li><li name="d480" id="d480" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">exp(x)</code> — Value of Ex</li><li name="2954" id="2954" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">floor(x)</code> — The value of x rounded down to its nearest integer</li><li name="ff4d" id="ff4d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">log(x)</code> — The natural logarithm (base E) of x</li><li name="b6a9" id="b6a9" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">max(x,y,z,...,n)</code> — Returns the number with the highest value</li><li name="dfb0" id="dfb0" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">min(x,y,z,...,n)</code> — Same for the number with the lowest value</li><li name="a6f1" id="a6f1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">pow(x,y)</code> — X to the power of y</li><li name="8851" id="8851" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">random()</code> — Returns a random number between 0 and 1</li><li name="d32e" id="d32e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">round(x)</code> — The value of x rounded to its nearest integer</li><li name="fe9a" id="fe9a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">sin(x)</code> — The sine of x (x is in radians)</li><li name="c244" id="c244" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">sqrt(x)</code> — Square root of x</li><li name="b5ef" id="b5ef" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">tan(x)</code> — The tangent of an angle</li></ul><h3 name="81f5" id="81f5" class="graf graf--h3 graf-after--li">Dealing with Dates in JavaScript</h3><p name="45cb" id="45cb" class="graf graf--p graf-after--h3">You can also work with and modify dates and time with JavaScript. This is the next chapter in the JavaScript cheat sheet.</p><h3 name="9b09" id="9b09" class="graf graf--h3 graf-after--p">Setting Dates</h3><ul class="postList"><li name="b187" id="b187" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">Date()</code> — Creates a new date object with the current date and time</li><li name="42f8" id="42f8" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Date(2017, 5, 21, 3, 23, 10, 0)</code> — Create a custom date object. The numbers represent a year, month, day, hour, minutes, seconds, milliseconds. You can omit anything you want except for a year and month.</li><li name="4e80" id="4e80" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Date(&quot;2017-06-23&quot;)</code> — Date declaration as a string</li></ul><h3 name="b746" id="b746" class="graf graf--h3 graf-after--li">Pulling Date and Time Values</h3><ul class="postList"><li name="465e" id="465e" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">getDate()</code> — Get the day of the month as a number (1-31)</li><li name="1b08" id="1b08" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getDay()</code> — The weekday as a number (0-6)</li><li name="6d9e" id="6d9e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getFullYear()</code> — Year as a four-digit number (yyyy)</li><li name="a216" id="a216" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getHours()</code> — Get the hour (0-23)</li><li name="388a" id="388a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getMilliseconds()</code> — The millisecond (0-999)</li><li name="a97f" id="a97f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getMinutes()</code> — Get the minute (0-59)</li><li name="2427" id="2427" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getMonth()</code> — Month as a number (0-11)</li><li name="b964" id="b964" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getSeconds()</code> — Get the second (0-59)</li><li name="505d" id="505d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getTime()</code> — Get the milliseconds since January 1, 1970</li><li name="7c14" id="7c14" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getUTCDate()</code> — The day (date) of the month in the specified date according to universal time (also available for day, month, full year, hours, minutes etc.)</li><li name="d6b6" id="d6b6" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">parse</code> — Parses a string representation of a date and returns the number of milliseconds since January 1, 1970</li></ul><h3 name="ec7c" id="ec7c" class="graf graf--h3 graf-after--li">Set Part of a Date</h3><ul class="postList"><li name="9a97" id="9a97" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">setDate()</code> — Set the day as a number (1-31)</li><li name="d4f0" id="d4f0" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setFullYear()</code> — Sets the year (optionally month and day)</li><li name="1a45" id="1a45" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setHours()</code> — Set the hour (0-23)</li><li name="8020" id="8020" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setMilliseconds()</code> — Set milliseconds (0-999)</li><li name="7feb" id="7feb" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setMinutes()</code> — Sets the minutes (0-59)</li><li name="d7ca" id="d7ca" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setMonth()</code> — Set the month (0-11)</li><li name="795d" id="795d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setSeconds()</code> — Sets the seconds (0-59)</li><li name="1d7f" id="1d7f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setTime()</code> — Set the time (milliseconds since January 1, 1970)</li><li name="78e1" id="78e1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setUTCDate()</code> — Sets the day of the month for a specified date according to universal time (also available for day, month, full year, hours, minutes etc.)</li></ul><h3 name="ad01" id="ad01" class="graf graf--h3 graf-after--li">DOM Mode</h3><p name="0231" id="0231" class="graf graf--p graf-after--h3">The DOM is the <a href="https://en.wikipedia.org/wiki/Document_Object_Model" data-href="https://en.wikipedia.org/wiki/Document_Object_Model" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank">Document Object Model</a> of a page. It is the code of the structure of a webpage. JavaScript comes with a lot of different ways to create and manipulate HTML elements (called nodes).</p><h3 name="3ace" id="3ace" class="graf graf--h3 graf-after--p">Node Properties</h3><ul class="postList"><li name="cfb7" id="cfb7" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">attributes</code> — Returns a live collection of all attributes registered to an element</li><li name="6138" id="6138" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">baseURI</code> — Provides the absolute base URL of an HTML element</li><li name="34da" id="34da" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">childNodes</code> — Gives a collection of an element’s child nodes</li><li name="58ec" id="58ec" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">firstChild</code> — Returns the first child node of an element</li><li name="2f34" id="2f34" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">lastChild</code> — The last child node of an element</li><li name="fdea" id="fdea" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">nextSibling</code> — Gives you the next node at the same node tree level</li><li name="1ca4" id="1ca4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">nodeName</code> —Returns the name of a node</li><li name="d4ee" id="d4ee" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">nodeType</code> — Returns the type of a node</li><li name="cd22" id="cd22" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">nodeValue</code> — Sets or returns the value of a node</li><li name="a9a3" id="a9a3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ownerDocument</code> — The top-level document object for this node</li><li name="51b4" id="51b4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">parentNode</code> — Returns the parent node of an element</li><li name="31ef" id="31ef" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">previousSibling</code> — Returns the node immediately preceding the current one</li><li name="ec40" id="ec40" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">textContent</code> — Sets or returns the textual content of a node and its descendants</li></ul><h3 name="6265" id="6265" class="graf graf--h3 graf-after--li">Node Methods</h3><ul class="postList"><li name="7f05" id="7f05" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">appendChild()</code> — Adds a new child node to an element as the last child node</li><li name="3b3a" id="3b3a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">cloneNode()</code> — Clones an HTML element</li><li name="661c" id="661c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">compareDocumentPosition()</code> — Compares the document position of two elements</li><li name="86d2" id="86d2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getFeature()</code> — Returns an object which implements the APIs of a specified feature</li><li name="059c" id="059c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">hasAttributes()</code> — Returns true if an element has any attributes, otherwise false</li><li name="5d0d" id="5d0d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">hasChildNodes()</code> — Returns true if an element has any child nodes, otherwise false</li><li name="4c86" id="4c86" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">insertBefore()</code> — Inserts a new child node before a specified, existing child node</li><li name="4b38" id="4b38" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">isDefaultNamespace()</code> — Returns true if a specified namespaceURI is the default, otherwise false</li><li name="8c4e" id="8c4e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">isEqualNode()</code> — Checks if two elements are equal</li><li name="2f6a" id="2f6a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">isSameNode()</code> — Checks if two elements are the same node</li><li name="944e" id="944e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">isSupported()</code> — Returns true if a specified feature is supported on the element</li><li name="b7ef" id="b7ef" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">lookupNamespaceURI()</code> — Returns the namespace URI associated with a given node</li><li name="5f59" id="5f59" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">lookupPrefix()</code> — Returns a DOMString containing the prefix for a given namespace URI if present</li><li name="6670" id="6670" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">normalize()</code> — Joins adjacent text nodes and removes empty text nodes in an element</li><li name="c80a" id="c80a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">removeChild()</code> — Removes a child node from an element</li><li name="8108" id="8108" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">replaceChild()</code> — Replaces a child node in an element</li></ul><h3 name="4b24" id="4b24" class="graf graf--h3 graf-after--li">Element Methods</h3><ul class="postList"><li name="9530" id="9530" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">getAttribute()</code> — Returns the specified attribute value of an element node</li><li name="0dd1" id="0dd1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getAttributeNS()</code> — Returns string value of the attribute with the specified namespace and name</li><li name="8a0d" id="8a0d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getAttributeNode()</code> — Gets the specified attribute node</li><li name="fc41" id="fc41" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getAttributeNodeNS()</code> — Returns the attribute node for the attribute with the given namespace and name</li><li name="2a3e" id="2a3e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getElementsByTagName()</code> — Provides a collection of all child elements with the specified tag name</li><li name="11a4" id="11a4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getElementsByTagNameNS()</code> — Returns a live HTMLCollection of elements with a certain tag name belonging to the given namespace</li><li name="e2ae" id="e2ae" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">hasAttribute()</code> — Returns true if an element has any attributes, otherwise false</li><li name="17dd" id="17dd" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">hasAttributeNS()</code> — Provides a true/false value indicating whether the current element in a given namespace has the specified attribute</li><li name="f28c" id="f28c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">removeAttribute()</code> — Removes a specified attribute from an element</li><li name="8cd0" id="8cd0" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">removeAttributeNS()</code> — Removes the specified attribute from an element within a certain namespace</li><li name="e6c3" id="e6c3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">removeAttributeNode()</code> — Takes away a specified attribute node and returns the removed node</li><li name="a7b9" id="a7b9" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setAttribute()</code> — Sets or changes the specified attribute to a specified value</li><li name="bf42" id="bf42" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setAttributeNS()</code> — Adds a new attribute or changes the value of an attribute with the given namespace and name</li><li name="2322" id="2322" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setAttributeNode()</code> — Sets or changes the specified attribute node</li><li name="0540" id="0540" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setAttributeNodeNS()</code> — Adds a new namespaced attribute node to an element</li></ul><h3 name="a1d1" id="a1d1" class="graf graf--h3 graf-after--li">Working with the User Browser</h3><p name="c351" id="c351" class="graf graf--p graf-after--h3">Besides HTML elements, JavaScript is also able to take into account the user browser and incorporate its properties into the code.</p><h3 name="7362" id="7362" class="graf graf--h3 graf-after--p">Window Properties</h3><ul class="postList"><li name="1b1f" id="1b1f" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">closed</code> — Checks whether a window has been closed or not and returns true or false</li><li name="805f" id="805f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">defaultStatus</code> — Sets or returns the default text in the status bar of a window</li><li name="458e" id="458e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">document</code> — Returns the document object for the window</li><li name="93ee" id="93ee" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">frames</code> — Returns all <code class="markup--code markup--li-code">&lt;iframe&gt;</code> elements in the current window</li><li name="c42a" id="c42a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">history</code> — Provides the History object for the window</li><li name="3a5d" id="3a5d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">innerHeight</code> — The inner height of a window’s content area</li><li name="c609" id="c609" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">innerWidth</code> — The inner width of the content area</li><li name="5167" id="5167" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">length</code> — Find out the number of <code class="markup--code markup--li-code">&lt;iframe&gt;</code> elements in the window</li><li name="4f05" id="4f05" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">location</code> — Returns the location object for the window</li><li name="4125" id="4125" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">name</code> — Sets or returns the name of a window</li><li name="3d7f" id="3d7f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">navigator</code> — Returns the Navigator object for the window</li><li name="c601" id="c601" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">opener</code> — Returns a reference to the window that created the window</li><li name="734e" id="734e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">outerHeight</code> — The outer height of a window, including toolbars/scrollbars</li><li name="9b0a" id="9b0a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">outerWidth</code> — The outer width of a window, including toolbars/scrollbars</li><li name="3140" id="3140" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">pageXOffset</code> — Number of pixels the current document has been scrolled horizontally</li><li name="0bcc" id="0bcc" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">pageYOffset</code> — Number of pixels the document has been scrolled vertically</li><li name="a2af" id="a2af" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">parent</code> — The parent window of the current window</li><li name="3634" id="3634" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">screen</code> — Returns the Screen object for the window</li><li name="9566" id="9566" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">screenLeft</code> — The horizontal coordinate of the window (relative to the screen)</li><li name="1245" id="1245" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">screenTop</code> — The vertical coordinate of the window</li><li name="5656" id="5656" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">screenX</code> — Same as <code class="markup--code markup--li-code">screenLeft</code> but needed for some browsers</li><li name="21e7" id="21e7" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">screenY</code> — Same as <code class="markup--code markup--li-code">screenTop</code> but needed for some browsers</li><li name="d000" id="d000" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">self</code> — Returns the current window</li><li name="99af" id="99af" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">status</code> — Sets or returns the text in the status bar of a window</li><li name="0a0f" id="0a0f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">top</code> — Returns the topmost browser window</li></ul><h3 name="496d" id="496d" class="graf graf--h3 graf-after--li">Window Methods</h3><ul class="postList"><li name="5715" id="5715" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">alert()</code> — Displays an alert box with a message and an OK button</li><li name="4afc" id="4afc" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">blur()</code> — Removes focus from the current window</li><li name="ef9a" id="ef9a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">clearInterval()</code> — Clears a timer set with <code class="markup--code markup--li-code">setInterval()</code></li><li name="fa72" id="fa72" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">clearTimeout()</code> — Clears a timer set with <code class="markup--code markup--li-code">setTimeout()</code></li><li name="7bce" id="7bce" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">close()</code> — Closes the current window</li><li name="ccbf" id="ccbf" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">confirm()</code> — Displays a dialogue box with a message and an <em class="markup--em markup--li-em">OK</em> and <em class="markup--em markup--li-em">Cancel</em> button</li><li name="e6f2" id="e6f2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">focus()</code> — Sets focus to the current window</li><li name="5eb7" id="5eb7" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">moveBy()</code> — Moves a window relative to its current position</li><li name="16b6" id="16b6" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">moveTo()</code> — Moves a window to a specified position</li><li name="32d8" id="32d8" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">open()</code> — Opens a new browser window</li><li name="4198" id="4198" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">print()</code> — Prints the content of the current window</li><li name="3bec" id="3bec" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">prompt()</code> — Displays a dialogue box that prompts the visitor for input</li><li name="e16a" id="e16a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">resizeBy()</code> — Resizes the window by the specified number of pixels</li><li name="31c8" id="31c8" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">resizeTo()</code> — Resizes the window to a specified width and height</li><li name="6c44" id="6c44" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">scrollBy()</code> — Scrolls the document by a specified number of pixels</li><li name="959f" id="959f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">scrollTo()</code> — Scrolls the document to specified coordinates</li><li name="704a" id="704a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setInterval()</code> — Calls a function or evaluates an expression at specified intervals</li><li name="87c3" id="87c3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">setTimeout()</code> — Calls a function or evaluates an expression after a specified interval</li><li name="1cde" id="1cde" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">stop()</code> — Stops the window from loading</li></ul><h3 name="8cf2" id="8cf2" class="graf graf--h3 graf-after--li">Screen Properties</h3><ul class="postList"><li name="7e50" id="7e50" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">availHeight</code> — Returns the height of the screen (excluding the Windows Taskbar)</li><li name="d7ea" id="d7ea" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">availWidth</code> — Returns the width of the screen (excluding the Windows Taskbar)</li><li name="4feb" id="4feb" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">colorDepth</code> — Returns the bit depth of the color palette for displaying images</li><li name="f2f7" id="f2f7" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">height</code> — The total height of the screen</li><li name="8e22" id="8e22" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">pixelDepth</code> — The color resolution of the screen in bits per pixel</li><li name="bc5a" id="bc5a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">width</code> — The total width of the screen</li></ul><h3 name="4828" id="4828" class="graf graf--h3 graf-after--li">JavaScript Events</h3><p name="1204" id="1204" class="graf graf--p graf-after--h3">Events are things that can happen to HTML elements and are performed by the user. The programming language can listen for these events and trigger actions in the code. No JavaScript cheat sheet would be complete without them.</p><h3 name="9d10" id="9d10" class="graf graf--h3 graf-after--p">Mouse</h3><ul class="postList"><li name="9546" id="9546" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">onclick</code> — The event occurs when the user clicks on an element</li><li name="9b50" id="9b50" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">oncontextmenu</code> — User right-clicks on an element to open a context menu</li><li name="147a" id="147a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ondblclick</code> — The user double-clicks on an element</li><li name="3720" id="3720" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onmousedown</code> — User presses a mouse button over an element</li><li name="a40a" id="a40a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onmouseenter</code> — The pointer moves onto an element</li><li name="345e" id="345e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onmouseleave</code> — Pointer moves out of an element</li><li name="79b1" id="79b1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onmousemove</code> — The pointer is moving while it is over an element</li><li name="fa70" id="fa70" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onmouseover</code> — When the pointer is moved onto an element or one of its children</li><li name="94f8" id="94f8" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onmouseout</code> — User moves the mouse pointer out of an element or one of its children</li><li name="486e" id="486e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onmouseup</code> — The user releases a mouse button while over an element</li></ul><h3 name="0fc7" id="0fc7" class="graf graf--h3 graf-after--li">Keyboard</h3><ul class="postList"><li name="6a8f" id="6a8f" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">onkeydown</code> — When the user is pressing a key down</li><li name="0647" id="0647" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onkeypress</code> — The moment the user starts pressing a key</li><li name="ff0f" id="ff0f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onkeyup</code> — The user releases a key</li></ul><h3 name="5462" id="5462" class="graf graf--h3 graf-after--li">Frame</h3><ul class="postList"><li name="9d29" id="9d29" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">onabort</code> — The loading of a media is aborted</li><li name="baa4" id="baa4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onbeforeunload</code> — Event occurs before the document is about to be unloaded</li><li name="740e" id="740e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onerror</code> — An error occurs while loading an external file</li><li name="be95" id="be95" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onhashchange</code> — There have been changes to the anchor part of a URL</li><li name="d0fd" id="d0fd" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onload</code> — When an object has loaded</li><li name="65e5" id="65e5" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onpagehide</code> — The user navigates away from a webpage</li><li name="aae6" id="aae6" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onpageshow</code> — When the user navigates to a webpage</li><li name="e3dc" id="e3dc" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onresize</code> — The document view is resized</li><li name="96c8" id="96c8" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onscroll</code> — An element’s scrollbar is being scrolled</li><li name="f2fa" id="f2fa" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onunload</code> — Event occurs when a page has unloaded</li></ul><h3 name="2a31" id="2a31" class="graf graf--h3 graf-after--li">Form</h3><ul class="postList"><li name="731a" id="731a" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">onblur</code> — When an element loses focus</li><li name="facf" id="facf" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onchange</code> — The content of a form element changes (for <code class="markup--code markup--li-code">&lt;input&gt;</code>, <code class="markup--code markup--li-code">&lt;select&gt;</code> and <code class="markup--code markup--li-code">&lt;textarea&gt;</code>)</li><li name="7a0a" id="7a0a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onfocus</code> — An element gets focus</li><li name="5188" id="5188" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onfocusin</code> — When an element is about to get focus</li><li name="594a" id="594a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onfocusout</code> — The element is about to lose focus</li><li name="700e" id="700e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">oninput</code> — User input on an element</li><li name="dd0f" id="dd0f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">oninvalid</code> — An element is invalid</li><li name="6cad" id="6cad" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onreset</code> — A form is reset</li><li name="f4f2" id="f4f2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onsearch</code> — The user writes something in a search field (for <code class="markup--code markup--li-code">&lt;input=&quot;search&quot;&gt;</code>)</li><li name="32a9" id="32a9" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onselect</code> — The user selects some text (for <code class="markup--code markup--li-code">&lt;input&gt;</code> and <code class="markup--code markup--li-code">&lt;textarea&gt;</code>)</li><li name="3e1d" id="3e1d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onsubmit</code> — A form is submitted</li></ul><h3 name="d109" id="d109" class="graf graf--h3 graf-after--li">Drag</h3><ul class="postList"><li name="912c" id="912c" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">ondrag</code> — An element is dragged</li><li name="6897" id="6897" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ondragend</code> — The user has finished dragging the element</li><li name="8225" id="8225" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ondragenter</code> — The dragged element enters a drop target</li><li name="cf37" id="cf37" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ondragleave</code> — A dragged element leaves the drop target</li><li name="5bc3" id="5bc3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ondragover</code> — The dragged element is on top of the drop target</li><li name="2b0c" id="2b0c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ondragstart</code> — User starts to drag an element</li><li name="8e24" id="8e24" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ondrop</code> — Dragged element is dropped on the drop target</li></ul><h3 name="78c5" id="78c5" class="graf graf--h3 graf-after--li">Clipboard</h3><ul class="postList"><li name="c299" id="c299" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">oncopy</code> — User copies the content of an element</li><li name="267c" id="267c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">oncut</code> — The user cuts an element’s content</li><li name="e33c" id="e33c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onpaste</code> — A user pastes the content in an element</li></ul><h3 name="2d40" id="2d40" class="graf graf--h3 graf-after--li">Media</h3><ul class="postList"><li name="e0ab" id="e0ab" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">onabort</code> — Media loading is aborted</li><li name="0758" id="0758" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">oncanplay</code> — The browser can start playing media (e.g. a file has buffered enough)</li><li name="0bc2" id="0bc2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">oncanplaythrough</code> — The browser can play through media without stopping</li><li name="4c27" id="4c27" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ondurationchange</code> — The duration of the media changes</li><li name="aa9a" id="aa9a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onended</code> — The media has reached its end</li><li name="25b8" id="25b8" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onerror</code> — Happens when an error occurs while loading an external file</li><li name="cdf4" id="cdf4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onloadeddata</code> — Media data is loaded</li><li name="edce" id="edce" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onloadedmetadata</code> — Metadata (like dimensions and duration) are loaded</li><li name="7928" id="7928" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onloadstart</code> — The browser starts looking for specified media</li><li name="159c" id="159c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onpause</code> — Media is paused either by the user or automatically</li><li name="057f" id="057f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onplay</code> — The media has been started or is no longer paused</li><li name="ce2a" id="ce2a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onplaying</code> — Media is playing after having been paused or stopped for buffering</li><li name="2655" id="2655" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onprogress</code> — The browser is in the process of downloading the media</li><li name="a11c" id="a11c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onratechange</code> — The playing speed of the media changes</li><li name="f8bb" id="f8bb" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onseeked</code> — User is finished moving/skipping to a new position in the media</li><li name="9895" id="9895" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onseeking</code> — The user starts moving/skipping</li><li name="c636" id="c636" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onstalled</code> — The browser is trying to load the media but it is not available</li><li name="6480" id="6480" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onsuspend</code> — The browser is intentionally not loading media</li><li name="f94b" id="f94b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ontimeupdate</code> — The playing position has changed (e.g. because of fast forward)</li><li name="e96b" id="e96b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onvolumechange</code> — Media volume has changed (including mute)</li><li name="9fe8" id="9fe8" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onwaiting</code> — Media paused but expected to resume (for example, buffering)</li></ul><h3 name="24b7" id="24b7" class="graf graf--h3 graf-after--li">Animation</h3><ul class="postList"><li name="4497" id="4497" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">animationend</code> — A CSS animation is complete</li><li name="fc16" id="fc16" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">animationiteration</code> — CSS animation is repeated</li><li name="0f40" id="0f40" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">animationstart</code> — CSS animation has started</li></ul><h3 name="31f2" id="31f2" class="graf graf--h3 graf-after--li">Other</h3><ul class="postList"><li name="614b" id="614b" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">transitionend</code> — Fired when a CSS transition has completed</li><li name="5a40" id="5a40" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onmessage</code> — A message is received through the event source</li><li name="0dad" id="0dad" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onoffline</code> — The browser starts to work offline</li><li name="058e" id="058e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ononline</code> — The browser starts to work online</li><li name="090a" id="090a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onpopstate</code> — When the window’s history changes</li><li name="d940" id="d940" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onshow</code> — A <code class="markup--code markup--li-code">&lt;menu&gt;</code> element is shown as a context menu</li><li name="3062" id="3062" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onstorage</code> — A Web Storage area is updated</li><li name="2681" id="2681" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ontoggle</code> — The user opens or closes the <code class="markup--code markup--li-code">&lt;details&gt;</code> element</li><li name="6a40" id="6a40" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">onwheel</code> — Mouse wheel rolls up or down over an element</li><li name="7178" id="7178" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ontouchcancel</code> — Screen-touch is interrupted</li><li name="bec5" id="bec5" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ontouchend</code> — User’s finger is removed from a touch-screen</li><li name="3b60" id="3b60" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ontouchmove</code> — A finger is dragged across the screen</li><li name="3c0e" id="3c0e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ontouchstart</code> — A finger is placed on the touch-screen</li></ul><h3 name="8c94" id="8c94" class="graf graf--h3 graf-after--li">Errors</h3><p name="49e4" id="49e4" class="graf graf--p graf-after--h3">When working with JavaScript, different errors can occur. There are several ways of handling them:</p><ul class="postList"><li name="54c9" id="54c9" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">try</code> — Lets you define a block of code to test for errors</li><li name="cb14" id="cb14" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">catch</code> — Set up a block of code to execute in case of an error</li><li name="6a5b" id="6a5b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">throw</code> — Create custom error messages instead of the standard JavaScript errors</li><li name="6aea" id="6aea" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">finally</code> — Lets you execute code, after try and catch, regardless of the result</li></ul><h3 name="b821" id="b821" class="graf graf--h3 graf-after--li">Error Name Values</h3><p name="c937" id="c937" class="graf graf--p graf-after--h3">JavaScript also has a built-in error object. It has two properties:</p><ul class="postList"><li name="ca3b" id="ca3b" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">name</code> — Sets or returns the error name</li><li name="7047" id="7047" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">message</code> — Sets or returns an error message in a string from</li></ul><p name="a5d3" id="a5d3" class="graf graf--p graf-after--li">The error property can return six different values as its name:</p><ul class="postList"><li name="b389" id="b389" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">EvalError</code> — An error has occurred in the <code class="markup--code markup--li-code">eval()</code> function</li><li name="570c" id="570c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">RangeError</code> — A number is “out of range”</li><li name="2352" id="2352" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ReferenceError</code> — An illegal reference has occurred</li><li name="5019" id="5019" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">SyntaxError</code> — A syntax error has occurred</li><li name="0527" id="0527" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">TypeError</code> — A type error has occurred</li><li name="02a3" id="02a3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">URIError</code> — An <code class="markup--code markup--li-code">encodeURI()</code> error has occurred</li></ul><figure name="c271" id="c271" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/bgoonz/736fce1327efdde3afc50229f5ce51f6#file-javascript-cheat-sheet-js.js"></script></figure><h3 name="c34b" id="c34b" class="graf graf--h3 graf-after--figure">Explicit Conversions</h3><p name="35b6" id="35b6" class="graf graf--p graf-after--h3">The simplest way to perform an explicit type conversion is to use the <code class="markup--code markup--p-code">Boolean(), Number()</code>, and <code class="markup--code markup--p-code">String()</code> functions.</p><p name="eb59" id="eb59" class="graf graf--p graf-after--p">Any value other than <code class="markup--code markup--p-code">null </code>or <code class="markup--code markup--p-code">undefined </code>has a<code class="markup--code markup--p-code"> toString()</code> method.</p><p name="b560" id="b560" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toString(2);</code></p><p name="43d5" id="43d5" class="graf graf--p graf-after--p">binary</p><p name="1a0d" id="1a0d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toString(8);</code></p><p name="53ef" id="53ef" class="graf graf--p graf-after--p">octal</p><p name="3276" id="3276" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toString(16);</code></p><p name="4ea0" id="4ea0" class="graf graf--p graf-after--p">hex</p><p name="a97c" id="a97c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let n = 123456.789;</code></p><p name="3eed" id="3eed" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toFixed(0)</code></p><p name="21b3" id="21b3" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“123457”</p><p name="3a3f" id="3a3f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toFixed(5)</code></p><p name="4f28" id="4f28" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“123456.78900”</p><p name="1949" id="1949" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toExponential(3)</code></p><p name="ee84" id="ee84" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“1.235e+5”</p><p name="1462" id="1462" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toPrecision(7)</code></p><p name="9908" id="9908" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“123456.8”</p><p name="bd34" id="bd34" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toPrecision(10)</code></p><p name="57de" id="57de" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“123456.7890”</p><p name="a4ac" id="a4ac" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseInt(&quot;3 blind mice&quot;)</code></p><p name="af5f" id="af5f" class="graf graf--p graf-after--p">3</p><p name="fecd" id="fecd" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseFloat(&quot; 3.14 meters&quot;)</code></p><p name="e720" id="e720" class="graf graf--p graf-after--p">3.14</p><p name="a7f1" id="a7f1" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseInt(&quot;-12.34&quot;)</code></p><p name="47e8" id="47e8" class="graf graf--p graf-after--p">-12</p><p name="ce73" id="ce73" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseInt(&quot;0xFF&quot;)</code></p><p name="248d" id="248d" class="graf graf--p graf-after--p">255</p><h3 name="6d5b" id="6d5b" class="graf graf--h3 graf-after--p">Types, Values, and Variables</h3><h3 name="6a7c" id="6a7c" class="graf graf--h3 graf-after--h3">Links</h3><p name="5814" id="5814" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Resource</strong></p><p name="2b4e" id="2b4e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">URL</strong></p><p name="20f8" id="20f8" class="graf graf--p graf-after--p">MDN</p><p name="c485" id="c485" class="graf graf--p graf-after--p"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></p><p name="b6ef" id="b6ef" class="graf graf--p graf-after--p">Run Snippets</p><p name="35ab" id="35ab" class="graf graf--p graf-after--p"><a href="https://developers.google.com/web/tools/chrome-devtools/javascript/snippets" data-href="https://developers.google.com/web/tools/chrome-devtools/javascript/snippets" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://developers.google.com/web/tools/chrome-devtools/javascript/snippets</a></p><h3 name="598d" id="598d" class="graf graf--h3 graf-after--p">Explicit Conversions</h3><p name="1ea8" id="1ea8" class="graf graf--p graf-after--h3">The simplest way to perform an explicit type conversion is to use the <code class="markup--code markup--p-code">Boolean(), Number()</code>, and <code class="markup--code markup--p-code">String()</code> functions.</p><p name="7fca" id="7fca" class="graf graf--p graf-after--p">Any value other than <code class="markup--code markup--p-code">null </code>or <code class="markup--code markup--p-code">undefined </code>has a<code class="markup--code markup--p-code"> toString()</code> method.</p><p name="7391" id="7391" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toString(2);</code></p><p name="603e" id="603e" class="graf graf--p graf-after--p">binary</p><p name="8111" id="8111" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toString(8);</code></p><p name="c6af" id="c6af" class="graf graf--p graf-after--p">octal</p><p name="b380" id="b380" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toString(16);</code></p><p name="d250" id="d250" class="graf graf--p graf-after--p">hex</p><p name="59e4" id="59e4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let n = 123456.789;</code></p><p name="332b" id="332b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toFixed(0)</code></p><p name="b5e6" id="b5e6" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“123457”</p><p name="fde3" id="fde3" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toFixed(5)</code></p><p name="b105" id="b105" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“123456.78900”</p><p name="1db6" id="1db6" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toExponential(3)</code></p><p name="bd92" id="bd92" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“1.235e+5”</p><p name="ac9e" id="ac9e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toPrecision(7)</code></p><p name="ff5d" id="ff5d" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“123456.8”</p><p name="bc8c" id="bc8c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">n.toPrecision(10)</code></p><p name="6b90" id="6b90" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“123456.7890”</p><p name="5f7c" id="5f7c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseInt(&quot;3 blind mice&quot;)</code></p><p name="4886" id="4886" class="graf graf--p graf-after--p">3</p><p name="86ac" id="86ac" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseFloat(&quot; 3.14 meters&quot;)</code></p><p name="157d" id="157d" class="graf graf--p graf-after--p">3.14</p><p name="2471" id="2471" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseInt(&quot;-12.34&quot;)</code></p><p name="b7bf" id="b7bf" class="graf graf--p graf-after--p">-12</p><p name="216e" id="216e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseInt(&quot;0xFF&quot;)</code></p><p name="1de5" id="1de5" class="graf graf--p graf-after--p">255</p><p name="6785" id="6785" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseInt(&quot;0xff&quot;)</code></p><p name="c68d" id="c68d" class="graf graf--p graf-after--p">255</p><p name="fc4a" id="fc4a" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseInt(&quot;-0XFF&quot;)</code></p><p name="dfc7" id="dfc7" class="graf graf--p graf-after--p">-255</p><p name="8e30" id="8e30" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseInt(&quot;0.1&quot;)</code></p><p name="68f0" id="68f0" class="graf graf--p graf-after--p">0</p><p name="bd07" id="bd07" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseInt(&quot;.1&quot;)</code></p><p name="3a35" id="3a35" class="graf graf--p graf-after--p">NaN: integers can’t start with “.”</p><p name="7690" id="7690" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseFloat(&quot;$72.47&quot;)</code></p><p name="6d68" id="6d68" class="graf graf--p graf-after--p">NaN: numbers can’t start with “$”</p><p name="d098" id="d098" class="graf graf--p graf-after--p">Supply Radix</p><p name="399f" id="399f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseInt(&quot;11&quot;, 2)</code></p><p name="ad63" id="ad63" class="graf graf--p graf-after--p">3</p><p name="420d" id="420d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseInt(&quot;ff&quot;, 16)</code></p><p name="9b74" id="9b74" class="graf graf--p graf-after--p">255</p><p name="8f7f" id="8f7f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">parseInt(&quot;077&quot;, 8)</code></p><p name="91e0" id="91e0" class="graf graf--p graf-after--p">63</p><h3 name="34e6" id="34e6" class="graf graf--h3 graf-after--p">Conversion Idioms</h3><p name="880e" id="880e" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">x + &quot;&quot;</code></p><p name="68b2" id="68b2" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">String(x)</code></p><p name="ed8d" id="ed8d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">+x</code></p><p name="c452" id="c452" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Number(x)</code></p><p name="1cd4" id="1cd4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">x-0</code></p><p name="fc79" id="fc79" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Number(x)</code></p><p name="05be" id="05be" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">!!x</code></p><p name="6f75" id="6f75" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Boolean(x)</code></p><h3 name="ec2e" id="ec2e" class="graf graf--h3 graf-after--p">Destructuring Assignment</h3><p name="6f4e" id="6f4e" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">let [x,y] = [1,2];</code></p><p name="3dc4" id="3dc4" class="graf graf--p graf-after--p">let x=1, y=2</p><p name="1601" id="1601" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[x,y] = [x + 1,y + 1];</code></p><p name="6e2a" id="6e2a" class="graf graf--p graf-after--p">x = x + 1, y = y + 1</p><p name="548f" id="548f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[x,y] = [y,x];</code></p><p name="daed" id="daed" class="graf graf--p graf-after--p">Swap the value of the two variables</p><p name="17bf" id="17bf" class="graf graf--p graf-after--p">Destructuring assignment makes it easy to work with functions that return arrays of values:</p><p name="e07a" id="e07a" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let [r,theta] = toPolar(1.0, 1.0);</code></p><pre name="8a5a" id="8a5a" class="graf graf--pre graf-after--p">function toPolar(x, y) {</pre><pre name="9b20" id="9b20" class="graf graf--pre graf-after--pre">return [Math.sqrt(x*x+y*y), Math.atan2(y,x)];</pre><pre name="88c5" id="88c5" class="graf graf--pre graf-after--pre">}</pre><p name="1db3" id="1db3" class="graf graf--p graf-after--pre">Variable destructuring in loops:</p><p name="7726" id="7726" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let o = { x: 1, y: 2 };</code></p><pre name="9ad6" id="9ad6" class="graf graf--pre graf-after--p">for(const [name, value] of Object.entries(o)) {</pre><pre name="8df8" id="8df8" class="graf graf--pre graf-after--pre">console.log(name, value); // Prints &quot;x 1&quot; and &quot;y 2&quot;</pre><pre name="6096" id="6096" class="graf graf--pre graf-after--pre">}</pre><p name="80f3" id="80f3" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Note</strong>: The <code class="markup--code markup--p-code">Object.entries()</code> method returns an array of a given object&#39;s own enumerable string-keyed property <code class="markup--code markup--p-code">[key, value]</code> pairs, in the same order as that provided by a <code class="markup--code markup--p-code">for...in</code> loop. (The only important difference is that a <code class="markup--code markup--p-code">for...in</code> loop enumerates properties in the prototype chain as well).</p><p name="7d5d" id="7d5d" class="graf graf--p graf-after--p">The list of variables on the left can include extra commas to skip certain values on the right</p><p name="36be" id="36be" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[,x,,y] = [1,2,3,4];</code></p><p name="644e" id="644e" class="graf graf--p graf-after--p">x == 2; y == 4</p><p name="918e" id="918e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Note</strong>: the last comma does not stand for a value.</p><p name="8e88" id="8e88" class="graf graf--p graf-after--p">To collect all unused or remaining values into a single variable when destructuring an array, use three dots <code class="markup--code markup--p-code">(...) </code>before the last variable name on the left-hand side</p><p name="0f83" id="0f83" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let [x, ...y] = [1,2,3,4];</code></p><p name="896c" id="896c" class="graf graf--p graf-after--p">y == [2,3,4]</p><p name="3b14" id="3b14" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let [first, ...rest] = &quot;Hello&quot;;</code></p><p name="b185" id="b185" class="graf graf--p graf-after--p">first == “H”; rest ==[“e”,”l”,”l”,”o”]</p><p name="bab4" id="bab4" class="graf graf--p graf-after--p">Destructuring assignment can also be performed when the righthand side is an object value.</p><p name="53de" id="53de" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let transparent = {r: 0.0, g: 0.0, b: 0.0, a: 1.0};</code></p><p name="22fa" id="22fa" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let {r, g, b} = transparent;</code></p><p name="eeaf" id="eeaf" class="graf graf--p graf-after--p">r == 0.0; g == 0.0; b == 0.0</p><p name="a4cc" id="a4cc" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">const {sin, cos, tan} = Math;</code></p><p name="7141" id="7141" class="graf graf--p graf-after--p">sin=Math.sin, cos=Math.cos, tan=Math.tan</p><h3 name="26d4" id="26d4" class="graf graf--h3 graf-after--p">Expressions and Operators</h3><p name="b713" id="b713" class="graf graf--p graf-after--h3">In JavaScript, the values <code class="markup--code markup--p-code">null </code>and <code class="markup--code markup--p-code">undefined </code>are the only two values that do not have properties. In a regular property access expression using . or [], you get a <code class="markup--code markup--p-code">TypeError</code> if the expression on the left evaluates to <code class="markup--code markup--p-code">null </code>or <code class="markup--code markup--p-code">undefined</code>. You can use <code class="markup--code markup--p-code">?.</code> and <code class="markup--code markup--p-code">?.[]</code> syntax to guard against errors of this type.</p><p name="3c9e" id="3c9e" class="graf graf--p graf-after--p">You can also invoke a function using <code class="markup--code markup--p-code">?.()</code> instead of <code class="markup--code markup--p-code">()</code>.</p><p name="b1bc" id="b1bc" class="graf graf--p graf-after--p">With the <code class="markup--code markup--p-code">new ?.()</code> invocation syntax, if the expression to the left of the <code class="markup--code markup--p-code">?.</code> evaluates to <code class="markup--code markup--p-code">null</code> or <code class="markup--code markup--p-code">undefined</code>, then the entire invocation expression evaluates to <code class="markup--code markup--p-code">undefined </code>and no exception is thrown.</p><p name="b4ca" id="b4ca" class="graf graf--p graf-after--p">Write the function invocation using <code class="markup--code markup--p-code">?.(),</code> knowing that invocation will only happen if there is actually a value to be invoked</p><pre name="c4b1" id="c4b1" class="graf graf--pre graf-after--p">function square(x, log) {</pre><pre name="6911" id="6911" class="graf graf--pre graf-after--pre">log?.(x); // Call the function if there is one</pre><pre name="389e" id="389e" class="graf graf--pre graf-after--pre">return x * x;</pre><pre name="a5af" id="a5af" class="graf graf--pre graf-after--pre">}</pre><p name="7422" id="7422" class="graf graf--p graf-after--pre">Note that expression <code class="markup--code markup--p-code">x++</code> is not always the same as <code class="markup--code markup--p-code">x = x + 1</code>.The <code class="markup--code markup--p-code">++</code> operator never performs string concatenation: it always converts its operand to a number and increments it. If x is the string &quot;1&quot;, <code class="markup--code markup--p-code">++x</code> is the number 2, but<code class="markup--code markup--p-code"> x + 1</code> is the string &quot;11&quot;.</p><p name="a120" id="a120" class="graf graf--p graf-after--p">JavaScript objects are compared by reference, not by value. An object is equal to itself, but not to any other object. If two distinct objects have the same number of properties, with the same names and values, they are still not equal. Similarly, two arrays that have the same elements in the same order are not equal to each other.</p><p name="c72d" id="c72d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">NaN </code>value is never equal to any other value, including itself! To check whether a value <code class="markup--code markup--p-code">x</code> is <code class="markup--code markup--p-code">NaN</code>, use <code class="markup--code markup--p-code">x !== </code>, or the global <code class="markup--code markup--p-code">isNaN()</code> function.</p><p name="3982" id="3982" class="graf graf--p graf-after--p">If both values refer to the same object, array, or function, they are equal. If they refer to different objects, they are not equal, even if both objects have identical properties.</p><h3 name="81e5" id="81e5" class="graf graf--h3 graf-after--p">Evaluating Expressions</h3><p name="0ada" id="0ada" class="graf graf--p graf-after--h3">JavaScript has the ability to interpret strings of JavaScript source code, evaluating them to produce a value.</p><p name="4d39" id="4d39" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">eval(&quot;3+2&quot;)</code></p><p name="d603" id="d603" class="graf graf--p graf-after--p">Because of security issues, some web servers use the HTTP “Content-Security-Policy” header to disable<code class="markup--code markup--p-code"> eval()</code> for an entire website.</p><h3 name="7bc9" id="7bc9" class="graf graf--h3 graf-after--p">First-Defined (??)</h3><p name="b3d6" id="b3d6" class="graf graf--p graf-after--h3">The first-defined operator <code class="markup--code markup--p-code">??</code> evaluates to its first defined operand: if its left operand is not <code class="markup--code markup--p-code">null</code> and not <code class="markup--code markup--p-code">undefined</code>, it returns that value.</p><p name="7779" id="7779" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a ?? b</code> is equivalent to <code class="markup--code markup--p-code">(a !== null &amp;&amp; a !== undefined) ? a : b</code></p><p name="d880" id="d880" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">??</code> is a useful alternative to <code class="markup--code markup--p-code">||.</code> The problem with this idiomatic use is that zero, the empty string, and false are all <code class="markup--code markup--p-code">falsy </code>values that may be perfectly valid in some circumstances. In this code example, if <code class="markup--code markup--p-code">maxWidth </code>is zero, that value will be ignored. But if we change the <code class="markup--code markup--p-code">||</code> operator to <code class="markup--code markup--p-code">??</code>, we end up with an expression where zero is a valid value.</p><p name="893b" id="893b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let max = maxWidth || preferences.maxWidth || 500;</code></p><p name="0f3b" id="0f3b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let max = maxWidth ?? preferences.maxWidth ?? 500;</code></p><h3 name="ab44" id="ab44" class="graf graf--h3 graf-after--p">delete Operator</h3><p name="baa3" id="baa3" class="graf graf--p graf-after--h3">Deleting an array element leaves a “hole” in the array and does not change the array’s length. The resulting array is sparse.</p><h3 name="e555" id="e555" class="graf graf--h3 graf-after--p">void Operator</h3><p name="f00d" id="f00d" class="graf graf--p graf-after--h3">Using the <code class="markup--code markup--p-code">void</code> operator makes sense only if the operand has side effects.</p><p name="90bd" id="90bd" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let counter = 0;</code></p><p name="4134" id="4134" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">const increment = () =&gt; void counter++;</code></p><p name="64c7" id="64c7" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">increment()</code></p><p name="9ee2" id="9ee2" class="graf graf--p graf-after--p">undefined</p><p name="7b10" id="7b10" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">counter</code></p><p name="c794" id="c794" class="graf graf--p graf-after--p">1</p><h3 name="545b" id="545b" class="graf graf--h3 graf-after--p">Statements</h3><p name="2f3c" id="2f3c" class="graf graf--p graf-after--h3">Expressions are evaluated to produce a value, but statements are executed to make something happen.</p><p name="a270" id="a270" class="graf graf--p graf-after--p">Expressions with side effects, such as assignments and function invocations, can stand alone as statements, and when used this way are known as expression statements.</p><p name="88c9" id="88c9" class="graf graf--p graf-after--p">A similar category of statements are the declaration statements that declare new variables and define new functions.</p><p name="ee15" id="ee15" class="graf graf--p graf-after--p">If a function does not have any side effects, there is no sense in calling it, unless it is part of a larger expression or an assignment statement.</p><h3 name="ea84" id="ea84" class="graf graf--h3 graf-after--p">for/of</h3><p name="19e1" id="19e1" class="graf graf--p graf-after--h3">The <code class="markup--code markup--p-code">for/of</code> loop works with iterable objects. Arrays, strings, sets, and maps are iterable.</p><p name="ea66" id="ea66" class="graf graf--p graf-after--p">Array</p><pre name="bc42" id="bc42" class="graf graf--pre graf-after--p">let data = [1, 2, 3, 4, 5, 6, 7, 8, 9], sum = 0;</pre><pre name="5c5a" id="5c5a" class="graf graf--pre graf-after--pre">for(let element of data) {</pre><pre name="71ec" id="71ec" class="graf graf--pre graf-after--pre">sum += element;</pre><pre name="fb51" id="fb51" class="graf graf--pre graf-after--pre">}</pre><pre name="d455" id="d455" class="graf graf--pre graf-after--pre">let text = &quot;Na na na na na na na na&quot;;</pre><pre name="aa34" id="aa34" class="graf graf--pre graf-after--pre">let wordSet = new Set(text.split(&quot; &quot;));</pre><pre name="5520" id="5520" class="graf graf--pre graf-after--pre">let unique = [];</pre><pre name="97af" id="97af" class="graf graf--pre graf-after--pre">for(let word of wordSet) {</pre><pre name="c4b9" id="c4b9" class="graf graf--pre graf-after--pre">unique.push(word);</pre><pre name="90ea" id="90ea" class="graf graf--pre graf-after--pre">}</pre><p name="8641" id="8641" class="graf graf--p graf-after--pre">String</p><pre name="938d" id="938d" class="graf graf--pre graf-after--p">let frequency = {};</pre><pre name="b09b" id="b09b" class="graf graf--pre graf-after--pre">for(let letter of &quot;mississippi&quot;) {</pre><pre name="7d90" id="7d90" class="graf graf--pre graf-after--pre">if (frequency[letter]) {</pre><pre name="3583" id="3583" class="graf graf--pre graf-after--pre">frequency[letter]++;</pre><pre name="b4ff" id="b4ff" class="graf graf--pre graf-after--pre">}</pre><pre name="eca3" id="eca3" class="graf graf--pre graf-after--pre">else {</pre><pre name="e54d" id="e54d" class="graf graf--pre graf-after--pre">frequency[letter] = 1;</pre><pre name="2d47" id="2d47" class="graf graf--pre graf-after--pre">}</pre><pre name="d00e" id="d00e" class="graf graf--pre graf-after--pre">}</pre><p name="aa37" id="aa37" class="graf graf--p graf-after--pre">Map</p><pre name="4100" id="4100" class="graf graf--pre graf-after--p">let m = new Map([[1, &quot;one&quot;]]);</pre><pre name="eeec" id="eeec" class="graf graf--pre graf-after--pre">for(let [key, value] of m) {</pre><pre name="2ad7" id="2ad7" class="graf graf--pre graf-after--pre">key // =&gt; 1</pre><pre name="3940" id="3940" class="graf graf--pre graf-after--pre">value // =&gt; &quot;one&quot;</pre><pre name="83c0" id="83c0" class="graf graf--pre graf-after--pre">}</pre><p name="142f" id="142f" class="graf graf--p graf-after--pre">Objects are not (by default) iterable. Attempting to use <code class="markup--code markup--p-code">for/of</code> on a regular object throws a <code class="markup--code markup--p-code">TypeError</code> at runtime.</p><p name="70b1" id="70b1" class="graf graf--p graf-after--p">If you want to iterate through the properties of an object, you can use the <code class="markup--code markup--p-code">for/in</code> loop.</p><p name="dbc6" id="dbc6" class="graf graf--p graf-after--p">Note: <code class="markup--code markup--p-code">for/of</code> can be used on objects with <code class="markup--code markup--p-code">Object.entries</code> property, but it will not pick properties from object’s prototype.</p><h3 name="13ef" id="13ef" class="graf graf--h3 graf-after--p">for/in</h3><p name="beff" id="beff" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">for/in</code> loop works with any object after the <code class="markup--code markup--p-code">in</code>.</p><pre name="caeb" id="caeb" class="graf graf--pre graf-after--p">for(let p in o) {</pre><pre name="b2f3" id="b2f3" class="graf graf--pre graf-after--pre">console.log(o[p]);</pre><pre name="e478" id="e478" class="graf graf--pre graf-after--pre">}</pre><p name="78ee" id="78ee" class="graf graf--p graf-after--pre">Note: this will enumerate array indexes, not values.</p><pre name="a3fb" id="a3fb" class="graf graf--pre graf-after--p">for(let i in a) console.log(i);</pre><p name="de4f" id="de4f" class="graf graf--p graf-after--pre">The <code class="markup--code markup--p-code">for/in</code> loop does not actually enumerate all properties of an object. It does not enumerate properties whose names are symbols. And of the properties whose names are strings, it only loops over the <code class="markup--code markup--p-code">enumerable</code>properties.</p><h3 name="aa46" id="aa46" class="graf graf--h3 graf-after--p">with</h3><p name="3cd7" id="3cd7" class="graf graf--p graf-after--h3">The with statement runs a block of code as if the properties of a specified object were variables in scope for that code.</p><p name="6343" id="6343" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">with </code>statement is forbidden in strict mode and should be considered deprecated in non-strict mode: avoid using it whenever possible.</p><pre name="d465" id="d465" class="graf graf--pre graf-after--p">document.forms[0].address.value</pre><pre name="7acf" id="7acf" class="graf graf--pre graf-after--pre">with(document.forms[0]) {</pre><pre name="f01c" id="f01c" class="graf graf--pre graf-after--pre">name.value = &quot;&quot;;</pre><pre name="4b21" id="4b21" class="graf graf--pre graf-after--pre">address.value = &quot;&quot;;</pre><pre name="c628" id="c628" class="graf graf--pre graf-after--pre">email.value = &quot;&quot;;</pre><pre name="dd29" id="dd29" class="graf graf--pre graf-after--pre">}</pre><h3 name="4303" id="4303" class="graf graf--h3 graf-after--pre">debugger</h3><p name="14c7" id="14c7" class="graf graf--p graf-after--h3">If a debugger program is available and is running, then an implementation may (but is not required to) perform some kind of debugging action.</p><p name="b8c7" id="b8c7" class="graf graf--p graf-after--p">In practice, this statement acts like a breakpoint: execution of JavaScript code stops, and you can use the debugger to print variables’ values, examine the call stack, and so on.</p><p name="924b" id="924b" class="graf graf--p graf-after--p">Note that it is not enough to have a debugger available: the debugger statement won’t start the debugger for you. If you’re using a web browser and have the developer tools console open, however, this statement will cause a breakpoint.</p><h3 name="5c8c" id="5c8c" class="graf graf--h3 graf-after--p">use strict</h3><p name="ed71" id="ed71" class="graf graf--p graf-after--h3">Strict mode is a restricted subset of the language that fixes important language deficiencies and provides stronger error checking and increased security.</p><p name="9a55" id="9a55" class="graf graf--p graf-after--p">The differences between strict mode and non-strict mode are the following:</p><p name="1631" id="1631" class="graf graf--p graf-after--p">· The <code class="markup--code markup--p-code">with </code>statement is not allowed in strict mode.</p><p name="3152" id="3152" class="graf graf--p graf-after--p">· In strict mode, all variables must be declared: a <code class="markup--code markup--p-code">ReferenceError </code>is thrown if you assign a value to an identifier that is not a declared variable, function, function parameter, catch clause parameter, or property of the global object.</p><p name="db34" id="db34" class="graf graf--p graf-after--p">· In non-strict mode, this implicitly declares a global variable by adding a new property to the global object.</p><p name="4f9c" id="4f9c" class="graf graf--p graf-after--p">· In strict mode, functions invoked as functions (rather than as methods) have a <code class="markup--code markup--p-code">this </code>value of undefined. (In non-strict mode, functions invoked as functions are always passed the global object as their <code class="markup--code markup--p-code">this </code>value.)</p><p name="e56e" id="e56e" class="graf graf--p graf-after--p">· A function is invoked with <code class="markup--code markup--p-code">call() </code>or <code class="markup--code markup--p-code">apply()</code> , the <code class="markup--code markup--p-code">this </code>value is exactly the value passed as the first argument to <code class="markup--code markup--p-code">call()</code> or <code class="markup--code markup--p-code">apply()</code>. (In non-strict mode, <code class="markup--code markup--p-code">null </code>and <code class="markup--code markup--p-code">undefined </code>values are replaced with the global object and non-object values are converted to objects.)</p><p name="d47c" id="d47c" class="graf graf--p graf-after--p">· In strict mode, assignments to non-writable properties and attempts to create new properties on non-extensible objects throw a <code class="markup--code markup--p-code">TypeError</code>. (In non-strict mode, these attempts fail silently.)</p><p name="8e4b" id="8e4b" class="graf graf--p graf-after--p">· In strict mode, code passed to <code class="markup--code markup--p-code">eval() </code>cannot declare variables or define functions in the caller’s scope as it can in non-strict mode. Instead, variable and function definitions live in a new scope created for the <code class="markup--code markup--p-code">eval()</code>. This scope is discarded when the <code class="markup--code markup--p-code">eval()</code> returns.</p><p name="29de" id="29de" class="graf graf--p graf-after--p">· In strict mode, the Arguments object in a function holds a static copy of the values passed to the function. In non-strict mode, the Arguments object has “magical” behavior in which elements of the array and named function parameters both refer to the same value.</p><p name="a390" id="a390" class="graf graf--p graf-after--p">· In strict mode, a <code class="markup--code markup--p-code">SyntaxError </code>is thrown if the <code class="markup--code markup--p-code">delete </code>operator is followed by an unqualified identifier such as a variable, function, or function parameter. (In non-strict mode, such a <code class="markup--code markup--p-code">delete </code>expression does nothing and evaluates to false.)</p><p name="0442" id="0442" class="graf graf--p graf-after--p">· In strict mode, an attempt to delete a non-configurable property throws a <code class="markup--code markup--p-code">TypeError</code>. (In non-strict mode, the attempt fails and the delete expression evaluates to false.)</p><p name="fa04" id="fa04" class="graf graf--p graf-after--p">· In strict mode, it is a syntax error for an object literal to define two or more properties by the same name. (In non-strict mode, no error occurs.)</p><h3 name="00da" id="00da" class="graf graf--h3 graf-after--p">Objects</h3><p name="ebd1" id="ebd1" class="graf graf--p graf-after--h3">In addition to its name and value, each property has three property attributes:</p><p name="3c4f" id="3c4f" class="graf graf--p graf-after--p">· The <code class="markup--code markup--p-code">writable </code>attribute specifies whether the value of the property can be set.</p><p name="71f7" id="71f7" class="graf graf--p graf-after--p">· The <code class="markup--code markup--p-code">enumerable </code>attribute specifies whether the property name is returned by a <code class="markup--code markup--p-code">for/in</code> loop.</p><p name="7a9e" id="7a9e" class="graf graf--p graf-after--p">· The <code class="markup--code markup--p-code">configurable </code>attribute specifies whether the property can be deleted and whether its attributes can be altered.</p><h3 name="56ee" id="56ee" class="graf graf--h3 graf-after--p">Prototypes</h3><p name="0237" id="0237" class="graf graf--p graf-after--h3">All objects created by object literals have the same prototype object, <code class="markup--code markup--p-code">Object.prototype.</code></p><p name="1644" id="1644" class="graf graf--p graf-after--p">Objects created using the <code class="markup--code markup--p-code">new </code>keyword and a constructor invocation use the value of the prototype property of the constructor function as their prototype.</p><p name="e885" id="e885" class="graf graf--p graf-after--p">Object created by <code class="markup--code markup--p-code">new Object()</code> inherits from <code class="markup--code markup--p-code">Object.prototype</code>, just as the object created by <code class="markup--code markup--p-code">{}</code> does. Similarly, the object created by <code class="markup--code markup--p-code">new Array()</code> uses <code class="markup--code markup--p-code">Array.prototype</code> as its prototype, and the object created by<code class="markup--code markup--p-code"> new Date()</code> uses <code class="markup--code markup--p-code">Date.prototype</code> as its prototype.</p><p name="9e75" id="9e75" class="graf graf--p graf-after--p">Almost all objects have a prototype, but only a relatively small number of objects have a <code class="markup--code markup--p-code">prototype </code>property. It is these objects with prototype properties that define the prototypes for all the other objects.</p><p name="0e43" id="0e43" class="graf graf--p graf-after--p">Most built-in constructors (and most user-defined constructors) have a prototype that inherits from <code class="markup--code markup--p-code">Object.prototype</code>.</p><p name="95d8" id="95d8" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Date.prototype</code> inherits properties from <code class="markup--code markup--p-code">Object.prototype</code>, so a Date object created by <code class="markup--code markup--p-code">new Date()</code> inherits properties from both <code class="markup--code markup--p-code">Date.prototype</code> and <code class="markup--code markup--p-code">Object.prototype</code>. This linked series of prototype objects is known as a prototype chain.</p><h3 name="3fdb" id="3fdb" class="graf graf--h3 graf-after--p">Creating Objects</h3><p name="8377" id="8377" class="graf graf--p graf-after--h3">Objects can be created with object literals, with the <code class="markup--code markup--p-code">new</code> keyword, and with the <code class="markup--code markup--p-code">Object.create()</code> function.</p><p name="5361" id="5361" class="graf graf--p graf-after--p">Literal</p><p name="43a3" id="43a3" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let empty = {};</code></p><p name="ac5c" id="ac5c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let point = { x: 0, y: 0 };</code></p><pre name="e559" id="e559" class="graf graf--pre graf-after--p">let book = {</pre><pre name="8d0f" id="8d0f" class="graf graf--pre graf-after--pre">&quot;main title&quot;: &quot;JavaScript&quot;,</pre><pre name="1b6d" id="1b6d" class="graf graf--pre graf-after--pre">&quot;sub-title&quot;: &quot;The Definitive Guide&quot;,</pre><pre name="4686" id="4686" class="graf graf--pre graf-after--pre">for: &quot;all audiences&quot;,</pre><pre name="1855" id="1855" class="graf graf--pre graf-after--pre">author: {</pre><pre name="6416" id="6416" class="graf graf--pre graf-after--pre">firstname: &quot;David&quot;, .</pre><pre name="8991" id="8991" class="graf graf--pre graf-after--pre">surname: &quot;Flanagan&quot;</pre><pre name="78c2" id="78c2" class="graf graf--pre graf-after--pre">}</pre><pre name="f3b0" id="f3b0" class="graf graf--pre graf-after--pre">};</pre><p name="1cf0" id="1cf0" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">new</code></p><p name="6b85" id="6b85" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let o = new Object(); </code><br> <code class="markup--code markup--p-code">let a = new Array(); </code><br> <code class="markup--code markup--p-code">let d = new Date(); </code><br> <code class="markup--code markup--p-code">let r = new Map();</code></p><p name="79a2" id="79a2" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Object.create</code></p><p name="5b0b" id="5b0b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let o3 = Object.create(Object.prototype);</code></p><p name="1a40" id="1a40" class="graf graf--p graf-after--p">Use <code class="markup--code markup--p-code">Object.create</code> to guard against accidental modifications:</p><pre name="b070" id="b070" class="graf graf--pre graf-after--p">let o = { x: &quot;don&#39;t change this value&quot; };</pre><pre name="cb49" id="cb49" class="graf graf--pre graf-after--pre">library.function(Object.create(o));</pre><p name="8f78" id="8f78" class="graf graf--p graf-after--pre">Note: the library function can modify the passed in object, but not the original <code class="markup--code markup--p-code">o</code> object</p><h3 name="d17d" id="d17d" class="graf graf--h3 graf-after--p">Access Object Properties with an array ([]) notation</h3><pre name="2019" id="2019" class="graf graf--pre graf-after--h3">let addr = &quot;&quot;;</pre><pre name="34a0" id="34a0" class="graf graf--pre graf-after--pre">for(let i = 0; i &lt; 4; i++) {</pre><pre name="9414" id="9414" class="graf graf--pre graf-after--pre">addr += customer[`address${i}`] + &quot;\n&quot;;</pre><pre name="9425" id="9425" class="graf graf--pre graf-after--pre">}</pre><h3 name="3e66" id="3e66" class="graf graf--h3 graf-after--pre">Inheritance</h3><p name="ab22" id="ab22" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">let o = {};</code></p><p name="3816" id="3816" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o.x = 1;</code></p><p name="b656" id="b656" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let p = Object.create(o);</code></p><p name="06af" id="06af" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">p.y = 2;</code></p><p name="8124" id="8124" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let q = Object.create(p);</code></p><p name="f16b" id="f16b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">q.z = 3;</code></p><p name="d80b" id="d80b" class="graf graf--p graf-after--p">Property <code class="markup--code markup--p-code">x</code> and <code class="markup--code markup--p-code">y</code> available on object <code class="markup--code markup--p-code">q</code></p><p name="4587" id="4587" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">q.x + q.y</code></p><h3 name="9f04" id="9f04" class="graf graf--h3 graf-after--p">How to query for property which may be undefined</h3><p name="bb35" id="bb35" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">surname = book &amp;&amp; book.author &amp;&amp; book.author.surname;</code></p><p name="b505" id="b505" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let surname = book?.author?.surname;</code></p><h3 name="8294" id="8294" class="graf graf--h3 graf-after--p">Deleting properties</h3><p name="0b88" id="0b88" class="graf graf--p graf-after--h3">The <code class="markup--code markup--p-code">delete</code> operator only deletes own properties, not inherited ones. (To delete an inherited property, you must delete it from the prototype object in which it is defined. Doing this affects every object that inherits from that prototype.)</p><p name="8c13" id="8c13" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">delete</code> does not remove properties that have a <code class="markup--code markup--p-code">configurable </code>attribute of false.</p><p name="4fc1" id="4fc1" class="graf graf--p graf-after--p">Certain properties of built-in objects are non-configurable, as are properties of the global object created by variable declaration and function declaration.</p><p name="7843" id="7843" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">delete Object.prototype</code></p><p name="6849" id="6849" class="graf graf--p graf-after--p">false: property is non-configurable</p><p name="db82" id="db82" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">var x = 1;</code></p><p name="d5df" id="d5df" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">delete globalThis.x</code></p><p name="4b1e" id="4b1e" class="graf graf--p graf-after--p">false: can’t delete <code class="markup--code markup--p-code">this </code>property</p><p name="c76e" id="c76e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">function f() {}</code></p><p name="3b9b" id="3b9b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">delete globalThis.f</code></p><p name="0d33" id="0d33" class="graf graf--p graf-after--p">false</p><p name="ca80" id="ca80" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">globalThis.x = 1;</code></p><p name="9c96" id="9c96" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">delete globalThis.x</code></p><p name="498a" id="498a" class="graf graf--p graf-after--p">true</p><h3 name="5870" id="5870" class="graf graf--h3 graf-after--p">Testing properties</h3><p name="b6d5" id="b6d5" class="graf graf--p graf-after--h3">To check whether an object has a property with a given name. You can do this with the <code class="markup--code markup--p-code">in</code> operator, with the <code class="markup--code markup--p-code">hasOwnProperty()</code> and <code class="markup--code markup--p-code">propertyIsEnumerable()</code> methods, or simply by querying the property</p><p name="e410" id="e410" class="graf graf--p graf-after--p">( <code class="markup--code markup--p-code">!= undefined</code>).</p><h3 name="91ed" id="91ed" class="graf graf--h3 graf-after--p">in &amp; query</h3><p name="ca50" id="ca50" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">let o = { x: 1 };</code></p><p name="133c" id="133c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">&quot;x&quot; in o</code></p><p name="8c3a" id="8c3a" class="graf graf--p graf-after--p">true</p><p name="8fb5" id="8fb5" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o.x !== undefined</code></p><p name="6a95" id="6a95" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">&quot;y&quot; in o</code></p><p name="e03a" id="e03a" class="graf graf--p graf-after--p">false</p><p name="437d" id="437d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o.y !== undefined</code></p><p name="76b3" id="76b3" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">&quot;toString&quot; in o</code></p><p name="2c77" id="2c77" class="graf graf--p graf-after--p">true: o inherits a <code class="markup--code markup--p-code">toString </code>property</p><p name="7078" id="7078" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o.toString !== undefined</code></p><p name="492d" id="492d" class="graf graf--p graf-after--p">Advantage of using in: <code class="markup--code markup--p-code">in</code> can distinguish between properties that do not exist and properties that exist but have been set to <code class="markup--code markup--p-code">undefined</code>.</p><h3 name="b67e" id="b67e" class="graf graf--h3 graf-after--p">hasOwnProperty</h3><p name="bf69" id="bf69" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">let o = { x: 1 };</code></p><p name="e79d" id="e79d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o.hasOwnProperty(&quot;x&quot;)</code></p><p name="cd86" id="cd86" class="graf graf--p graf-after--p">true</p><p name="ae55" id="ae55" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o.hasOwnProperty(&quot;y&quot;)</code></p><p name="f127" id="f127" class="graf graf--p graf-after--p">false</p><p name="3bd8" id="3bd8" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o.hasOwnProperty(&quot;toString&quot;)</code></p><p name="a80a" id="a80a" class="graf graf--p graf-after--p">false: toString is an inherited property</p><p name="06a4" id="06a4" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">propertyIsEnumerable()</code> returns true only if the named property is an own property and its <code class="markup--code markup--p-code">enumerable</code> attribute is true.</p><p name="e5c9" id="e5c9" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let o = { x: 1 };</code></p><p name="603d" id="603d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o.propertyIsEnumerable(&quot;x&quot;)</code></p><p name="ff4c" id="ff4c" class="graf graf--p graf-after--p">true</p><p name="ae27" id="ae27" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o.propertyIsEnumerable(&quot;toString&quot;)</code></p><p name="2048" id="2048" class="graf graf--p graf-after--p">false: not an own property</p><p name="9a17" id="9a17" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Object.prototype.propertyIsEnumerable(&quot;toString&quot;)</code></p><p name="e792" id="e792" class="graf graf--p graf-after--p">false: not enumerable</p><h3 name="d2b9" id="d2b9" class="graf graf--h3 graf-after--p">Enumerating properties</h3><p name="dcba" id="dcba" class="graf graf--p graf-after--h3">To guard against enumerating inherited properties with <code class="markup--code markup--p-code">for/in</code>, you can add an explicit check inside the loop body:</p><pre name="9aea" id="9aea" class="graf graf--pre graf-after--p">for(let p in o) {</pre><pre name="f247" id="f247" class="graf graf--pre graf-after--pre">if (!o.hasOwnProperty(p)) continue;</pre><pre name="f32c" id="f32c" class="graf graf--pre graf-after--pre">}</pre><pre name="0d71" id="0d71" class="graf graf--pre graf-after--pre">for(let p in o) {</pre><pre name="0d0d" id="0d0d" class="graf graf--pre graf-after--pre">if (typeof o[p] === &quot;function&quot;) continue;</pre><pre name="2d51" id="2d51" class="graf graf--pre graf-after--pre">}</pre><p name="ed4c" id="ed4c" class="graf graf--p graf-after--pre">Functions you can use to get an array of property names</p><p name="1bc6" id="1bc6" class="graf graf--p graf-after--p">· <code class="markup--code markup--p-code">Object.keys()</code> returns an array of the names of the enumerable own properties of an object. It does not include non-enumerable properties, inherited properties, or properties whose name is a Symbol.</p><p name="9128" id="9128" class="graf graf--p graf-after--p">· <code class="markup--code markup--p-code">Object.getOwnPropertyNames()</code> works like <code class="markup--code markup--p-code">Object.keys() </code>but returns an array of the names of nonenumerable own properties as well.</p><p name="e62e" id="e62e" class="graf graf--p graf-after--p">· <code class="markup--code markup--p-code">Object.getOwnPropertySymbols()</code> returns own properties whose names are Symbols, whether or not they are enumerable.</p><p name="2310" id="2310" class="graf graf--p graf-after--p">· <code class="markup--code markup--p-code">Reflect.ownKeys()</code> returns all own property names, both enumerable and non-enumerable, and both string and Symbol.</p><h3 name="02e5" id="02e5" class="graf graf--h3 graf-after--p">Extending Objects</h3><p name="03b2" id="03b2" class="graf graf--p graf-after--h3">To copy the properties of one object to another object</p><pre name="1cef" id="1cef" class="graf graf--pre graf-after--p">let target = {x: 1}, source = {y: 2, z: 3};</pre><pre name="bfde" id="bfde" class="graf graf--pre graf-after--pre">for(let key of Object.keys(source)) {</pre><pre name="c285" id="c285" class="graf graf--pre graf-after--pre">target[key] = source[key];</pre><pre name="56ce" id="56ce" class="graf graf--pre graf-after--pre">}</pre><p name="6ae9" id="6ae9" class="graf graf--p graf-after--pre">One reason to assign properties from one object into another is when you have an object that defines default values for many properties and you want to copy those default properties into another object if a property by that name does not already exist in that object. Using <code class="markup--code markup--p-code">Object.assign()</code> naively will not do what you want:</p><pre name="8409" id="8409" class="graf graf--pre graf-after--p">Object.assign(o, defaults);</pre><p name="63fc" id="63fc" class="graf graf--p graf-after--pre">overwrites everything in o with defaults</p><p name="a973" id="a973" class="graf graf--p graf-after--p">Instead, use one of the following:,</p><p name="b3da" id="b3da" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o = Object.assign({}, defaults, o);</code></p><p name="a482" id="a482" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o = {...defaults, ...o};</code></p><h3 name="8b23" id="8b23" class="graf graf--h3 graf-after--p">Serializing Objects</h3><p name="7a4a" id="7a4a" class="graf graf--p graf-after--h3">The functions <code class="markup--code markup--p-code">JSON.stringify()</code> and<code class="markup--code markup--p-code"> JSON.parse()</code> serialize and restore JavaScript objects.</p><p name="785e" id="785e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let o = {x: 1, y: {z: [false, null, &quot;&quot;]}};</code></p><p name="a6cb" id="a6cb" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let s = JSON.stringify(o);</code></p><p name="656b" id="656b" class="graf graf--p graf-after--p">s == ‘{“x”:1,”y”:{“z”:[false,null,””]}}’</p><p name="1d09" id="1d09" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let p = JSON.parse(s);</code></p><p name="b80d" id="b80d" class="graf graf--p graf-after--p">p == {x: 1, y: {z: [false,null, “”]}}</p><h3 name="89c1" id="89c1" class="graf graf--h3 graf-after--p">Object methods</h3><p name="2ae3" id="2ae3" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">toString(), valueOf(), loLocaleString(), toJSON()</code></p><p name="be33" id="be33" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let s = { x: 1, y: 1 }.toString();</code></p><p name="ee7a" id="ee7a" class="graf graf--p graf-after--p">s == “[object Object]”</p><h3 name="a7ab" id="a7ab" class="graf graf--h3 graf-after--p">Extended Object Literal Syntax</h3><h3 name="3b07" id="3b07" class="graf graf--h3 graf-after--h3">Shorthand Properties</h3><pre name="b264" id="b264" class="graf graf--pre graf-after--h3">let x = 1, y = 2;</pre><pre name="4ba9" id="4ba9" class="graf graf--pre graf-after--pre">let o = {</pre><pre name="f14c" id="f14c" class="graf graf--pre graf-after--pre">x: x,</pre><pre name="e422" id="e422" class="graf graf--pre graf-after--pre">y: y</pre><pre name="cf99" id="cf99" class="graf graf--pre graf-after--pre">};</pre><p name="4632" id="4632" class="graf graf--p graf-after--pre">←&gt;</p><p name="dc20" id="dc20" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let x = 1, y = 2;</code><br> <code class="markup--code markup--p-code">let o = { x, y };</code></p><h3 name="ef1d" id="ef1d" class="graf graf--h3 graf-after--p">Computer Property Names</h3><p name="3d93" id="3d93" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">const PROPERTY_NAME = &quot;p1&quot;;</code><br> <code class="markup--code markup--p-code">function computePropertyName() { return &quot;p&quot; + 2; }</code></p><pre name="4a83" id="4a83" class="graf graf--pre graf-after--p">let o = {};</pre><pre name="e326" id="e326" class="graf graf--pre graf-after--pre">o[PROPERTY_NAME] = 1;</pre><pre name="9bb9" id="9bb9" class="graf graf--pre graf-after--pre">o[computePropertyName()] = 2;</pre><p name="eb61" id="eb61" class="graf graf--p graf-after--pre">←&gt;</p><pre name="1aad" id="1aad" class="graf graf--pre graf-after--p">let p = {</pre><pre name="2287" id="2287" class="graf graf--pre graf-after--pre">[PROPERTY_NAME]: 1,</pre><pre name="55ea" id="55ea" class="graf graf--pre graf-after--pre">[computePropertyName()]: 2</pre><pre name="ef09" id="ef09" class="graf graf--pre graf-after--pre">};</pre><h3 name="41fa" id="41fa" class="graf graf--h3 graf-after--pre">Symbols as Property Names</h3><pre name="cdc0" id="cdc0" class="graf graf--pre graf-after--h3">const extension = Symbol(&quot;my extension symbol&quot;);</pre><pre name="5d27" id="5d27" class="graf graf--pre graf-after--pre">let o = {</pre><pre name="4425" id="4425" class="graf graf--pre graf-after--pre">[extension]: {}</pre><pre name="7309" id="7309" class="graf graf--pre graf-after--pre">};</pre><pre name="e65e" id="e65e" class="graf graf--pre graf-after--pre">o[extension].x = 0;</pre><p name="8fdf" id="8fdf" class="graf graf--p graf-after--pre">Two Symbols created with the same string argument are still different from one another.</p><p name="2250" id="2250" class="graf graf--p graf-after--p">The point of Symbols is not security, but to define a safe extension mechanism for JavaScript objects. If you get an object from third-party code that you do not control and need to add some of your own properties to that object but want to be sure that your properties will not conflict with any properties that may already exist on the object, you can safely use Symbols as your property names.</p><h3 name="9b7d" id="9b7d" class="graf graf--h3 graf-after--p">Spread Operator</h3><p name="a391" id="a391" class="graf graf--p graf-after--h3">You can copy the properties of an existing object into a new object using the “spread operator” … inside an object literal:</p><p name="21b8" id="21b8" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let position = { x: 0, y: 0 };</code><br> <code class="markup--code markup--p-code">let dimensions = { width: 100, height: 75 };</code><br> <code class="markup--code markup--p-code">let rect = { ...position, ...dimensions };</code><br> <code class="markup--code markup--p-code">rect.x + rect.y + rect.width + rect.height</code></p><h3 name="e1c1" id="e1c1" class="graf graf--h3 graf-after--p">Shorthand Methods</h3><pre name="5445" id="5445" class="graf graf--pre graf-after--h3">let square = {</pre><pre name="b894" id="b894" class="graf graf--pre graf-after--pre">area: function() {</pre><pre name="7b4c" id="7b4c" class="graf graf--pre graf-after--pre">return this.side * this.side; },</pre><pre name="02ab" id="02ab" class="graf graf--pre graf-after--pre">side: 10</pre><pre name="cf0c" id="cf0c" class="graf graf--pre graf-after--pre">};</pre><p name="f8e9" id="f8e9" class="graf graf--p graf-after--pre">←&gt;</p><pre name="a96e" id="a96e" class="graf graf--pre graf-after--p">let square = {</pre><pre name="9e5c" id="9e5c" class="graf graf--pre graf-after--pre">area() {</pre><pre name="36e3" id="36e3" class="graf graf--pre graf-after--pre">return this.side * this.side; },</pre><pre name="ad0d" id="ad0d" class="graf graf--pre graf-after--pre">side: 10</pre><pre name="e763" id="e763" class="graf graf--pre graf-after--pre">};</pre><p name="0719" id="0719" class="graf graf--p graf-after--pre">When you write a method using this shorthand syntax, the property name can take any of the forms that are legal in an object literal: in addition to a regular JavaScript identifier like the name area above, you can also use string literals and computed property names, which can include Symbol property names:</p><pre name="87f8" id="87f8" class="graf graf--pre graf-after--p">const METHOD_NAME = &quot;m&quot;;</pre><pre name="7d07" id="7d07" class="graf graf--pre graf-after--pre">const symbol = Symbol();</pre><pre name="5c35" id="5c35" class="graf graf--pre graf-after--pre">let weirdMethods = {</pre><pre name="27c2" id="27c2" class="graf graf--pre graf-after--pre">&quot;method With Spaces&quot;(x) { return x + 1; },</pre><pre name="32f4" id="32f4" class="graf graf--pre graf-after--pre">[METHOD_NAME](x) { return x + 2; },</pre><pre name="47a0" id="47a0" class="graf graf--pre graf-after--pre">[symbol](x) { return x + 3; }</pre><pre name="69dc" id="69dc" class="graf graf--pre graf-after--pre">};</pre><p name="30c4" id="30c4" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">weirdMethods[&quot;method With Spaces&quot;](1)</code></p><p name="1aea" id="1aea" class="graf graf--p graf-after--p">2</p><p name="4b0e" id="4b0e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">weirdMethods[METHOD_NAME](1)</code></p><p name="1209" id="1209" class="graf graf--p graf-after--p">3</p><p name="995e" id="995e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">weirdMethods[symbol](1)</code></p><p name="8501" id="8501" class="graf graf--p graf-after--p">4</p><h3 name="abb2" id="abb2" class="graf graf--h3 graf-after--p">Property Getters and Setters</h3><pre name="84b8" id="84b8" class="graf graf--pre graf-after--h3">let o = {</pre><pre name="f1a0" id="f1a0" class="graf graf--pre graf-after--pre">dataProp: value,</pre><pre name="b2aa" id="b2aa" class="graf graf--pre graf-after--pre">get accessorProp() { return this.dataProp; },</pre><pre name="5b2a" id="5b2a" class="graf graf--pre graf-after--pre">set accessorProp(value) { this.dataProp = value; }</pre><pre name="b482" id="b482" class="graf graf--pre graf-after--pre">};</pre><h3 name="59f1" id="59f1" class="graf graf--h3 graf-after--pre">Arrays</h3><h3 name="f605" id="f605" class="graf graf--h3 graf-after--h3">Creating Arrays</h3><p name="713e" id="713e" class="graf graf--p graf-after--h3">· Array literals</p><p name="fe08" id="fe08" class="graf graf--p graf-after--p">· The … spread operator on an iterable object</p><p name="769e" id="769e" class="graf graf--p graf-after--p">· The <code class="markup--code markup--p-code">Array()</code> constructor</p><p name="bde0" id="bde0" class="graf graf--p graf-after--p">· The <code class="markup--code markup--p-code">Array.of()</code> and <code class="markup--code markup--p-code">Array.from()</code> factory methods</p><h3 name="a681" id="a681" class="graf graf--h3 graf-after--p">Array literals</h3><p name="6d86" id="6d86" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">let empty = [];</code></p><p name="7e06" id="7e06" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let primes = [2, 3, 5, 7, 11];</code></p><p name="2422" id="2422" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let misc = [ 1.1, true, &quot;a&quot;, ];</code></p><p name="0864" id="0864" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let b = [[1, {x: 1, y: 2}], [2, {x: 3, y: 4}]];</code></p><p name="13b1" id="13b1" class="graf graf--p graf-after--p">If an array literal contains multiple commas in a row, with no value between, the array is sparse</p><p name="48ee" id="48ee" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let count = [1,,3];</code></p><p name="ace4" id="ace4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let undefs = [,,];</code></p><p name="2b38" id="2b38" class="graf graf--p graf-after--p">Array literal syntax allows an optional trailing comma, so <code class="markup--code markup--p-code">[,,]</code> has a length of 2, not 3.</p><h3 name="d37d" id="d37d" class="graf graf--h3 graf-after--p">The Spread Operator</h3><p name="c80c" id="c80c" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">let a = [1, 2, 3];</code></p><p name="1e55" id="1e55" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let b = [0, ...a, 4];</code></p><p name="3da4" id="3da4" class="graf graf--p graf-after--p">[0, 1, 2, 3, 4]</p><p name="e756" id="e756" class="graf graf--p graf-after--p">create a copy of an array — modifying the copy does not change the original</p><p name="c595" id="c595" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let original = [1,2,3];</code><br> <code class="markup--code markup--p-code">let copy = [...original];</code></p><p name="ecaf" id="ecaf" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let digits = [...&quot;0123456789ABCDEF&quot;];</code></p><p name="70c4" id="70c4" class="graf graf--p graf-after--p">[“0”,”1&quot;,”2&quot;,”3&quot;,”4&quot;,”5&quot;,”6&quot;,”7&quot;,”8&quot;,”9&quot;,”A”,”B”,”C”,”D”,”E”,”F”]</p><p name="7456" id="7456" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let letters = [...&quot;hello world&quot;];</code></p><p name="9a8d" id="9a8d" class="graf graf--p graf-after--p">[“h”,”e”,”l”,”l””o”,””,”w”,”o””r”,”l”,”d”]</p><p name="04f3" id="04f3" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[...new Set(letters)]</code></p><p name="ed37" id="ed37" class="graf graf--p graf-after--p">[“h”,”e”,”l”,”o”,””,”w”,”r”,”d”]</p><h3 name="92ad" id="92ad" class="graf graf--h3 graf-after--p">Array.of()</h3><p name="45f2" id="45f2" class="graf graf--p graf-after--h3">When the <code class="markup--code markup--p-code">Array()</code> constructor function is invoked with one numeric argument, it uses that argument as an array length. But when invoked with more than one numeric argument, it treats those arguments as elements for the array to be created. This means that the <code class="markup--code markup--p-code">Array()</code> constructor cannot be used to create an array with a single numeric element.</p><p name="90c7" id="90c7" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Array.of()</code></p><p name="a175" id="a175" class="graf graf--p graf-after--p">[]</p><p name="04a2" id="04a2" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Array.of(10)</code></p><p name="92de" id="92de" class="graf graf--p graf-after--p">[10]</p><p name="f9c2" id="f9c2" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Array.of(1,2,3)</code></p><p name="bfcf" id="bfcf" class="graf graf--p graf-after--p">[1, 2, 3]</p><h3 name="1150" id="1150" class="graf graf--h3 graf-after--p">Array.from()</h3><p name="a517" id="a517" class="graf graf--p graf-after--h3">It is also a simple way to make a copy of an array:</p><p name="fefb" id="fefb" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let copy = Array.from(original);</code></p><p name="3617" id="3617" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Array.from()</code> is also important because it defines a way to make a true-array copy of an array-like object. Array-like objects are non-array objects that have a numeric length property and have values stored with properties whose names happen to be integers.</p><p name="ca13" id="ca13" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let truearray = Array.from(arraylike);</code></p><p name="12be" id="12be" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Array.from()</code> also accepts an optional second argument. If you pass a function as the second argument, then as the new array is being built, each element from the source object will be passed to the function you specify, and the return value of the function will be stored in the array instead of the original value.</p><h3 name="a7fa" id="a7fa" class="graf graf--h3 graf-after--p">Reading and Writing Array Elements</h3><p name="7b20" id="7b20" class="graf graf--p graf-after--h3">What is special about arrays is that when you use property names that are non-negative integers , the array automatically maintains the value of the <code class="markup--code markup--p-code">length</code> property for you.</p><p name="4c53" id="4c53" class="graf graf--p graf-after--p">JavaScript converts the numeric array index you specify to a string — the index 1 becomes the string “1”, then uses that string as a property name.</p><p name="b723" id="b723" class="graf graf--p graf-after--p">It is helpful to clearly distinguish an array index from an object property name. All indexes are property names, but only property names that are integers between 0 and 231 are indexes. All arrays are objects, and you can create properties of any name on them. If you use properties that are array indexes, however, arrays have the special behavior of updating their <code class="markup--code markup--p-code">length</code> property as needed.</p><p name="33fc" id="33fc" class="graf graf--p graf-after--p">Note that you can index an array using numbers that are negative or that are not integers. When you do this, the number is converted to a string, and that string is used as the property name. Since the name is not a non-negative integer, it is treated as a regular object property, not an array index.</p><p name="a3f0" id="a3f0" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a[-1.23] = true;</code></p><p name="5d47" id="5d47" class="graf graf--p graf-after--p">This creates a property named “-1.23”</p><p name="a725" id="a725" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a[&quot;1000&quot;] = 0;</code></p><p name="ad74" id="ad74" class="graf graf--p graf-after--p">This the 1001st element of the array</p><p name="6e39" id="6e39" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a[1.000] = 1;</code></p><p name="b2fe" id="b2fe" class="graf graf--p graf-after--p">Array index 1. Same as a[1] = 1;</p><p name="2f54" id="2f54" class="graf graf--p graf-after--p">The fact that array indexes are simply a special type of object property name means that JavaScript arrays have no notion of an “out of bounds” error. When you try to query a nonexistent property of any object, you don’t get an error; you simply get <code class="markup--code markup--p-code">undefined</code>.</p><h3 name="6963" id="6963" class="graf graf--h3 graf-after--p">Sparse Arrays</h3><p name="6d6c" id="6d6c" class="graf graf--p graf-after--h3">Sparse arrays can be created with the <code class="markup--code markup--p-code">Array()</code> constructor or simply by assigning to an array index larger than the current array length.</p><p name="53eb" id="53eb" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a[1000] = 0;</code></p><p name="e14a" id="e14a" class="graf graf--p graf-after--p">Assignment adds one element but sets length to 1001.</p><p name="01ab" id="01ab" class="graf graf--p graf-after--p">you can also make an array sparse with the <code class="markup--code markup--p-code">delete</code> operator.</p><p name="3d16" id="3d16" class="graf graf--p graf-after--p">Note that when you omit a value in an array literal (using repeated commas as in <code class="markup--code markup--p-code">[1,,3]</code>), the resulting array is sparse, and the omitted elements simply do not exist</p><h3 name="fb2e" id="fb2e" class="graf graf--h3 graf-after--p">Array Length</h3><p name="cc13" id="cc13" class="graf graf--p graf-after--h3">if you set the length property to a nonnegative integer <code class="markup--code markup--p-code">n</code> smaller than its current value, any array elements whose index is greater than or equal to n are deleted from the array.</p><p name="447b" id="447b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a = [1,2,3,4,5];</code></p><p name="c2bf" id="c2bf" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.length = 3;</code></p><p name="fa68" id="fa68" class="graf graf--p graf-after--p">a is now [1,2,3].</p><p name="798c" id="798c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.length = 0;</code></p><p name="8943" id="8943" class="graf graf--p graf-after--p">Delete all elements. a is [].</p><p name="202f" id="202f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.length = 5;</code></p><p name="97bb" id="97bb" class="graf graf--p graf-after--p">Length is 5, but no elements, like <code class="markup--code markup--p-code">new Array(5)</code></p><p name="f5e6" id="f5e6" class="graf graf--p graf-after--p">You can also set the length property of an array to a value larger than its current value. Doing this does not actually add any new elements to the array; it simply creates a sparse area at the end of the array.</p><h3 name="f3e6" id="f3e6" class="graf graf--h3 graf-after--p">Adding and Deleting Array Elements</h3><p name="4c00" id="4c00" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">let a = [];</code></p><p name="043b" id="043b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a[0] = &quot;zero&quot;;</code></p><p name="b6a6" id="b6a6" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a[1] = &quot;one&quot;;</code></p><p name="75a4" id="75a4" class="graf graf--p graf-after--p">add elements to it.</p><p name="d81c" id="d81c" class="graf graf--p graf-after--p">You can also use the <code class="markup--code markup--p-code">push()</code> method to add one or more values to the end of an array.</p><p name="6f15" id="6f15" class="graf graf--p graf-after--p">You can use the<code class="markup--code markup--p-code"> unshift()</code> method to insert a value at the beginning of an array, shifting the existing array elements to higher indexes.</p><p name="20f0" id="20f0" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">pop()</code> method is the opposite of <code class="markup--code markup--p-code">push()</code>: it removes the last element of the array and returns it, reducing the length of an array by 1.</p><p name="958f" id="958f" class="graf graf--p graf-after--p">Similarly, the <code class="markup--code markup--p-code">shift()</code> method removes and returns the first element of the array, reducing the length by 1 and shifting all elements down to an index one lower than their current index.</p><p name="e557" id="e557" class="graf graf--p graf-after--p">You can delete array elements with the delete operator</p><p name="abd8" id="abd8" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [1,2,3];</code></p><p name="45f5" id="45f5" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">delete a[2];</code></p><p name="759d" id="759d" class="graf graf--p graf-after--p">a now has no element at index 2</p><p name="c0a1" id="c0a1" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">2 in a</code></p><p name="09af" id="09af" class="graf graf--p graf-after--p">false</p><p name="d2f1" id="d2f1" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.length</code></p><p name="ba65" id="ba65" class="graf graf--p graf-after--p">3: delete does not affect array length</p><h3 name="0cd6" id="0cd6" class="graf graf--h3 graf-after--p">Iterating Arrays</h3><p name="d3d4" id="d3d4" class="graf graf--p graf-after--h3">The easiest way to loop through each of the elements of an array (or any iterable object) is with the <code class="markup--code markup--p-code">for/of</code>loop</p><pre name="2f1a" id="2f1a" class="graf graf--pre graf-after--p">let letters = [...&quot;Hello world&quot;];</pre><pre name="9677" id="9677" class="graf graf--pre graf-after--pre">let string = &quot;&quot;;</pre><pre name="12e2" id="12e2" class="graf graf--pre graf-after--pre">for(let letter of letters) {</pre><pre name="ecb4" id="ecb4" class="graf graf--pre graf-after--pre">string += letter;</pre><pre name="b43d" id="b43d" class="graf graf--pre graf-after--pre">}</pre><p name="7f30" id="7f30" class="graf graf--p graf-after--pre">It has no special behavior for sparse arrays and simply returns <code class="markup--code markup--p-code">undefined</code> for any array elements that do not exist.</p><p name="2207" id="2207" class="graf graf--p graf-after--p">If you want to use a <code class="markup--code markup--p-code">for/of</code> loop for an array and need to know the index of each array element, use the <code class="markup--code markup--p-code">entries()</code> method of the array</p><pre name="ab80" id="ab80" class="graf graf--pre graf-after--p">let letters = [...&quot;Hello world&quot;];</pre><pre name="1f78" id="1f78" class="graf graf--pre graf-after--pre">let everyother = &quot;&quot;;</pre><pre name="ba27" id="ba27" class="graf graf--pre graf-after--pre">for(let [index, letter] of letters.entries()) {</pre><pre name="2a4b" id="2a4b" class="graf graf--pre graf-after--pre">if (index % 2 === 0) everyother += letter;</pre><pre name="0ffd" id="0ffd" class="graf graf--pre graf-after--pre">}</pre><p name="a713" id="a713" class="graf graf--p graf-after--pre">Another good way to iterate arrays is with <code class="markup--code markup--p-code">forEach()</code>. This is not a new form of the for loop, but an array method that offers a functional approach to array iteration.</p><pre name="c7c9" id="c7c9" class="graf graf--pre graf-after--p">let letters = [...&quot;Hello world&quot;];</pre><pre name="b35b" id="b35b" class="graf graf--pre graf-after--pre">let uppercase = &quot;&quot;;</pre><pre name="97aa" id="97aa" class="graf graf--pre graf-after--pre">letters.forEach(letter =&gt; {</pre><pre name="3721" id="3721" class="graf graf--pre graf-after--pre">uppercase += letter.toUpperCase();</pre><pre name="2330" id="2330" class="graf graf--pre graf-after--pre">});</pre><p name="4eb5" id="4eb5" class="graf graf--p graf-after--pre">You can also loop through the elements of an array with a <code class="markup--code markup--p-code">for</code> loop.</p><pre name="bb93" id="bb93" class="graf graf--pre graf-after--p">for(let i = 0, len = letters.length; i &lt; len; i++) {</pre><pre name="8c79" id="8c79" class="graf graf--pre graf-after--pre">// loop body</pre><pre name="2a08" id="2a08" class="graf graf--pre graf-after--pre">}</pre><h3 name="c562" id="c562" class="graf graf--h3 graf-after--pre">Multidimensional Arrays</h3><h3 name="c281" id="c281" class="graf graf--h3 graf-after--h3">Create a multidimensional array</h3><p name="e408" id="e408" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">let table = new Array(10);</code></p><pre name="63e1" id="63e1" class="graf graf--pre graf-after--p">for(let i = 0; i &lt; table.length; i++) {</pre><pre name="1841" id="1841" class="graf graf--pre graf-after--pre">table[i] = new Array(10);</pre><pre name="ee4b" id="ee4b" class="graf graf--pre graf-after--pre">}</pre><pre name="9100" id="9100" class="graf graf--pre graf-after--pre">for(let row = 0; row &lt; table.length; row++) {</pre><pre name="8ae4" id="8ae4" class="graf graf--pre graf-after--pre">for(let col = 0; col &lt; table[row].length; col++) {</pre><pre name="556a" id="556a" class="graf graf--pre graf-after--pre">table[row][col] = row * col;</pre><pre name="5969" id="5969" class="graf graf--pre graf-after--pre">}</pre><pre name="5496" id="5496" class="graf graf--pre graf-after--pre">}</pre><h3 name="27f5" id="27f5" class="graf graf--h3 graf-after--pre">Array Methods</h3><h3 name="d2e7" id="d2e7" class="graf graf--h3 graf-after--h3">Array Iterator Methods</h3><p name="fbc6" id="fbc6" class="graf graf--p graf-after--h3">First, all of these methods accept a function as their first argument and invoke that function once for each element (or some elements) of the array. If the array is sparse, the function you pass is not invoked for nonexistent elements. In most cases, the function you supply is invoked with three arguments: the value of the array element, the index of the array element, and the array itself.</p><p name="c493" id="c493" class="graf graf--p graf-after--p">FOREACH()</p><p name="b0f6" id="b0f6" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let data = [1,2,3,4,5], sum = 0;</code></p><pre name="512a" id="512a" class="graf graf--pre graf-after--p">data.forEach(value =&gt; { sum += value; });</pre><pre name="cc5f" id="cc5f" class="graf graf--pre graf-after--pre">data.forEach(function(v, i, a) {</pre><pre name="e231" id="e231" class="graf graf--pre graf-after--pre">a[i] = v + 1;</pre><pre name="581a" id="581a" class="graf graf--pre graf-after--pre">});</pre><p name="7390" id="7390" class="graf graf--p graf-after--pre">15</p><p name="8f01" id="8f01" class="graf graf--p graf-after--p">[2,3,4,5,6]</p><p name="5704" id="5704" class="graf graf--p graf-after--p">MAP()</p><p name="7466" id="7466" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [1, 2, 3];</code><br> <code class="markup--code markup--p-code">a.map(x =&gt; x*x)</code></p><p name="fbc2" id="fbc2" class="graf graf--p graf-after--p">[1, 4, 9]</p><p name="771f" id="771f" class="graf graf--p graf-after--p">FILTER()</p><p name="75e7" id="75e7" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [5, 4, 3, 2, 1];</code><br> <code class="markup--code markup--p-code">a.filter(x =&gt; x &lt; 3) </code><br> <code class="markup--code markup--p-code">a.filter((x,i) =&gt; i % 2 === 0)</code></p><p name="73e9" id="73e9" class="graf graf--p graf-after--p">[2, 1];</p><p name="73de" id="73de" class="graf graf--p graf-after--p">[5, 3, 1];</p><p name="0f2d" id="0f2d" class="graf graf--p graf-after--p">FIND()</p><p name="005c" id="005c" class="graf graf--p graf-after--p">FINDINDEX()</p><p name="a1d4" id="a1d4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [1,2,3,4,5];</code></p><p name="57f1" id="57f1" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.findIndex(x =&gt; x === 3)</code></p><p name="e71c" id="e71c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.find(x =&gt; x % 5 === 0)</code></p><p name="9ebf" id="9ebf" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.find(x =&gt; x % 7 === 0)</code></p><p name="3bb2" id="3bb2" class="graf graf--p graf-after--p">2</p><p name="40ec" id="40ec" class="graf graf--p graf-after--p">5</p><p name="3495" id="3495" class="graf graf--p graf-after--p">undefined</p><p name="551c" id="551c" class="graf graf--p graf-after--p">EVERY()</p><p name="ff95" id="ff95" class="graf graf--p graf-after--p">SOME()</p><p name="e474" id="e474" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [1,2,3,4,5];</code></p><p name="b8f1" id="b8f1" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.every(x =&gt; x &lt; 10)</code></p><p name="61e5" id="61e5" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.some(x =&gt; x % 2 === 0)</code></p><p name="a934" id="a934" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.some(isNaN)</code></p><p name="83df" id="83df" class="graf graf--p graf-after--p">true</p><p name="fab4" id="fab4" class="graf graf--p graf-after--p">true</p><p name="fe59" id="fe59" class="graf graf--p graf-after--p">false</p><p name="a1ee" id="a1ee" class="graf graf--p graf-after--p">REDUCE()</p><p name="7ba9" id="7ba9" class="graf graf--p graf-after--p">ReduceRight()</p><p name="ad8e" id="ad8e" class="graf graf--p graf-after--p">l<code class="markup--code markup--p-code">et a = [1,2,3,4,5];</code></p><p name="5151" id="5151" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.reduce((x,y) =&gt; x+y, 0)</code></p><p name="3c37" id="3c37" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.reduce((x,y) =&gt; x*y, 1)</code></p><p name="f518" id="f518" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.reduce((x,y) =&gt; (x &gt; y) ? x : y)</code></p><p name="f6fd" id="f6fd" class="graf graf--p graf-after--p">15</p><p name="dcd4" id="dcd4" class="graf graf--p graf-after--p">120</p><p name="d8be" id="d8be" class="graf graf--p graf-after--p">5</p><p name="9e19" id="9e19" class="graf graf--p graf-after--p">Note that <code class="markup--code markup--p-code">map()</code> returns a new array: it does not modify the array it is invoked on. If that array is sparse, your function will not be called for the missing elements, but the returned array will be sparse in the same way as the original array: it will have the same length and the same missing elements.</p><p name="6f53" id="6f53" class="graf graf--p graf-after--p">To close the gaps in a sparse array, you can do this:</p><p name="2289" id="2289" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let dense = sparse.filter(() =&gt; true);</code></p><p name="709f" id="709f" class="graf graf--p graf-after--p">And to close gaps and remove undefined and null elements, you can use filter, like this:</p><p name="893e" id="893e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a = a.filter(x =&gt; x !== undefined &amp;&amp; x !== null);</code></p><p name="9011" id="9011" class="graf graf--p graf-after--p">Unlike <code class="markup--code markup--p-code">filter()</code>, however,<code class="markup--code markup--p-code"> find()</code> and <code class="markup--code markup--p-code">findIndex()</code> stop iterating the first time the predicate finds an element. When that happens, <code class="markup--code markup--p-code">find()</code> returns the matching element, and <code class="markup--code markup--p-code">findIndex()</code> returns the index of the matching element. If no matching element is found,<code class="markup--code markup--p-code"> find()</code> returns <code class="markup--code markup--p-code">undefined</code> and<code class="markup--code markup--p-code"> findIndex()</code>returns -1.</p><p name="d099" id="d099" class="graf graf--p graf-after--p">When you invoke <code class="markup--code markup--p-code">reduce()</code> with no initial value, it uses the first element of the array as the initial value.</p><p name="0f56" id="0f56" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">reduceRight()</code> works just like <code class="markup--code markup--p-code">reduce()</code>, except that it processes the array from highest index to lowest (right-to-left), rather than from lowest to highest. You might want to do this if the reduction operation has right-to-left associativity</p><h3 name="3775" id="3775" class="graf graf--h3 graf-after--p">Flattening arrays with <code class="markup--code markup--h3-code">flat()</code> and <code class="markup--code markup--h3-code">flatMap()</code></h3><p name="0afb" id="0afb" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">[1, [2, 3]].flat()</code></p><p name="d049" id="d049" class="graf graf--p graf-after--p">[1, 2, 3]</p><p name="602b" id="602b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[1, [2, [3]]].flat()</code></p><p name="ab93" id="ab93" class="graf graf--p graf-after--p">[1, 2, [3]]</p><p name="568e" id="568e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [1, [2, [3, [4]]]];</code></p><p name="a680" id="a680" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.flat(1)</code></p><p name="4acb" id="4acb" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.flat(2)</code></p><p name="5a7c" id="5a7c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.flat(3)</code></p><p name="71c5" id="71c5" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.flat(4)</code></p><p name="377a" id="377a" class="graf graf--p graf-after--p">[1, 2, [3, [4]]]</p><p name="d20d" id="d20d" class="graf graf--p graf-after--p">[1, 2, 3, [4]]</p><p name="452c" id="452c" class="graf graf--p graf-after--p">[1, 2, 3, 4]</p><p name="7cef" id="7cef" class="graf graf--p graf-after--p">[1, 2, 3, 4]</p><p name="de45" id="de45" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let phrases = [&quot;hello world&quot;, &quot;the definitive guide&quot;];</code><br> <code class="markup--code markup--p-code">let words = phrases.flatMap(phrase =&gt; phrase.split(&quot; &quot;));</code></p><p name="5187" id="5187" class="graf graf--p graf-after--p">[“hello”, “world”, “the”, “definitive”, “guide”];</p><p name="f90d" id="f90d" class="graf graf--p graf-after--p">Calling <code class="markup--code markup--p-code">a.flatMap(f)</code> is the same as (but more efficient than) <code class="markup--code markup--p-code">a.map(f).flat()</code>:</p><h3 name="849a" id="849a" class="graf graf--h3 graf-after--p">Adding arrays with concat()</h3><p name="0e08" id="0e08" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">let a = [1,2,3];</code></p><p name="3991" id="3991" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.concat(4, 5)</code></p><p name="7ac5" id="7ac5" class="graf graf--p graf-after--p">[1,2,3,4,5]</p><p name="af69" id="af69" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.concat([4,5],[6,7])</code></p><p name="7101" id="7101" class="graf graf--p graf-after--p">[1,2,3,4,5,6,7]</p><h3 name="0e46" id="0e46" class="graf graf--h3 graf-after--p">Stacks and Queues with push(), pop(), shift(), and unshift()</h3><p name="ab5e" id="ab5e" class="graf graf--p graf-after--h3">The <code class="markup--code markup--p-code">push()</code> and<code class="markup--code markup--p-code"> pop()</code> methods allow you to work with arrays as if they were stacks. The <code class="markup--code markup--p-code">push()</code> method appends one or more new elements to the end of an array and returns the new length of the array.</p><p name="9dcb" id="9dcb" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">unshift()</code> and <code class="markup--code markup--p-code">shift()</code> methods behave much like <code class="markup--code markup--p-code">push()</code> and<code class="markup--code markup--p-code"> pop()</code>, except that they insert and remove elements from the beginning of an array rather than from the end.</p><p name="2bf6" id="2bf6" class="graf graf--p graf-after--p">You can implement a queue data structure by using <code class="markup--code markup--p-code">push()</code> to add elements at the end of an array and <code class="markup--code markup--p-code">shift()</code> to remove them from the start of the array. Note differences in <code class="markup--code markup--p-code">unshift </code>with single and multiple values.</p><p name="c1da" id="c1da" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [];</code></p><p name="bb6f" id="bb6f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.unshift(1)</code></p><p name="e321" id="e321" class="graf graf--p graf-after--p">[1]</p><p name="0d12" id="0d12" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.unshift(2)</code></p><p name="5941" id="5941" class="graf graf--p graf-after--p">[2, 1]</p><p name="6130" id="6130" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a = [];</code></p><p name="8980" id="8980" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.unshift(1,2)</code></p><p name="a226" id="a226" class="graf graf--p graf-after--p">[1, 2]</p><h3 name="7212" id="7212" class="graf graf--h3 graf-after--p">Subarrays with <code class="markup--code markup--h3-code">slice(), splice(), fill()</code>, and <code class="markup--code markup--h3-code">copyWithin()</code></h3><p name="72d3" id="72d3" class="graf graf--p graf-after--h3">SLICE()</p><p name="e1ed" id="e1ed" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [1,2,3,4,5];</code></p><p name="2fb2" id="2fb2" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.slice(0,3);</code></p><p name="e8e4" id="e8e4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.slice(3);</code></p><p name="8d16" id="8d16" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.slice(1,-1);</code></p><p name="3511" id="3511" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.slice(-3,-2);</code></p><p name="1bd6" id="1bd6" class="graf graf--p graf-after--p">[1,2,3]</p><p name="3100" id="3100" class="graf graf--p graf-after--p">[4,5]</p><p name="0de2" id="0de2" class="graf graf--p graf-after--p">[2,3,4]</p><p name="f8d1" id="f8d1" class="graf graf--p graf-after--p">[3]</p><p name="37ad" id="37ad" class="graf graf--p graf-after--p">SPLICE</p><p name="db80" id="db80" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [1,2,3,4,5,6,7,8];</code></p><p name="e081" id="e081" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.splice(4)</code></p><p name="cbe2" id="cbe2" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.splice(1,2)</code></p><p name="48e9" id="48e9" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.splice(1,1)</code></p><p name="0f22" id="0f22" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [1,2,3,4,5];</code></p><p name="cf74" id="cf74" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.splice(2,0,&quot;a&quot;,&quot;b&quot;)</code></p><p name="49e2" id="49e2" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.splice(2,2,[1,2],3)</code></p><p name="3728" id="3728" class="graf graf--p graf-after--p">[5,6,7,8]; <code class="markup--code markup--p-code">a</code> is now [1,2,3,4]</p><p name="956d" id="956d" class="graf graf--p graf-after--p">[2,3]; a is now [1,4]</p><p name="e266" id="e266" class="graf graf--p graf-after--p">[4]; a is now [1]</p><p name="3e8b" id="3e8b" class="graf graf--p graf-after--p">[]; a is now [1,2,”a”,”b”,3,4,5]</p><p name="e8b6" id="e8b6" class="graf graf--p graf-after--p">[“a”,”b”]; a is now [1,2,[1,2],3,3,4,5]</p><p name="616d" id="616d" class="graf graf--p graf-after--p">FILL()</p><p name="4904" id="4904" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = new Array(5);</code></p><p name="3ea9" id="3ea9" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.fill(0)</code></p><p name="1e4b" id="1e4b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.fill(9, 1)</code></p><p name="3781" id="3781" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.fill(8, 2, -1)</code></p><p name="e3b0" id="e3b0" class="graf graf--p graf-after--p">[0,0,0,0,0]</p><p name="ebf2" id="ebf2" class="graf graf--p graf-after--p">[0,9,9,9,9]</p><p name="f211" id="f211" class="graf graf--p graf-after--p">[0,9,8,8,9]</p><p name="75d9" id="75d9" class="graf graf--p graf-after--p">COPYWITHIN()</p><p name="b4d4" id="b4d4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [1,2,3,4,5];</code></p><p name="a62f" id="a62f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.copyWithin(1)</code></p><p name="1a52" id="1a52" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.copyWithin(2, 3, 5)</code></p><p name="b14f" id="b14f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.copyWithin(0, -2)</code></p><p name="81db" id="81db" class="graf graf--p graf-after--p">[1,1,2,3,4]</p><p name="d55c" id="d55c" class="graf graf--p graf-after--p">[1,1,3,4,4]</p><p name="0fd9" id="0fd9" class="graf graf--p graf-after--p">[4,4,3,4,4]</p><p name="29e3" id="29e3" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">splice()</code> is a general-purpose method for inserting or removing elements from an array.<code class="markup--code markup--p-code"> splice()</code> can delete elements from an array, insert new elements into an array, or perform both operations at the same time.</p><p name="0a1f" id="0a1f" class="graf graf--p graf-after--p">The first argument to <code class="markup--code markup--p-code">splice()</code> specifies the array position at which the insertion and/or deletion is to begin. The second argument specifies the number of elements that should be deleted from (spliced out of) the array.</p><p name="3084" id="3084" class="graf graf--p graf-after--p">Unlike <code class="markup--code markup--p-code">concat(), splice()</code> inserts arrays themselves, not the elements of those arrays.</p><p name="2fd2" id="2fd2" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">copyWithin()</code> copies a slice of an array to a new position within the array. It modifies the array in place and returns the modified array, but it will not change the length of the array.</p><h3 name="30a0" id="30a0" class="graf graf--h3 graf-after--p">Array Searching and Sorting Methods</h3><p name="47c1" id="47c1" class="graf graf--p graf-after--h3">INDEXOF()<br> LASTINDEXOF()</p><p name="9f5d" id="9f5d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [0,1,2,1,0];</code></p><p name="e23d" id="e23d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.indexOf(1)</code></p><p name="6e3a" id="6e3a" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.lastIndexOf(1)</code></p><p name="fe70" id="fe70" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.indexOf(3)</code></p><p name="4d6b" id="4d6b" class="graf graf--p graf-after--p">1</p><p name="e98c" id="e98c" class="graf graf--p graf-after--p">3</p><p name="e1b4" id="e1b4" class="graf graf--p graf-after--p">-1</p><p name="b0d1" id="b0d1" class="graf graf--p graf-after--p">SORT()</p><p name="2e94" id="2e94" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [33, 4, 1111, 222];</code></p><p name="fa4c" id="fa4c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.sort();</code></p><p name="7f55" id="7f55" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.sort((a,b) =&gt; a - b);</code></p><p name="1cc7" id="1cc7" class="graf graf--p graf-after--p">Case-insensitive sort</p><pre name="b2f1" id="b2f1" class="graf graf--pre graf-after--p">let a = [&quot;ant&quot;, &quot;Bug&quot;, &quot;cat&quot;, &quot;Dog&quot;];</pre><pre name="acc1" id="acc1" class="graf graf--pre graf-after--pre">a.sort(); // a == [&quot;Bug&quot;,&quot;Dog&quot;,&quot;ant&quot;,&quot;cat&quot;];</pre><pre name="013a" id="013a" class="graf graf--pre graf-after--pre">a.sort(function(s,t) {</pre><pre name="7fa7" id="7fa7" class="graf graf--pre graf-after--pre">let a = s.toLowerCase();</pre><pre name="6b2a" id="6b2a" class="graf graf--pre graf-after--pre">let b = t.toLowerCase();</pre><pre name="87ca" id="87ca" class="graf graf--pre graf-after--pre">if (a &lt; b) return -1;</pre><pre name="7203" id="7203" class="graf graf--pre graf-after--pre">if (a &gt; b) return 1;</pre><pre name="553c" id="553c" class="graf graf--pre graf-after--pre">return 0;</pre><pre name="14b6" id="14b6" class="graf graf--pre graf-after--pre">});</pre><p name="1e1e" id="1e1e" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">[1111, 222, 33, 4];</code></p><p name="964b" id="964b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[4, 33, 222, 1111]</code></p><p name="7686" id="7686" class="graf graf--p graf-after--p">REVERSE()</p><p name="6626" id="6626" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [1,2,3];</code><br> <code class="markup--code markup--p-code">a.reverse();</code></p><p name="6afd" id="6afd" class="graf graf--p graf-after--p">[3,2,1]</p><p name="1743" id="1743" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">indexOf()</code> and <code class="markup--code markup--p-code">lastIndexOf()</code> compare their argument to the array elements using the equivalent of the === operator. If your array contains objects instead of primitive values, these methods check to see if two references both refer to exactly the same object. If you want to actually look at the content of an object, try using the <code class="markup--code markup--p-code">find()</code> method with your own custom predicate function instead.</p><p name="7bea" id="7bea" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">indexOf()</code> and <code class="markup--code markup--p-code">lastIndexOf()</code> take an optional second argument that specifies the array index at which to begin the search. Negative values are allowed for the second argument and are treated as an offset from the end of the array.</p><p name="0481" id="0481" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">indexOf()</code> will not detect the NaN value in an array, but <code class="markup--code markup--p-code">includes()</code> will</p><p name="d672" id="d672" class="graf graf--p graf-after--p">When <code class="markup--code markup--p-code">sort()</code> is called with no arguments, it sorts the array elements in alphabetical order. To sort an array into some order other than alphabetical, you must pass a comparison function as an argument to <code class="markup--code markup--p-code">sort()</code>.</p><h3 name="a286" id="a286" class="graf graf--h3 graf-after--p">Array to String Conversions</h3><p name="e0dd" id="e0dd" class="graf graf--p graf-after--h3">The <code class="markup--code markup--p-code">join()</code> method converts all the elements of an array to strings and concatenates them, returning the resulting string.</p><p name="ccae" id="ccae" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [1, 2, 3];</code></p><p name="2412" id="2412" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.join()</code></p><p name="6738" id="6738" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.join(&quot; &quot;)</code></p><p name="dea0" id="dea0" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.join(&quot;&quot;)</code></p><p name="4f04" id="4f04" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“1,2,3”</p><p name="e0b3" id="e0b3" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“1 2 3”</p><p name="ea47" id="ea47" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“123”</p><p name="3d96" id="3d96" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let b = new Array(10);</code></p><p name="ebab" id="ebab" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">b.join(&quot;-&quot;)</code></p><p name="c70b" id="c70b" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“ — — — — -”</p><p name="5d18" id="5d18" class="graf graf--p graf-after--p">Arrays, like all JavaScript objects, have a <code class="markup--code markup--p-code">toString()</code> method. For an array, this method works just like the <code class="markup--code markup--p-code">join()</code> method with no arguments:</p><p name="b72a" id="b72a" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[1,2,3].toString()</code></p><p name="3746" id="3746" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“1,2,3”</p><p name="d75f" id="d75f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].toString()</code></p><p name="0e63" id="0e63" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“a,b,c”</p><p name="a30d" id="a30d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[1, [2,&quot;c&quot;]].toString()</code></p><p name="2759" id="2759" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“1,2,c”</p><h3 name="ab9f" id="ab9f" class="graf graf--h3 graf-after--p">Static Array Functions</h3><p name="47cb" id="47cb" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">Array.isArray([])</code></p><p name="d624" id="d624" class="graf graf--p graf-after--p">true</p><p name="6190" id="6190" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Array.isArray({})</code></p><p name="c6fe" id="c6fe" class="graf graf--p graf-after--p">false</p><h3 name="d878" id="d878" class="graf graf--h3 graf-after--p">Array-Like Objects</h3><p name="ea0d" id="ea0d" class="graf graf--p graf-after--h3">It is often perfectly reasonable to treat any object with a numeric <code class="markup--code markup--p-code">length</code> property and corresponding non-negative integer properties as a kind of array.</p><pre name="82e9" id="82e9" class="graf graf--pre graf-after--p">let a = {};</pre><pre name="c469" id="c469" class="graf graf--pre graf-after--pre">let i = 0;</pre><pre name="9627" id="9627" class="graf graf--pre graf-after--pre">while(i &lt; 10) {</pre><pre name="ef67" id="ef67" class="graf graf--pre graf-after--pre">a[i] = i * i;</pre><pre name="aace" id="aace" class="graf graf--pre graf-after--pre">i++;</pre><pre name="9092" id="9092" class="graf graf--pre graf-after--pre">}</pre><pre name="f6b2" id="f6b2" class="graf graf--pre graf-after--pre">a.length = i;</pre><pre name="f459" id="f459" class="graf graf--pre graf-after--pre">// Now iterate through it as if it were a real array</pre><pre name="8f99" id="8f99" class="graf graf--pre graf-after--pre">let total = 0;</pre><pre name="401e" id="401e" class="graf graf--pre graf-after--pre">for(let j = 0; j &lt; a.length; j++) {</pre><pre name="f89d" id="f89d" class="graf graf--pre graf-after--pre">total += a[j];</pre><pre name="e51a" id="e51a" class="graf graf--pre graf-after--pre">}</pre><p name="2317" id="2317" class="graf graf--p graf-after--pre">Since array-like objects do not inherit from <code class="markup--code markup--p-code">Array.prototype</code>, you cannot invoke array methods on them directly. You can invoke them indirectly using the <code class="markup--code markup--p-code">Function.call</code> method.</p><p name="bbd4" id="bbd4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = {&quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot;, length: 3};</code></p><p name="1493" id="1493" class="graf graf--p graf-after--p">// An array-like object</p><p name="0759" id="0759" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Array.prototype.join.call(a, &quot;+&quot;)</code></p><p name="1ce6" id="1ce6" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“a+b+c”</p><p name="e5af" id="e5af" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Array.prototype.join.call(&quot;JavaScript&quot;, &quot; &quot;)</code></p><p name="1c80" id="1c80" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“J a v a S c r i p t”</p><p name="64bf" id="64bf" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Array.prototype.map.call(a, x =&gt; x.toUpperCase())</code></p><p name="acee" id="acee" class="graf graf--p graf-after--p">[“A”,”B”,”C”]</p><p name="1451" id="1451" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Array.from(a)</code></p><p name="1ae1" id="1ae1" class="graf graf--p graf-after--p">[“a”,”b”,”c”]</p><h3 name="faeb" id="faeb" class="graf graf--h3 graf-after--p">Strings as Arrays</h3><p name="7677" id="7677" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">let s = &quot;test&quot;;</code></p><p name="c085" id="c085" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">s.charAt(0)</code></p><p name="b01c" id="b01c" class="graf graf--p graf-after--p">t</p><p name="e09f" id="e09f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">s[1]</code></p><p name="f477" id="f477" class="graf graf--p graf-after--p">e</p><h3 name="6d70" id="6d70" class="graf graf--h3 graf-after--p">Functions</h3><p name="15ff" id="15ff" class="graf graf--p graf-after--h3">In addition to the arguments, each invocation has another value — the invocation context — that is the value of the <code class="markup--code markup--p-code">this</code> keyword.</p><h3 name="17de" id="17de" class="graf graf--h3 graf-after--p">Function Declarations</h3><pre name="fdb1" id="fdb1" class="graf graf--pre graf-after--h3">function printprops(o) {</pre><pre name="8a4a" id="8a4a" class="graf graf--pre graf-after--pre">for(let p in o) {</pre><pre name="7eba" id="7eba" class="graf graf--pre graf-after--pre">console.log(`${p}: ${o[p]}\n`);</pre><pre name="411d" id="411d" class="graf graf--pre graf-after--pre">}</pre><pre name="ad3f" id="ad3f" class="graf graf--pre graf-after--pre">}</pre><p name="808c" id="808c" class="graf graf--p graf-after--pre">Function declaration statements are “hoisted” to the top of the enclosing script, function, or block so that functions defined in this way may be invoked from code that appears before the definition.</p><h3 name="e8fc" id="e8fc" class="graf graf--h3 graf-after--p">Function Expressions</h3><p name="feee" id="feee" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">const square = function(x) { return x*x; };</code></p><pre name="ce46" id="ce46" class="graf graf--pre graf-after--p">const f = function fact(x) {</pre><pre name="2266" id="2266" class="graf graf--pre graf-after--pre">if (x &lt;= 1) return 1;</pre><pre name="3492" id="3492" class="graf graf--pre graf-after--pre">return x * fact(x-1);</pre><pre name="7165" id="7165" class="graf graf--pre graf-after--pre">}</pre><p name="60ea" id="60ea" class="graf graf--p graf-after--pre">Function expressions can include names, which is useful for recursion</p><p name="1064" id="1064" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[3,2,1].sort(function(a,b) { return a - b; });</code></p><p name="ee0c" id="ee0c" class="graf graf--p graf-after--p">Function expressions can also be used as arguments to other functions</p><p name="e108" id="e108" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let tensquared = (function(x) {return x*x;}(10));</code></p><p name="e738" id="e738" class="graf graf--p graf-after--p">Function expressions are sometimes defined and immediately invoked</p><h3 name="611c" id="611c" class="graf graf--h3 graf-after--p">Arrow Functions</h3><p name="8e29" id="8e29" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">const sum = (x, y) =&gt; { return x + y; };</code></p><p name="b178" id="b178" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">const sum = (x, y) =&gt; x + y;</code></p><p name="6c73" id="6c73" class="graf graf--p graf-after--p">no need for <code class="markup--code markup--p-code">return</code></p><p name="bea1" id="bea1" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">const polynomial = x =&gt; x*x + 2*x + 3;</code></p><p name="1ebe" id="1ebe" class="graf graf--p graf-after--p">omit parens with single parameter</p><p name="b969" id="b969" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">const constantFunc = () =&gt; 42;</code></p><p name="eca6" id="eca6" class="graf graf--p graf-after--p">usage for no params</p><p name="7f28" id="7f28" class="graf graf--p graf-after--p">If the body of your arrow function is a single return statement but the expression to be returned is an object literal, then you have to put the object literal inside parentheses to avoid syntactic ambiguity between the curly braces of a function body and the curly braces of an object literal</p><p name="c152" id="c152" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">const f = x =&gt; { return { value: x }; };</code></p><p name="2051" id="2051" class="graf graf--p graf-after--p">good</p><p name="9465" id="9465" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">const g = x =&gt; ({ value: x });</code></p><p name="f43d" id="f43d" class="graf graf--p graf-after--p">good</p><p name="9cd9" id="9cd9" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">const h = x =&gt; { value: x };</code></p><p name="e855" id="e855" class="graf graf--p graf-after--p">returns nothing</p><p name="629d" id="629d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">const i = x =&gt; { v: x, w: x };</code></p><p name="f4e3" id="f4e3" class="graf graf--p graf-after--p">syntax error</p><p name="cdbe" id="cdbe" class="graf graf--p graf-after--p">Arrow functions differ from functions defined in other ways in one critical way: they inherit the value of the <code class="markup--code markup--p-code">this</code> keyword from the environment in which they are defined rather than defining their own invocation context as functions defined in other ways do.</p><h3 name="0578" id="0578" class="graf graf--h3 graf-after--p">Nested Functions</h3><pre name="e755" id="e755" class="graf graf--pre graf-after--h3">function hypotenuse(a, b) {</pre><pre name="e33d" id="e33d" class="graf graf--pre graf-after--pre">function square(x) { return x*x; }</pre><pre name="2e42" id="2e42" class="graf graf--pre graf-after--pre">return Math.sqrt(square(a) + square(b));</pre><pre name="fc71" id="fc71" class="graf graf--pre graf-after--pre">}</pre><h3 name="6b7d" id="6b7d" class="graf graf--h3 graf-after--pre">Invoking Functions</h3><p name="e7c9" id="e7c9" class="graf graf--p graf-after--h3">For function invocation in non-strict mode, the invocation context (the <code class="markup--code markup--p-code">this</code> value) is the global object. In strict mode, however, the invocation context is <code class="markup--code markup--p-code">undefined</code>.</p><p name="feae" id="feae" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">const strict = (function() { return !this; }())</code></p><p name="0251" id="0251" class="graf graf--p graf-after--p">Determine if we’re in strict mode</p><h3 name="c639" id="c639" class="graf graf--h3 graf-after--p">Constructor Invocation</h3><p name="8be7" id="8be7" class="graf graf--p graf-after--h3">A constructor invocation creates a new, empty object that inherits from the object specified by the <code class="markup--code markup--p-code">prototype</code>property of the constructor.</p><h3 name="e004" id="e004" class="graf graf--h3 graf-after--p">Indirect invocation</h3><p name="3803" id="3803" class="graf graf--p graf-after--h3">JavaScript functions are objects, and like all JavaScript objects, they have methods. Two of these methods, <code class="markup--code markup--p-code">call()</code> and <code class="markup--code markup--p-code">apply()</code>, invoke the function indirectly. Both methods allow you to explicitly specify the <code class="markup--code markup--p-code">this </code>value for the invocation, which means you can invoke any function as a method of any object, even if it is not actually a method of that object.</p><h3 name="f019" id="f019" class="graf graf--h3 graf-after--p">Function Arguments and Parameters</h3><h3 name="f888" id="f888" class="graf graf--h3 graf-after--h3">Optional Parameters and Defaults</h3><p name="c803" id="c803" class="graf graf--p graf-after--h3">When a function is invoked with fewer arguments than declared parameters, the additional parameters are set to their default value, which is normally <code class="markup--code markup--p-code">undefined</code>.</p><pre name="fb8b" id="fb8b" class="graf graf--pre graf-after--p">function getPropertyNames(o, a) {</pre><pre name="6b4b" id="6b4b" class="graf graf--pre graf-after--pre">a = a || [];</pre><pre name="c56e" id="c56e" class="graf graf--pre graf-after--pre">for(let property in o) a.push(property);</pre><pre name="8022" id="8022" class="graf graf--pre graf-after--pre">return a;</pre><pre name="bbb8" id="bbb8" class="graf graf--pre graf-after--pre">}</pre><pre name="dc19" id="dc19" class="graf graf--pre graf-after--pre">function getPropertyNames(o, a = []) {</pre><pre name="70a1" id="70a1" class="graf graf--pre graf-after--pre">for(let property in o) a.push(property);</pre><pre name="c3bc" id="c3bc" class="graf graf--pre graf-after--pre">return a;</pre><pre name="b00d" id="b00d" class="graf graf--pre graf-after--pre">}</pre><p name="4ec7" id="4ec7" class="graf graf--p graf-after--pre">One interesting case is that, for functions with multiple parameters, you can use the value of a previous parameter to define the default value of the parameters that follow it</p><pre name="d5cf" id="d5cf" class="graf graf--pre graf-after--p">const rectangle = (width, height = width*2) =&gt; ({width, height});</pre><h3 name="20ec" id="20ec" class="graf graf--h3 graf-after--pre">Rest Parameters and Variable-Length Argument Lists</h3><p name="76ea" id="76ea" class="graf graf--p graf-after--h3">Rest parameters enable us to write functions that can be invoked with arbitrarily more arguments than parameters.</p><pre name="719c" id="719c" class="graf graf--pre graf-after--p">function max(first=-Infinity, ...rest) {</pre><pre name="2615" id="2615" class="graf graf--pre graf-after--pre">let maxValue = first;</pre><pre name="c670" id="c670" class="graf graf--pre graf-after--pre">for(let n of rest) {</pre><pre name="bd6b" id="bd6b" class="graf graf--pre graf-after--pre">if (n &gt; maxValue) {</pre><pre name="f8b6" id="f8b6" class="graf graf--pre graf-after--pre">maxValue = n;</pre><pre name="fade" id="fade" class="graf graf--pre graf-after--pre">}</pre><pre name="aacf" id="aacf" class="graf graf--pre graf-after--pre">}</pre><pre name="14ec" id="14ec" class="graf graf--pre graf-after--pre">return maxValue;</pre><pre name="9071" id="9071" class="graf graf--pre graf-after--pre">}</pre><pre name="1b92" id="1b92" class="graf graf--pre graf-after--pre">max(1, 10, 100, 2, 3, 1000, 4, 5, 6)</pre><p name="17f4" id="17f4" class="graf graf--p graf-after--pre">1000</p><p name="2839" id="2839" class="graf graf--p graf-after--p">within the body of a function, the value of a rest parameter will always be an array. The array may be empty, but a rest parameter will never be <code class="markup--code markup--p-code">undefined</code>.</p><p name="0ff4" id="0ff4" class="graf graf--p graf-after--p">This type of function is called variadic functions, variable arity functions, or vararg functions.</p><h3 name="ef1b" id="ef1b" class="graf graf--h3 graf-after--p">The Arguments Object</h3><p name="cc80" id="cc80" class="graf graf--p graf-after--h3">Within the body of any function, the identifier <code class="markup--code markup--p-code">arguments</code> refers to the Arguments object for that invocation.</p><pre name="4635" id="4635" class="graf graf--pre graf-after--p">function max(x) {</pre><pre name="5982" id="5982" class="graf graf--pre graf-after--pre">let maxValue = -Infinity;</pre><pre name="6eae" id="6eae" class="graf graf--pre graf-after--pre">for(let i = 0; i &lt; arguments.length; i++) {</pre><pre name="15ed" id="15ed" class="graf graf--pre graf-after--pre">if (arguments[i] &gt; maxValue)</pre><pre name="1fb7" id="1fb7" class="graf graf--pre graf-after--pre">maxValue = arguments[i];</pre><pre name="d28d" id="d28d" class="graf graf--pre graf-after--pre">}</pre><pre name="3a1e" id="3a1e" class="graf graf--pre graf-after--pre">return maxValue;</pre><pre name="2d1a" id="2d1a" class="graf graf--pre graf-after--pre">}</pre><pre name="6fdd" id="6fdd" class="graf graf--pre graf-after--pre">max(1, 10, 100, 2, 3, 1000, 4, 5, 6)</pre><p name="1efc" id="1efc" class="graf graf--p graf-after--pre">1000</p><p name="61c6" id="61c6" class="graf graf--p graf-after--p">you should avoid using it in any new code you write.</p><h3 name="7707" id="7707" class="graf graf--h3 graf-after--p">The Spread Operator for Function Calls</h3><pre name="7d92" id="7d92" class="graf graf--pre graf-after--h3">let numbers = [5, 2, 10, -1, 9, 100, 1];</pre><pre name="0b1b" id="0b1b" class="graf graf--pre graf-after--pre">Math.min(...numbers)</pre><p name="0177" id="0177" class="graf graf--p graf-after--pre">-1</p><pre name="6d28" id="6d28" class="graf graf--pre graf-after--p">function timed(f) {</pre><pre name="bd69" id="bd69" class="graf graf--pre graf-after--pre">return function(...args) {</pre><pre name="2a11" id="2a11" class="graf graf--pre graf-after--pre">console.log(`Entering function ${f.name}`);</pre><pre name="4809" id="4809" class="graf graf--pre graf-after--pre">let startTime = Date.now();</pre><pre name="59d4" id="59d4" class="graf graf--pre graf-after--pre">try {</pre><pre name="132f" id="132f" class="graf graf--pre graf-after--pre">return f(...args);</pre><pre name="3f68" id="3f68" class="graf graf--pre graf-after--pre">}</pre><pre name="010e" id="010e" class="graf graf--pre graf-after--pre">finally {</pre><pre name="5f97" id="5f97" class="graf graf--pre graf-after--pre">console.log(`Exiting ${f.name} after ${Date.now() - startTime}ms`);</pre><pre name="794f" id="794f" class="graf graf--pre graf-after--pre">}</pre><pre name="7b9b" id="7b9b" class="graf graf--pre graf-after--pre">};</pre><pre name="b0ab" id="b0ab" class="graf graf--pre graf-after--pre">}</pre><pre name="9444" id="9444" class="graf graf--pre graf-after--pre">// Compute the sum of the numbers between 1 and n by brute force</pre><pre name="8c8f" id="8c8f" class="graf graf--pre graf-after--pre">function benchmark(n) {</pre><pre name="094d" id="094d" class="graf graf--pre graf-after--pre">let sum = 0;</pre><pre name="f0b1" id="f0b1" class="graf graf--pre graf-after--pre">for(let i = 1; i &lt;= n; i++) sum += i;</pre><pre name="7444" id="7444" class="graf graf--pre graf-after--pre">return sum;</pre><pre name="d9c7" id="d9c7" class="graf graf--pre graf-after--pre">}</pre><pre name="8223" id="8223" class="graf graf--pre graf-after--pre">// Now invoke the timed version of that test function</pre><pre name="7fe3" id="7fe3" class="graf graf--pre graf-after--pre">timed(benchmark)(1000000)</pre><h3 name="023a" id="023a" class="graf graf--h3 graf-after--pre">Destructuring Function Arguments into Parameters</h3><pre name="eb03" id="eb03" class="graf graf--pre graf-after--h3">function vectorAdd(v1, v2) {</pre><pre name="02f2" id="02f2" class="graf graf--pre graf-after--pre">return [v1[0] + v2[0], v1[1] + v2[1]];</pre><pre name="7010" id="7010" class="graf graf--pre graf-after--pre">}</pre><pre name="d3c9" id="d3c9" class="graf graf--pre graf-after--pre">vectorAdd([1,2], [3,4])</pre><p name="33b7" id="33b7" class="graf graf--p graf-after--pre">←&gt;</p><pre name="89ec" id="89ec" class="graf graf--pre graf-after--p">function vectorAdd([x1,y1], [x2,y2]) {</pre><pre name="b67d" id="b67d" class="graf graf--pre graf-after--pre">return [x1 + x2, y1 + y2];</pre><pre name="8721" id="8721" class="graf graf--pre graf-after--pre">}</pre><pre name="7092" id="7092" class="graf graf--pre graf-after--pre">vectorAdd([1,2], [3,4])</pre><pre name="83e9" id="83e9" class="graf graf--pre graf-after--pre">function vectorMultiply({x, y}, scalar) {</pre><pre name="2cc6" id="2cc6" class="graf graf--pre graf-after--pre">return { x: x*scalar, y: y*scalar };</pre><pre name="ad45" id="ad45" class="graf graf--pre graf-after--pre">}</pre><pre name="0c15" id="0c15" class="graf graf--pre graf-after--pre">vectorMultiply({x: 1, y: 2}, 2)</pre><p name="64d6" id="64d6" class="graf graf--p graf-after--pre">←&gt;</p><pre name="ff0e" id="ff0e" class="graf graf--pre graf-after--p">function vectorMultiply({x,y}, scalar) {</pre><pre name="4730" id="4730" class="graf graf--pre graf-after--pre">return { x: x*scalar, y: y*scalar};</pre><pre name="8c2e" id="8c2e" class="graf graf--pre graf-after--pre">}</pre><pre name="818a" id="818a" class="graf graf--pre graf-after--pre">vectorMultiply({x: 1, y: 2}, 2)</pre><h3 name="4fe8" id="4fe8" class="graf graf--h3 graf-after--pre">Argument Types</h3><p name="c354" id="c354" class="graf graf--p graf-after--h3">Adding code to check the types of arguments</p><pre name="ae7b" id="ae7b" class="graf graf--pre graf-after--p">function sum(a) {</pre><pre name="8794" id="8794" class="graf graf--pre graf-after--pre">let total = 0;</pre><pre name="b39c" id="b39c" class="graf graf--pre graf-after--pre">for(let element of a) {</pre><pre name="784c" id="784c" class="graf graf--pre graf-after--pre">if (typeof element !== &quot;number&quot;) {</pre><pre name="7338" id="7338" class="graf graf--pre graf-after--pre">throw new TypeError(&quot;sum(): elements must be numbers&quot;);</pre><pre name="74cf" id="74cf" class="graf graf--pre graf-after--pre">}</pre><pre name="d113" id="d113" class="graf graf--pre graf-after--pre">total += element;</pre><pre name="fe94" id="fe94" class="graf graf--pre graf-after--pre">}</pre><pre name="ee47" id="ee47" class="graf graf--pre graf-after--pre">return total;</pre><pre name="548a" id="548a" class="graf graf--pre graf-after--pre">}</pre><p name="30a9" id="30a9" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">sum([1,2,3])</code></p><p name="254a" id="254a" class="graf graf--p graf-after--p">6</p><p name="ccc3" id="ccc3" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">sum(1, 2, 3);</code></p><p name="1b63" id="1b63" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">TypeError</code>: 1 is not iterable</p><p name="1b1d" id="1b1d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">sum([1,2,&quot;3&quot;]);</code></p><p name="915f" id="915f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">TypeError</code>: element 2 is not a number</p><h3 name="e7a8" id="e7a8" class="graf graf--h3 graf-after--p">Functions as Values</h3><pre name="5c5e" id="5c5e" class="graf graf--pre graf-after--h3">function square(x) { return x * x; }</pre><p name="2777" id="2777" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">let s = square;</code></p><p name="29a6" id="29a6" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">square(4)</code></p><p name="c3e4" id="c3e4" class="graf graf--p graf-after--p">16</p><p name="8c33" id="8c33" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">s(4)</code></p><p name="c759" id="c759" class="graf graf--p graf-after--p">16</p><p name="2e6e" id="2e6e" class="graf graf--p graf-after--p">Functions can also be assigned to object properties rather than variables.</p><p name="4594" id="4594" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let o = {square: function(x) { return x*x; }};</code></p><p name="2943" id="2943" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let y = o.square(16);</code></p><p name="1e36" id="1e36" class="graf graf--p graf-after--p">256</p><p name="bca7" id="bca7" class="graf graf--p graf-after--p">Functions don’t even require names at all, as when they’re assigned to array elements:</p><p name="ea90" id="ea90" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let a = [x =&gt; x*x, 20];</code></p><p name="2297" id="2297" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a[0](a[1])</code></p><p name="a1a3" id="a1a3" class="graf graf--p graf-after--p">400</p><p name="1655" id="1655" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a[0]</code> accesses first element of the array, which is &quot;<code class="markup--code markup--p-code">x =&gt; x*x</code>&quot;, <code class="markup--code markup--p-code">(a[1])</code> passes parameter, which is 20.</p><h3 name="bc40" id="bc40" class="graf graf--h3 graf-after--p">Examples of using functions as data</h3><pre name="0a53" id="0a53" class="graf graf--pre graf-after--h3">function add(x,y) { return x + y; }</pre><pre name="d116" id="d116" class="graf graf--pre graf-after--pre">function subtract(x,y) { return x - y; }</pre><pre name="1ba9" id="1ba9" class="graf graf--pre graf-after--pre">function multiply(x,y) { return x * y; }</pre><pre name="6999" id="6999" class="graf graf--pre graf-after--pre">function divide(x,y) { return x / y; }</pre><pre name="6ab9" id="6ab9" class="graf graf--pre graf-after--pre">function operate(operator, operand1, operand2) {</pre><pre name="e569" id="e569" class="graf graf--pre graf-after--pre">return operator(operand1, operand2);</pre><pre name="ce81" id="ce81" class="graf graf--pre graf-after--pre">}</pre><p name="a053" id="a053" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">let i = operate(add, operate(add, 2, 3), operate(multiply, 4,5));</code></p><p name="0e18" id="0e18" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">(2+3) + (4*5):</code></p><p name="51f1" id="51f1" class="graf graf--p graf-after--p">or:</p><pre name="0033" id="0033" class="graf graf--pre graf-after--p">const operators = {</pre><pre name="004b" id="004b" class="graf graf--pre graf-after--pre">add: (x,y) =&gt; x+y,</pre><pre name="ba3e" id="ba3e" class="graf graf--pre graf-after--pre">subtract: (x,y) =&gt; x-y,</pre><pre name="06e7" id="06e7" class="graf graf--pre graf-after--pre">multiply: (x,y) =&gt; x*y,</pre><pre name="37c1" id="37c1" class="graf graf--pre graf-after--pre">divide: (x,y) =&gt; x/y,</pre><pre name="a5dd" id="a5dd" class="graf graf--pre graf-after--pre">pow: Math.pow</pre><pre name="a56e" id="a56e" class="graf graf--pre graf-after--pre">};</pre><pre name="583a" id="583a" class="graf graf--pre graf-after--pre">function operate2(operation, operand1, operand2) {</pre><pre name="8932" id="8932" class="graf graf--pre graf-after--pre">if (typeof operators[operation] === &quot;function&quot;) {</pre><pre name="9579" id="9579" class="graf graf--pre graf-after--pre">return operators[operation](operand1, operand2);</pre><pre name="ee91" id="ee91" class="graf graf--pre graf-after--pre">}</pre><pre name="791a" id="791a" class="graf graf--pre graf-after--pre">else throw &quot;unknown operator&quot;;</pre><pre name="4794" id="4794" class="graf graf--pre graf-after--pre">}</pre><p name="c004" id="c004" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">operate2(&quot;add&quot;, &quot;hello&quot;, operate2(&quot;add&quot;, &quot; &quot;, &quot;world&quot;))</code></p><p name="73f7" id="73f7" class="graf graf--p graf-after--p">// “hello world”</p><p name="d55b" id="d55b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">operate2(&quot;pow&quot;, 10, 2)</code></p><p name="c538" id="c538" class="graf graf--p graf-after--p">100</p><h3 name="17a5" id="17a5" class="graf graf--h3 graf-after--p">Defining Your Own Function Properties</h3><p name="4325" id="4325" class="graf graf--p graf-after--h3">When a function needs a “static” variable whose value persists across invocations, it is often convenient to use a property of the function itself.</p><p name="8eb9" id="8eb9" class="graf graf--p graf-after--p">For example, suppose you want to write a function that returns a unique integer whenever it is invoked. The function must never return the same value twice. In order to manage this, the function needs to keep track of the values it has already returned, and this information must persist across function invocations.</p><pre name="9d9d" id="9d9d" class="graf graf--pre graf-after--p">uniqueInteger.counter = 0;</pre><pre name="dc1c" id="dc1c" class="graf graf--pre graf-after--pre">function uniqueInteger() {</pre><pre name="340c" id="340c" class="graf graf--pre graf-after--pre">return uniqueInteger.counter++;</pre><pre name="cfa2" id="cfa2" class="graf graf--pre graf-after--pre">}</pre><pre name="f2df" id="f2df" class="graf graf--pre graf-after--pre">uniqueInteger()</pre><p name="10a5" id="10a5" class="graf graf--p graf-after--pre">0</p><pre name="1387" id="1387" class="graf graf--pre graf-after--p">uniqueInteger()</pre><p name="e999" id="e999" class="graf graf--p graf-after--pre">1</p><p name="d9b7" id="d9b7" class="graf graf--p graf-after--p">Compute factorials and cache results as properties of the function itself.</p><pre name="994d" id="994d" class="graf graf--pre graf-after--p">function factorial(n) {</pre><pre name="b1da" id="b1da" class="graf graf--pre graf-after--pre">if (Number.isInteger(n) &amp;&amp; n &gt; 0) {</pre><pre name="869f" id="869f" class="graf graf--pre graf-after--pre">if (!(n in factorial)) {</pre><pre name="1b05" id="1b05" class="graf graf--pre graf-after--pre">factorial[n] = n * factorial(n-1);</pre><pre name="e4b3" id="e4b3" class="graf graf--pre graf-after--pre">}</pre><pre name="8141" id="8141" class="graf graf--pre graf-after--pre">return factorial[n];</pre><pre name="37b9" id="37b9" class="graf graf--pre graf-after--pre">}</pre><pre name="7327" id="7327" class="graf graf--pre graf-after--pre">else {</pre><pre name="357e" id="357e" class="graf graf--pre graf-after--pre">return NaN;</pre><pre name="aaef" id="aaef" class="graf graf--pre graf-after--pre">}</pre><pre name="587d" id="587d" class="graf graf--pre graf-after--pre">}</pre><pre name="3f3c" id="3f3c" class="graf graf--pre graf-after--pre">factorial[1] = 1;</pre><p name="9f38" id="9f38" class="graf graf--p graf-after--pre">Initialize the cache to hold this base case.</p><pre name="2a66" id="2a66" class="graf graf--pre graf-after--p">factorial(6)</pre><p name="b7f7" id="b7f7" class="graf graf--p graf-after--pre">720</p><pre name="8d6b" id="8d6b" class="graf graf--pre graf-after--p">factorial[5]</pre><p name="2540" id="2540" class="graf graf--p graf-after--pre">120; the call above caches this value</p><h3 name="e1e5" id="e1e5" class="graf graf--h3 graf-after--p">Functions as Namespaces</h3><p name="aeab" id="aeab" class="graf graf--p graf-after--h3">Variables declared within a function are not visible outside of the function. For this reason, it is sometimes useful to define a function simply to act as a temporary namespace in which you can define variables without cluttering the global namespace.</p><p name="c732" id="c732" class="graf graf--p graf-after--p">Variables that would have been global become local to the function. Following code defines only a single global variable: the function name <code class="markup--code markup--p-code">chunkNamespace</code>.</p><pre name="5021" id="5021" class="graf graf--pre graf-after--p">function chunkNamespace() {</pre><pre name="767a" id="767a" class="graf graf--pre graf-after--pre">// Chunk of code goes here</pre><pre name="02f5" id="02f5" class="graf graf--pre graf-after--pre">// Any variables defined in the chunk are local to this function</pre><pre name="32b3" id="32b3" class="graf graf--pre graf-after--pre">// instead of cluttering up the global namespace.</pre><pre name="f471" id="f471" class="graf graf--pre graf-after--pre">}</pre><pre name="7f49" id="7f49" class="graf graf--pre graf-after--pre">chunkNamespace();</pre><p name="bcd7" id="bcd7" class="graf graf--p graf-after--pre">If defining even a single property is too much, you can define and invoke an anonymous function in a single expression — IIEF (immediately invoked function expression)</p><pre name="a0e3" id="a0e3" class="graf graf--pre graf-after--p">(function() {</pre><pre name="f874" id="f874" class="graf graf--pre graf-after--pre">// chunkNamespace() function rewritten as an unnamed expression.</pre><pre name="0914" id="0914" class="graf graf--pre graf-after--pre">// Chunk of code goes here</pre><pre name="5eee" id="5eee" class="graf graf--pre graf-after--pre">}());</pre><h3 name="cb21" id="cb21" class="graf graf--h3 graf-after--pre">Closures</h3><p name="3d2c" id="3d2c" class="graf graf--p graf-after--h3">JavaScript uses lexical scoping. This means that functions are executed using the variable scope that was in effect when they were defined, not the variable scope that is in effect when they are invoked.</p><p name="cb67" id="cb67" class="graf graf--p graf-after--p">In order to implement lexical scoping, the internal state of a JavaScript function object must include not only the code of the function but also a reference to the scope in which the function definition appears.</p><p name="cc86" id="cc86" class="graf graf--p graf-after--p">This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure.</p><p name="133f" id="133f" class="graf graf--p graf-after--p">Closures become interesting when they are invoked from a different scope than the one they were defined in. This happens most commonly when a nested function object is returned from the function within which it was defined.</p><pre name="4c4c" id="4c4c" class="graf graf--pre graf-after--p">let scope = &quot;global scope&quot;;</pre><pre name="b2f2" id="b2f2" class="graf graf--pre graf-after--pre">function checkscope() {</pre><pre name="9926" id="9926" class="graf graf--pre graf-after--pre">let scope = &quot;local scope&quot;;</pre><pre name="dd4c" id="dd4c" class="graf graf--pre graf-after--pre">function f() { return scope; }</pre><pre name="eb31" id="eb31" class="graf graf--pre graf-after--pre">return f();</pre><pre name="3435" id="3435" class="graf graf--pre graf-after--pre">}</pre><p name="e44f" id="e44f" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">checkscope()</code></p><p name="982b" id="982b" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“local scope”</p><pre name="32a8" id="32a8" class="graf graf--pre graf-after--p">let scope = &quot;global scope&quot;;</pre><pre name="beb9" id="beb9" class="graf graf--pre graf-after--pre">function checkscope() {</pre><pre name="1126" id="1126" class="graf graf--pre graf-after--pre">let scope = &quot;local scope&quot;;</pre><pre name="211b" id="211b" class="graf graf--pre graf-after--pre">function f() { return scope; }</pre><pre name="aa30" id="aa30" class="graf graf--pre graf-after--pre">return f;</pre><pre name="d1d6" id="d1d6" class="graf graf--pre graf-after--pre">}</pre><p name="aced" id="aced" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">let s = checkscope()();</code></p><p name="199a" id="199a" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“local scope”</p><p name="b4b4" id="b4b4" class="graf graf--p graf-after--p">Closures capture the local variables of a single function invocation and can use those variables as private state.</p><pre name="0187" id="0187" class="graf graf--pre graf-after--p">let uniqueInteger = (function() {</pre><pre name="f52a" id="f52a" class="graf graf--pre graf-after--pre">let counter = 0;</pre><pre name="f358" id="f358" class="graf graf--pre graf-after--pre">return function() { return counter++; };</pre><pre name="4054" id="4054" class="graf graf--pre graf-after--pre">}());</pre><p name="5a50" id="5a50" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">uniqueInteger()</code></p><p name="a6dc" id="a6dc" class="graf graf--p graf-after--p">0</p><p name="f01d" id="f01d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">uniqueInteger()</code></p><p name="3c46" id="3c46" class="graf graf--p graf-after--p">1</p><p name="d14c" id="d14c" class="graf graf--p graf-after--p">it is the return value of the function that is being assigned to <code class="markup--code markup--p-code">uniqueInteger</code>.</p><p name="66a9" id="66a9" class="graf graf--p graf-after--p">Private variables like counter need not be exclusive to a single closure: it is perfectly possible for two or more nested functions to be defined within the same outer function and share the same scope.</p><pre name="6d71" id="6d71" class="graf graf--pre graf-after--p">function counter() {</pre><pre name="6de6" id="6de6" class="graf graf--pre graf-after--pre">let n = 0;</pre><pre name="3ab3" id="3ab3" class="graf graf--pre graf-after--pre">return {</pre><pre name="310b" id="310b" class="graf graf--pre graf-after--pre">count: function() { return n++; },</pre><pre name="c626" id="c626" class="graf graf--pre graf-after--pre">reset: function() { n = 0; }</pre><pre name="7889" id="7889" class="graf graf--pre graf-after--pre">};</pre><pre name="51f7" id="51f7" class="graf graf--pre graf-after--pre">}</pre><p name="ab5c" id="ab5c" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">let c = counter(), d = counter();</code></p><p name="760a" id="760a" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">c.count()</code></p><p name="0331" id="0331" class="graf graf--p graf-after--p">0</p><p name="3966" id="3966" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">d.count()</code></p><p name="069a" id="069a" class="graf graf--p graf-after--p">0</p><p name="8b5a" id="8b5a" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">c.reset();</code></p><p name="edb4" id="edb4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">c.count()</code></p><p name="7f12" id="7f12" class="graf graf--p graf-after--p">0</p><p name="f3c2" id="f3c2" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">d.count()</code></p><p name="c529" id="c529" class="graf graf--p graf-after--p">1</p><p name="d101" id="d101" class="graf graf--p graf-after--p">You can combine this closure technique with property getters and setters</p><pre name="ec57" id="ec57" class="graf graf--pre graf-after--p">function counter(n) {</pre><pre name="5acb" id="5acb" class="graf graf--pre graf-after--pre">return {</pre><pre name="647d" id="647d" class="graf graf--pre graf-after--pre">get count() { return n++; },</pre><pre name="edaa" id="edaa" class="graf graf--pre graf-after--pre">set count(m) {</pre><pre name="8ecf" id="8ecf" class="graf graf--pre graf-after--pre">if (m &gt; n) n = m;</pre><pre name="d81a" id="d81a" class="graf graf--pre graf-after--pre">else throw Error(&quot;count can only be set to a larger value&quot;)</pre><pre name="6a79" id="6a79" class="graf graf--pre graf-after--pre">}</pre><pre name="d84e" id="d84e" class="graf graf--pre graf-after--pre">};</pre><pre name="e5bb" id="e5bb" class="graf graf--pre graf-after--pre">}</pre><p name="6b9e" id="6b9e" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">let c = counter(1000);</code></p><p name="2a32" id="2a32" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">c.count</code></p><p name="e1a0" id="e1a0" class="graf graf--p graf-after--p">1000</p><p name="dd89" id="dd89" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">c.count</code></p><p name="bc36" id="bc36" class="graf graf--p graf-after--p">1001</p><p name="8051" id="8051" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">c.count = 2000;</code></p><p name="4273" id="4273" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">c.count</code></p><p name="83f0" id="83f0" class="graf graf--p graf-after--p">2000</p><p name="189a" id="189a" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">c.count = 2000;</code></p><p name="f9fe" id="f9fe" class="graf graf--p graf-after--p">Error: count can only be set to a larger value</p><p name="9c70" id="9c70" class="graf graf--p graf-after--p">Define a private variable and two nested functions to get and set the value of that variable.</p><pre name="bdcf" id="bdcf" class="graf graf--pre graf-after--p">function addPrivateProperty(o, name, predicate) {</pre><pre name="dc71" id="dc71" class="graf graf--pre graf-after--pre">let value;</pre><pre name="1862" id="1862" class="graf graf--pre graf-after--pre">o[`get${name}`] = function() { return value; };</pre><pre name="05ad" id="05ad" class="graf graf--pre graf-after--pre">o[`set${name}`] = function(v) {</pre><pre name="fae2" id="fae2" class="graf graf--pre graf-after--pre">if (predicate &amp;&amp; !predicate(v)) {</pre><pre name="6be9" id="6be9" class="graf graf--pre graf-after--pre">throw new TypeError(`set${name}: invalid value ${v}`);</pre><pre name="2263" id="2263" class="graf graf--pre graf-after--pre">}</pre><pre name="c36b" id="c36b" class="graf graf--pre graf-after--pre">else {</pre><pre name="a0e1" id="a0e1" class="graf graf--pre graf-after--pre">value = v;</pre><pre name="138d" id="138d" class="graf graf--pre graf-after--pre">}</pre><pre name="4380" id="4380" class="graf graf--pre graf-after--pre">};</pre><pre name="de92" id="de92" class="graf graf--pre graf-after--pre">}</pre><p name="f5d7" id="f5d7" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">let o = {};</code></p><p name="0902" id="0902" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">addPrivateProperty(o, &quot;Name&quot;, x =&gt; typeof x === &quot;string&quot;);</code></p><p name="93de" id="93de" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o.setName(&quot;Frank&quot;);</code></p><p name="8d38" id="8d38" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o.getName()</code></p><p name="39d7" id="39d7" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“Frank”</p><p name="e92b" id="e92b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o.setName(0);</code></p><p name="faef" id="faef" class="graf graf--p graf-after--p">TypeError: try to set a value ofthe wrong type</p><h3 name="edca" id="edca" class="graf graf--h3 graf-after--p">Function Properties, Methods, and Constructor</h3><p name="5ed6" id="5ed6" class="graf graf--p graf-after--h3">Since functions are objects, they can have properties and methods, just like any other object.</p><h3 name="6325" id="6325" class="graf graf--h3 graf-after--p">The length Property</h3><p name="3dc6" id="3dc6" class="graf graf--p graf-after--h3">The read-only length property of a function specifies the arity of the function — the number of parameters it declares in its parameter list, which is usually the number of arguments that the function expects.</p><h3 name="857f" id="857f" class="graf graf--h3 graf-after--p">The name Property</h3><p name="0b34" id="0b34" class="graf graf--p graf-after--h3">This property is primarily useful when writing debugging or error messages.</p><h3 name="0700" id="0700" class="graf graf--h3 graf-after--p">The prototype Property</h3><p name="460b" id="460b" class="graf graf--p graf-after--h3">When a function is used as a constructor, the newly created object inherits properties from the prototype object.</p><h3 name="9b18" id="9b18" class="graf graf--h3 graf-after--p">The call() and apply() Methods</h3><p name="2e65" id="2e65" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">call()</code> and <code class="markup--code markup--p-code">apply()</code> allow you to indirectly invoke a function as if it were a method of some other object. The first argument to both <code class="markup--code markup--p-code">call()</code> and <code class="markup--code markup--p-code">apply()</code> is the object on which the function is to be invoked; this argument is the invocation context and becomes the value of the <code class="markup--code markup--p-code">this</code> keyword within the body of the function.</p><p name="4973" id="4973" class="graf graf--p graf-after--p">To invoke the function<code class="markup--code markup--p-code"> f()</code> as a method of the object o (passing no arguments),</p><p name="2b70" id="2b70" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">f.call(o);</code></p><p name="6123" id="6123" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">f.apply(o);</code></p><p name="478a" id="478a" class="graf graf--p graf-after--p">To pass two numbers to the function <code class="markup--code markup--p-code">f()</code> and invoke it as if it were a method of the object o,</p><pre name="98a0" id="98a0" class="graf graf--pre graf-after--p">f.call(o, 1, 2);</pre><p name="7022" id="7022" class="graf graf--p graf-after--pre">The <code class="markup--code markup--p-code">apply()</code> method is like the <code class="markup--code markup--p-code">call()</code> method, except that the arguments to be passed to the function are specified as an array:</p><pre name="1f85" id="1f85" class="graf graf--pre graf-after--p">f.apply(o, [1,2]);</pre><p name="a404" id="a404" class="graf graf--p graf-after--pre">The <code class="markup--code markup--p-code">trace() </code>function defined uses the <code class="markup--code markup--p-code">apply() </code>method instead of a spread operator, and by doing that, it is able to invoke the wrapped method with the same arguments and the same this value as the wrapper method</p><pre name="eda5" id="eda5" class="graf graf--pre graf-after--p">function trace(o, m) {</pre><pre name="bcb5" id="bcb5" class="graf graf--pre graf-after--pre">let original = o[m];</pre><pre name="9c68" id="9c68" class="graf graf--pre graf-after--pre">o[m] = function(...args) {</pre><pre name="1084" id="1084" class="graf graf--pre graf-after--pre">console.log(new Date(), &quot;Entering:&quot;, m);</pre><pre name="e477" id="e477" class="graf graf--pre graf-after--pre">let result = original.apply(this, args);</pre><pre name="9520" id="9520" class="graf graf--pre graf-after--pre">console.log(new Date(), &quot;Exiting:&quot;, m);</pre><pre name="9a0f" id="9a0f" class="graf graf--pre graf-after--pre">return result;</pre><pre name="09bf" id="09bf" class="graf graf--pre graf-after--pre">};</pre><pre name="aa99" id="aa99" class="graf graf--pre graf-after--pre">}</pre><h3 name="3972" id="3972" class="graf graf--h3 graf-after--pre">The bind() Method</h3><p name="7918" id="7918" class="graf graf--p graf-after--h3">The primary purpose of <code class="markup--code markup--p-code">bind()</code> is to bind a function to an object.</p><p name="cefb" id="cefb" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">function f(y) { return this.x + y; }</code></p><p name="f796" id="f796" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let o = { x: 1 };</code></p><p name="d4bf" id="d4bf" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let g = f.bind(o);</code></p><p name="9d44" id="9d44" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">g(2)</code></p><p name="7b73" id="7b73" class="graf graf--p graf-after--p">3</p><p name="d543" id="d543" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let p = { x: 10, g };</code></p><p name="d956" id="d956" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">p.g(2)</code></p><p name="7acd" id="7acd" class="graf graf--p graf-after--p">3 // g is still bound to o, not p.</p><p name="47cf" id="47cf" class="graf graf--p graf-after--p">The most common use case for calling <code class="markup--code markup--p-code">bind()</code> is to make non-arrow functions behave like arrow functions.</p><p name="0590" id="0590" class="graf graf--p graf-after--p">Partial application is a common technique in functional programming and is sometimes called <code class="markup--code markup--p-code">currying</code>.</p><p name="3bac" id="3bac" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let sum = (x,y) =&gt; x + y;</code></p><p name="d96d" id="d96d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let succ = sum.bind(null, 1);</code></p><p name="a34e" id="a34e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">succ(2)</code></p><p name="8459" id="8459" class="graf graf--p graf-after--p">3</p><h3 name="0ed5" id="0ed5" class="graf graf--h3 graf-after--p">The toString() Method</h3><p name="e8ca" id="e8ca" class="graf graf--p graf-after--h3">Most (but not all) implementations of this <code class="markup--code markup--p-code">toString()</code> method return the complete source code for the function</p><h3 name="67ad" id="67ad" class="graf graf--h3 graf-after--p">The Function() Constructor</h3><p name="4702" id="4702" class="graf graf--p graf-after--h3">The Function() constructor is best thought of as a globally scoped version of <code class="markup--code markup--p-code">eval()</code> that defines new variables and functions in its own private scope. You will probably never need to use this constructor in your code.</p><h3 name="8b87" id="8b87" class="graf graf--h3 graf-after--p">Higher-Order Functions</h3><p name="adbb" id="adbb" class="graf graf--p graf-after--h3">A higher-order function is a function that operates on functions, taking one or more functions as arguments and returning a new function.</p><pre name="ff0b" id="ff0b" class="graf graf--pre graf-after--p">function not(f) {</pre><pre name="6420" id="6420" class="graf graf--pre graf-after--pre">return function(...args) {</pre><pre name="24af" id="24af" class="graf graf--pre graf-after--pre">let result = f.apply(this, args);</pre><pre name="b47a" id="b47a" class="graf graf--pre graf-after--pre">return !result;</pre><pre name="4233" id="4233" class="graf graf--pre graf-after--pre">};</pre><pre name="017f" id="017f" class="graf graf--pre graf-after--pre">}</pre><p name="32c8" id="32c8" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">const even = x =&gt; x % 2 === 0;</code></p><p name="ab1e" id="ab1e" class="graf graf--p graf-after--p">A function to determine if a number is even</p><p name="a344" id="a344" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">const odd = not(even);</code></p><p name="f737" id="f737" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[1,1,3,5,5].every(odd)</code></p><p name="36e8" id="36e8" class="graf graf--p graf-after--p">true</p><p name="233b" id="233b" class="graf graf--p graf-after--p">Returns a new function that maps one array to another</p><pre name="eefe" id="eefe" class="graf graf--pre graf-after--p">const map = function(a, ...args) { return a.map(...args); };</pre><pre name="c063" id="c063" class="graf graf--pre graf-after--pre">function mapper(f) {</pre><pre name="5d5a" id="5d5a" class="graf graf--pre graf-after--pre">return a =&gt; map(a, f);</pre><pre name="6a18" id="6a18" class="graf graf--pre graf-after--pre">}</pre><pre name="e97f" id="e97f" class="graf graf--pre graf-after--pre">const increment = x =&gt; x + 1;</pre><pre name="eecd" id="eecd" class="graf graf--pre graf-after--pre">const incrementAll = mapper(increment);</pre><pre name="49c3" id="49c3" class="graf graf--pre graf-after--pre">incrementAll([1,2,3]</pre><p name="7192" id="7192" class="graf graf--p graf-after--pre">[2,3,4]</p><p name="0bd4" id="0bd4" class="graf graf--p graf-after--p">Example that takes two functions, f and g, and returns a new function that computes f(g()):</p><pre name="e880" id="e880" class="graf graf--pre graf-after--p">function compose(f, g) {</pre><pre name="5852" id="5852" class="graf graf--pre graf-after--pre">return function(...args) {</pre><pre name="a54c" id="a54c" class="graf graf--pre graf-after--pre">return f.call(this, g.apply(this, args));</pre><pre name="797f" id="797f" class="graf graf--pre graf-after--pre">};</pre><pre name="435c" id="435c" class="graf graf--pre graf-after--pre">}</pre><p name="b148" id="b148" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">const sum = (x,y) =&gt; x+y;</code></p><p name="2f29" id="2f29" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">const square = x =&gt; x*x;</code></p><p name="b96f" id="b96f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">compose(square, sum)(2,3)</code></p><p name="de32" id="de32" class="graf graf--p graf-after--p">25</p><h3 name="8753" id="8753" class="graf graf--h3 graf-after--p">Memoization</h3><p name="ee01" id="ee01" class="graf graf--p graf-after--h3">We defined a factorial function that cached its previously computed results. In functional programming, this kind of caching is called memoization.</p><h3 name="5465" id="5465" class="graf graf--h3 graf-after--p">Classes</h3><p name="0218" id="0218" class="graf graf--p graf-after--h3">JavaScript’s classes and prototype-based inheritance mechanism are substantially different from the classes and class-based inheritance mechanism of Java.</p><h3 name="ffac" id="ffac" class="graf graf--h3 graf-after--p">Classes and Prototypes</h3><p name="82df" id="82df" class="graf graf--p graf-after--h3">If we define a prototype object and then use <code class="markup--code markup--p-code">Object.create()</code> to create objects that inherit from it, we have defined a JavaScript class.</p><p name="3ee9" id="3ee9" class="graf graf--p graf-after--p">Factory function that returns a new range object:</p><pre name="e36f" id="e36f" class="graf graf--pre graf-after--p">function range(from, to) {</pre><pre name="3f71" id="3f71" class="graf graf--pre graf-after--pre">let r = Object.create(range.methods);</pre><pre name="af0b" id="af0b" class="graf graf--pre graf-after--pre">r.from = from;</pre><pre name="ef8b" id="ef8b" class="graf graf--pre graf-after--pre">r.to = to;</pre><pre name="e226" id="e226" class="graf graf--pre graf-after--pre">return r;</pre><pre name="7124" id="7124" class="graf graf--pre graf-after--pre">}</pre><pre name="3184" id="3184" class="graf graf--pre graf-after--pre">range.methods = {</pre><pre name="fd54" id="fd54" class="graf graf--pre graf-after--pre">includes(x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to; },</pre><pre name="0b22" id="0b22" class="graf graf--pre graf-after--pre">*[Symbol.iterator]() {</pre><pre name="60a7" id="60a7" class="graf graf--pre graf-after--pre">for(let x = Math.ceil(this.from); x &lt;= this.to; x++)</pre><pre name="2d96" id="2d96" class="graf graf--pre graf-after--pre">yield x;</pre><pre name="ca66" id="ca66" class="graf graf--pre graf-after--pre">},</pre><pre name="8179" id="8179" class="graf graf--pre graf-after--pre">toString() { return &quot;(&quot; + this.from + &quot;...&quot; + this.to +&quot;)&quot;; }</pre><pre name="8fbf" id="8fbf" class="graf graf--pre graf-after--pre">};</pre><p name="73a6" id="73a6" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">let r = range(1,3);</code></p><p name="5892" id="5892" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">r.includes(2)</code></p><p name="bce9" id="bce9" class="graf graf--p graf-after--p">true</p><p name="a279" id="a279" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">r.toString()</code></p><p name="b028" id="b028" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“(1…3)”</p><p name="c9d2" id="c9d2" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[...r]</code></p><p name="4580" id="4580" class="graf graf--p graf-after--p">[1, 2, 3]</p><h3 name="551b" id="551b" class="graf graf--h3 graf-after--p">Classes and Constructors</h3><p name="ef35" id="ef35" class="graf graf--p graf-after--h3">A constructor is a function designed for the initialization of newly created objects.</p><p name="2dd4" id="2dd4" class="graf graf--p graf-after--p">The critical feature of constructor invocations is that the <code class="markup--code markup--p-code">prototype</code> property of the constructor is used as the prototype of the new object.</p><p name="ec15" id="ec15" class="graf graf--p graf-after--p">While almost all objects have a prototype, only a few objects have a <code class="markup--code markup--p-code">prototype</code> property. It is function objects that have a <code class="markup--code markup--p-code">prototype</code> property.</p><p name="69c0" id="69c0" class="graf graf--p graf-after--p">This means that all objects created with the same constructor function inherit from the same object and are therefore members of the same class.</p><p name="f483" id="f483" class="graf graf--p graf-after--p">A Range class using a constructor</p><pre name="6edc" id="6edc" class="graf graf--pre graf-after--p">function Range(from, to) {</pre><pre name="944c" id="944c" class="graf graf--pre graf-after--pre">this.from = from;</pre><pre name="cedb" id="cedb" class="graf graf--pre graf-after--pre">this.to = to;</pre><pre name="6457" id="6457" class="graf graf--pre graf-after--pre">}</pre><pre name="e684" id="e684" class="graf graf--pre graf-after--pre">Range.prototype = {</pre><pre name="c127" id="c127" class="graf graf--pre graf-after--pre">includes: function(x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to; },</pre><pre name="1de4" id="1de4" class="graf graf--pre graf-after--pre">[Symbol.iterator]: function*() {</pre><pre name="1525" id="1525" class="graf graf--pre graf-after--pre">for(let x = Math.ceil(this.from); x &lt;= this.to; x++)</pre><pre name="207d" id="207d" class="graf graf--pre graf-after--pre">yield x;</pre><pre name="3df1" id="3df1" class="graf graf--pre graf-after--pre">},</pre><pre name="ae90" id="ae90" class="graf graf--pre graf-after--pre">toString: function() { return &quot;(&quot; + this.from + &quot;...&quot; + this.to + &quot;)&quot;; }</pre><pre name="3bb3" id="3bb3" class="graf graf--pre graf-after--pre">};</pre><p name="8cc7" id="8cc7" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">let r = new Range(1,3);</code></p><p name="5e8f" id="5e8f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">r.includes(2)</code></p><p name="9ae2" id="9ae2" class="graf graf--p graf-after--p">true</p><p name="fb9e" id="fb9e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">r.toString()</code></p><p name="deab" id="deab" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“(1…3)”</p><p name="b805" id="b805" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[...r]</code></p><p name="093c" id="093c" class="graf graf--p graf-after--p">[1, 2, 3]</p><p name="f052" id="f052" class="graf graf--p graf-after--p">Because the <code class="markup--code markup--p-code">Range() </code>constructor is invoked with <code class="markup--code markup--p-code">new</code>, it does not have to call <code class="markup--code markup--p-code">Object.create()</code> or take any action to create a new object.</p><p name="8762" id="8762" class="graf graf--p graf-after--p">In the first example, the prototype was <code class="markup--code markup--p-code">range.methods</code>. This was a convenient and descriptive name, but arbitrary. In the second example, the prototype is <code class="markup--code markup--p-code">Range.prototype</code>, and this name is mandatory.</p><p name="27ce" id="27ce" class="graf graf--p graf-after--p">An invocation of the <code class="markup--code markup--p-code">Range()</code> constructor automatically uses <code class="markup--code markup--p-code">Range.prototype</code> as the prototype of the <code class="markup--code markup--p-code">new Range</code> object.</p><h3 name="8d34" id="8d34" class="graf graf--h3 graf-after--p">Constructors, Class Identity, and instanceof</h3><p name="fac2" id="fac2" class="graf graf--p graf-after--h3">Two objects are instances of the same class if and only if they inherit from the same prototype object.</p><p name="d00c" id="d00c" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">instanceof</code> operator is not checking whether <code class="markup--code markup--p-code">r</code> was actually initialized by the Range constructor. Instead, it is checking whether <code class="markup--code markup--p-code">r</code> inherits from <code class="markup--code markup--p-code">Range.prototype</code>.</p><pre name="0c22" id="0c22" class="graf graf--pre graf-after--p">function Strange() {}</pre><pre name="a1ab" id="a1ab" class="graf graf--pre graf-after--pre">Strange.prototype = Range.prototype;</pre><pre name="7233" id="7233" class="graf graf--pre graf-after--pre">new Strange() instanceof Range</pre><p name="21ed" id="21ed" class="graf graf--p graf-after--pre">true</p><p name="2c31" id="2c31" class="graf graf--p graf-after--p">If you want to test the prototype chain of an object for a specific prototype and do not want to use the constructor function as an intermediary, you can use the <code class="markup--code markup--p-code">isPrototypeOf()</code> method</p><pre name="cc78" id="cc78" class="graf graf--pre graf-after--p">range.methods.isPrototypeOf(r);</pre><h3 name="2e9d" id="2e9d" class="graf graf--h3 graf-after--pre">The constructor Property</h3><p name="64f2" id="64f2" class="graf graf--p graf-after--h3">Every regular JavaScript function automatically has a <code class="markup--code markup--p-code">prototype</code> property. The value of this property is an object that has a single, non-enumerable <code class="markup--code markup--p-code">constructor</code> property.</p><p name="5a55" id="5a55" class="graf graf--p graf-after--p">The value of the <code class="markup--code markup--p-code">constructor</code> property is the function object</p><pre name="e41b" id="e41b" class="graf graf--pre graf-after--p">let F = function() {};</pre><pre name="e5c1" id="e5c1" class="graf graf--pre graf-after--pre">let p = F.prototype;</pre><pre name="9761" id="9761" class="graf graf--pre graf-after--pre">let c = p.constructor;</pre><pre name="e3b7" id="e3b7" class="graf graf--pre graf-after--pre">c === F</pre><p name="5f34" id="5f34" class="graf graf--p graf-after--pre">true</p><p name="6daf" id="6daf" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let o = new F();</code></p><p name="2564" id="2564" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">o.constructor === F</code></p><p name="7ffa" id="7ffa" class="graf graf--p graf-after--p">true</p><p name="2e97" id="2e97" class="graf graf--p graf-after--p">Instances of the Range class, as defined, do not have a constructor property. We can remedy this problem by explicitly adding a constructor to the prototype:</p><pre name="8783" id="8783" class="graf graf--pre graf-after--p">Range.prototype = {</pre><pre name="149e" id="149e" class="graf graf--pre graf-after--pre">constructor: Range</pre><pre name="726d" id="726d" class="graf graf--pre graf-after--pre">};</pre><p name="356e" id="356e" class="graf graf--p graf-after--pre">Another common technique that you are likely to see in older JavaScript code is to use the predefined prototype object with its constructor property and add methods to it one at a time with code like this:</p><pre name="2909" id="2909" class="graf graf--pre graf-after--p">Range.prototype.includes = function(x) {</pre><pre name="6ebc" id="6ebc" class="graf graf--pre graf-after--pre">return this.from &lt;= x &amp;&amp; x &lt;= this.to;</pre><pre name="0360" id="0360" class="graf graf--pre graf-after--pre">};</pre><pre name="c37c" id="c37c" class="graf graf--pre graf-after--pre">Range.prototype.toString = function() {</pre><pre name="f9ad" id="f9ad" class="graf graf--pre graf-after--pre">return &quot;(&quot; + this.from + &quot;...&quot; + this.to + &quot;)&quot;;</pre><pre name="a299" id="a299" class="graf graf--pre graf-after--pre">};</pre><h3 name="f257" id="f257" class="graf graf--h3 graf-after--pre">Classes with the class Keyword</h3><pre name="4f7f" id="4f7f" class="graf graf--pre graf-after--h3">class Range {</pre><pre name="9fda" id="9fda" class="graf graf--pre graf-after--pre">constructor(from, to) {</pre><pre name="3071" id="3071" class="graf graf--pre graf-after--pre">this.from = from;</pre><pre name="e4e0" id="e4e0" class="graf graf--pre graf-after--pre">this.to = to;</pre><pre name="d275" id="d275" class="graf graf--pre graf-after--pre">}</pre><pre name="deb3" id="deb3" class="graf graf--pre graf-after--pre">includes(x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to; }</pre><pre name="462a" id="462a" class="graf graf--pre graf-after--pre">*[Symbol.iterator]() {</pre><pre name="8c44" id="8c44" class="graf graf--pre graf-after--pre">for(let x = Math.ceil(this.from); x &lt;= this.to; x++)</pre><pre name="2342" id="2342" class="graf graf--pre graf-after--pre">yield x;</pre><pre name="9423" id="9423" class="graf graf--pre graf-after--pre">}</pre><pre name="352f" id="352f" class="graf graf--pre graf-after--pre">toString() { return `(${this.from}...${this.to})`; }</pre><pre name="14cd" id="14cd" class="graf graf--pre graf-after--pre">}</pre><p name="eb29" id="eb29" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">let r = new Range(1,3);</code></p><p name="9c62" id="9c62" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">r.includes(2)</code></p><p name="ea19" id="ea19" class="graf graf--p graf-after--p">true</p><p name="6eeb" id="6eeb" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">r.toString()</code></p><p name="b8f2" id="b8f2" class="graf graf--p graf-after--p">(1…3)</p><p name="7f39" id="7f39" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[...r]</code></p><p name="633d" id="633d" class="graf graf--p graf-after--p">[1, 2, 3]</p><p name="de6e" id="de6e" class="graf graf--p graf-after--p">Although class bodies are superficially similar to object literals, they are not the same thing. In particular, they do not support the definition of properties with name/value pairs.</p><p name="ac5b" id="ac5b" class="graf graf--p graf-after--p">If your class does not need to do any initialization, you can omit the constructor keyword and its body, and an empty constructor function will be implicitly created for you.</p><p name="c73c" id="c73c" class="graf graf--p graf-after--p">If you want to define a class that subclasses — or inherits from — another class, you can use the <code class="markup--code markup--p-code">extends</code> keyword with the class keyword:</p><pre name="59ba" id="59ba" class="graf graf--pre graf-after--p">class Span extends Range {</pre><pre name="1866" id="1866" class="graf graf--pre graf-after--pre">constructor(start, length) {</pre><pre name="0838" id="0838" class="graf graf--pre graf-after--pre">if (length &gt;= 0) {</pre><pre name="1db9" id="1db9" class="graf graf--pre graf-after--pre">super(start, start + length);</pre><pre name="08f6" id="08f6" class="graf graf--pre graf-after--pre">}</pre><pre name="3827" id="3827" class="graf graf--pre graf-after--pre">else {</pre><pre name="9be6" id="9be6" class="graf graf--pre graf-after--pre">super(start + length, start);</pre><pre name="b9bb" id="b9bb" class="graf graf--pre graf-after--pre">}</pre><pre name="095c" id="095c" class="graf graf--pre graf-after--pre">}</pre><pre name="22dc" id="22dc" class="graf graf--pre graf-after--pre">}</pre><p name="65e7" id="65e7" class="graf graf--p graf-after--pre">class declarations have both statement and expression forms</p><p name="1610" id="1610" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let Square = class { constructor(x) { this.area = x * x; } };</code></p><p name="0704" id="0704" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">new Square(3).area</code></p><p name="0894" id="0894" class="graf graf--p graf-after--p">9</p><h3 name="f650" id="f650" class="graf graf--h3 graf-after--p">Static methods</h3><p name="0cb6" id="0cb6" class="graf graf--p graf-after--h3">You can define a <code class="markup--code markup--p-code">static</code> method within a class body by prefixing the method declaration with the <code class="markup--code markup--p-code">static</code> keyword. Static methods are defined as properties of the constructor function rather than properties of the prototype object.</p><pre name="1bca" id="1bca" class="graf graf--pre graf-after--p">static parse(s) {</pre><pre name="5ebf" id="5ebf" class="graf graf--pre graf-after--pre">let matches = s.match(/^\((\d+)\.\.\.(\d+)\)$/);</pre><pre name="1f34" id="1f34" class="graf graf--pre graf-after--pre">if (!matches) {</pre><pre name="d01b" id="d01b" class="graf graf--pre graf-after--pre">throw new TypeError(`Cannot parse Range from &quot;${s}&quot;.`)</pre><pre name="ea67" id="ea67" class="graf graf--pre graf-after--pre">}</pre><pre name="5311" id="5311" class="graf graf--pre graf-after--pre">return new Range(parseInt(matches[1]),</pre><pre name="1421" id="1421" class="graf graf--pre graf-after--pre">parseInt(matches[2]));</pre><pre name="25e2" id="25e2" class="graf graf--pre graf-after--pre">}</pre><p name="ff3d" id="ff3d" class="graf graf--p graf-after--pre">The method defined by this code is <code class="markup--code markup--p-code">Range.parse()</code>, not <code class="markup--code markup--p-code">Range.prototype.parse()</code>, and you must invoke it through the constructor, not through an instance:</p><pre name="ac4b" id="ac4b" class="graf graf--pre graf-after--p">let r = Range.parse(&#39;(1...10)&#39;);</pre><h3 name="8dc7" id="8dc7" class="graf graf--h3 graf-after--pre">Getters, Setters, and other Method Forms</h3><p name="b54b" id="b54b" class="graf graf--p graf-after--h3">Within a class body, you can define getter and setter methods just as you can in object literals. The only difference is that in class bodies, you don’t put a comma after the getter or setter.</p><h3 name="96ec" id="96ec" class="graf graf--h3 graf-after--p">Public, Private, and Static Fields</h3><p name="fead" id="fead" class="graf graf--p graf-after--h3">The ES6 standard only allows the creation of methods (including getters, setters, and generators) and static methods; it does not include syntax for defining fields.</p><p name="45a5" id="45a5" class="graf graf--p graf-after--p">If you want to define a field on a class instance, you must do that in the constructor function or in one of the methods. And if you want to define a static field for a class, you must do that outside the class body, after the class has been defined.</p><p name="aa7d" id="aa7d" class="graf graf--p graf-after--p">Standardization is underway, however, for extended class syntax that allows the definition of instance and static fields, in both public and private forms.</p><pre name="de75" id="de75" class="graf graf--pre graf-after--p">class Buffer {</pre><pre name="4892" id="4892" class="graf graf--pre graf-after--pre">constructor() {</pre><pre name="58fa" id="58fa" class="graf graf--pre graf-after--pre">this.size = 0;</pre><pre name="356f" id="356f" class="graf graf--pre graf-after--pre">this.capacity = 4096;</pre><pre name="0602" id="0602" class="graf graf--pre graf-after--pre">this.buffer = new Uint8Array(this.capacity);</pre><pre name="e835" id="e835" class="graf graf--pre graf-after--pre">}</pre><pre name="8897" id="8897" class="graf graf--pre graf-after--pre">}</pre><p name="0f5b" id="0f5b" class="graf graf--p graf-after--pre">←&gt;</p><pre name="aa41" id="aa41" class="graf graf--pre graf-after--p">class Buffer {</pre><pre name="8e5e" id="8e5e" class="graf graf--pre graf-after--pre">size = 0;</pre><pre name="3f47" id="3f47" class="graf graf--pre graf-after--pre">capacity = 4096;</pre><pre name="fa84" id="fa84" class="graf graf--pre graf-after--pre">buffer = new Uint8Array(this.capacity);</pre><pre name="2442" id="2442" class="graf graf--pre graf-after--pre">}</pre><p name="4b76" id="4b76" class="graf graf--p graf-after--pre">The same proposal that seeks to standardize these instance fields also defines private (with the # prefix) instance fields.</p><pre name="2722" id="2722" class="graf graf--pre graf-after--p">class Buffer {</pre><pre name="a3de" id="a3de" class="graf graf--pre graf-after--pre">#size = 0;</pre><pre name="1b3b" id="1b3b" class="graf graf--pre graf-after--pre">get size() { return this.#size; }</pre><pre name="98d3" id="98d3" class="graf graf--pre graf-after--pre">}</pre><p name="287a" id="287a" class="graf graf--p graf-after--pre">A related proposal seeks to standardize the use of the <code class="markup--code markup--p-code">static</code> keyword for fields.</p><pre name="29c7" id="29c7" class="graf graf--pre graf-after--p">static integerRangePattern = /^\((\d+)\.\.\.(\d+)\)$/;</pre><pre name="69bb" id="69bb" class="graf graf--pre graf-after--pre">static parse(s) {</pre><pre name="5408" id="5408" class="graf graf--pre graf-after--pre">let matches = s.match(Range.integerRangePattern);</pre><pre name="64a7" id="64a7" class="graf graf--pre graf-after--pre">if (!matches) {</pre><pre name="dfa8" id="dfa8" class="graf graf--pre graf-after--pre">throw new TypeError(`Cannot parse Range from &quot;${s}&quot;.`)</pre><pre name="b503" id="b503" class="graf graf--pre graf-after--pre">}</pre><pre name="e5c3" id="e5c3" class="graf graf--pre graf-after--pre">return new Range(parseInt(matches[1]), matches[2]);</pre><pre name="5b03" id="5b03" class="graf graf--pre graf-after--pre">}</pre><h3 name="1c22" id="1c22" class="graf graf--h3 graf-after--pre">Adding Methods to Existing Classes</h3><p name="7d7e" id="7d7e" class="graf graf--p graf-after--h3">We can augment JavaScript classes simply by adding new methods to their prototype objects.</p><pre name="8410" id="8410" class="graf graf--pre graf-after--p">if (!String.prototype.startsWith) {</pre><pre name="a3fc" id="a3fc" class="graf graf--pre graf-after--pre">String.prototype.startsWith = function(s) {</pre><pre name="58cc" id="58cc" class="graf graf--pre graf-after--pre">return this.indexOf(s) === 0;</pre><pre name="b75e" id="b75e" class="graf graf--pre graf-after--pre">};</pre><pre name="7f00" id="7f00" class="graf graf--pre graf-after--pre">}</pre><pre name="7ad5" id="7ad5" class="graf graf--pre graf-after--pre">Number.prototype.times = function(f, context) {</pre><pre name="7f4f" id="7f4f" class="graf graf--pre graf-after--pre">let n = this.valueOf();</pre><pre name="9da4" id="9da4" class="graf graf--pre graf-after--pre">for(let i = 0; i &lt; n; i++) f.call(context, i);</pre><pre name="4058" id="4058" class="graf graf--pre graf-after--pre">};</pre><h3 name="3bd2" id="3bd2" class="graf graf--h3 graf-after--pre">Subclasses</h3><h3 name="126c" id="126c" class="graf graf--h3 graf-after--h3">Subclasses and Prototypes</h3><p name="b88d" id="b88d" class="graf graf--p graf-after--h3">Span subclass of the Range class. This subclass will work just like a Range, but instead of initializing it with a start and an end, we’ll instead specify a start and a distance, or span.</p><pre name="2785" id="2785" class="graf graf--pre graf-after--p">function Span(start, span) {</pre><pre name="3e54" id="3e54" class="graf graf--pre graf-after--pre">if (span &gt;= 0) {</pre><pre name="0203" id="0203" class="graf graf--pre graf-after--pre">this.from = start;</pre><pre name="d677" id="d677" class="graf graf--pre graf-after--pre">this.to = start + span;</pre><pre name="379c" id="379c" class="graf graf--pre graf-after--pre">}</pre><pre name="80c7" id="80c7" class="graf graf--pre graf-after--pre">else {</pre><pre name="7c42" id="7c42" class="graf graf--pre graf-after--pre">this.to = start;</pre><pre name="8bb7" id="8bb7" class="graf graf--pre graf-after--pre">this.from = start + span;</pre><pre name="118d" id="118d" class="graf graf--pre graf-after--pre">}</pre><pre name="9471" id="9471" class="graf graf--pre graf-after--pre">}</pre><p name="d217" id="d217" class="graf graf--p graf-after--pre">Ensure that the <code class="markup--code markup--p-code">Span</code> prototype inherits from the <code class="markup--code markup--p-code">Range</code></p><pre name="4012" id="4012" class="graf graf--pre graf-after--p">Span.prototype = Object.create(Range.prototype);</pre><p name="a0f3" id="a0f3" class="graf graf--p graf-after--pre">We don’t want to inherit <code class="markup--code markup--p-code">Range.prototype.constructor</code>, so we define our own constructor property:</p><pre name="ed9d" id="ed9d" class="graf graf--pre graf-after--p">Span.prototype.constructor = Span;</pre><p name="453b" id="453b" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">Span</code> overrides the <code class="markup--code markup--p-code">toString()</code> method</p><p name="6044" id="6044" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Span.prototype.toString = function() {</code><br> <code class="markup--code markup--p-code">return `(${this.from}... +${this.to - this.from})`;</code><br> <code class="markup--code markup--p-code">};</code></p><p name="0eac" id="0eac" class="graf graf--p graf-after--p">A robust subclassing mechanism needs to allow classes to invoke the methods and constructor of their superclass, but prior to ES6, JavaScript did not have a simple way to do these things.</p><h3 name="a62b" id="a62b" class="graf graf--h3 graf-after--p">Subclasses with extends and super</h3><pre name="b694" id="b694" class="graf graf--pre graf-after--h3">class EZArray extends Array {</pre><pre name="01ef" id="01ef" class="graf graf--pre graf-after--pre">get first() { return this[0]; }</pre><pre name="5342" id="5342" class="graf graf--pre graf-after--pre">get last() { return this[this.length-1]; }</pre><pre name="d1cd" id="d1cd" class="graf graf--pre graf-after--pre">}</pre><p name="0fc4" id="0fc4" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">let a = new EZArray();</code></p><p name="9888" id="9888" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a instanceof EZArray</code></p><p name="a0af" id="a0af" class="graf graf--p graf-after--p">true</p><p name="4a91" id="4a91" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a instanceof Array</code></p><p name="c8bc" id="c8bc" class="graf graf--p graf-after--p">true</p><p name="19fe" id="19fe" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.push(1,2,3,4);</code></p><p name="c5ad" id="c5ad" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.pop()</code></p><p name="3852" id="3852" class="graf graf--p graf-after--p">4</p><p name="f3ce" id="f3ce" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.first</code></p><p name="1890" id="1890" class="graf graf--p graf-after--p">1</p><p name="99fe" id="99fe" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">a.last</code></p><p name="efb9" id="efb9" class="graf graf--p graf-after--p">3</p><p name="7866" id="7866" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Array.isArray(a)</code></p><p name="20d2" id="20d2" class="graf graf--p graf-after--p">true</p><p name="e9e3" id="e9e3" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">EZArray.isArray(a)</code></p><p name="017a" id="017a" class="graf graf--p graf-after--p">true</p><p name="3819" id="3819" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Array.prototype.isPrototypeOf(EZArray.prototype</code></p><p name="e2f2" id="e2f2" class="graf graf--p graf-after--p">true</p><p name="c09b" id="c09b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Array.isPrototypeOf(EZArray)</code></p><p name="87f5" id="87f5" class="graf graf--p graf-after--p">true</p><p name="9e01" id="9e01" class="graf graf--p graf-after--p">Example demonstrates the use of the <code class="markup--code markup--p-code">super</code> keyword to invoke the constructor and methods of the superclass</p><pre name="2c1f" id="2c1f" class="graf graf--pre graf-after--p">class TypedMap extends Map {</pre><pre name="7c20" id="7c20" class="graf graf--pre graf-after--pre">constructor(keyType, valueType, entries) {</pre><pre name="9b1c" id="9b1c" class="graf graf--pre graf-after--pre">if (entries) {</pre><pre name="edeb" id="edeb" class="graf graf--pre graf-after--pre">for(let [k, v] of entries) {</pre><pre name="5e06" id="5e06" class="graf graf--pre graf-after--pre">if (typeof k !== keyType || typeof v !== valueType) {</pre><pre name="381e" id="381e" class="graf graf--pre graf-after--pre">throw new TypeError(`Wrong type for entry [${k}, ${v}]`);</pre><pre name="6dd1" id="6dd1" class="graf graf--pre graf-after--pre">}</pre><pre name="ead4" id="ead4" class="graf graf--pre graf-after--pre">}</pre><pre name="aa04" id="aa04" class="graf graf--pre graf-after--pre">}</pre><pre name="b4ed" id="b4ed" class="graf graf--pre graf-after--pre">super(entries);</pre><pre name="a711" id="a711" class="graf graf--pre graf-after--pre">this.keyType = keyType;</pre><pre name="66d3" id="66d3" class="graf graf--pre graf-after--pre">this.valueType = valueType;</pre><pre name="63f8" id="63f8" class="graf graf--pre graf-after--pre">}</pre><pre name="1eeb" id="1eeb" class="graf graf--pre graf-after--pre">set(key, value) {</pre><pre name="ccd9" id="ccd9" class="graf graf--pre graf-after--pre">if (this.keyType &amp;&amp; typeof key !== this.keyType) {</pre><pre name="9f4c" id="9f4c" class="graf graf--pre graf-after--pre">throw new TypeError(`${key} is not of type${this.keyType}`);</pre><pre name="bc0a" id="bc0a" class="graf graf--pre graf-after--pre">}</pre><pre name="cfc9" id="cfc9" class="graf graf--pre graf-after--pre">if (this.valueType &amp;&amp; typeof value !== this.valueType)</pre><pre name="5a49" id="5a49" class="graf graf--pre graf-after--pre">{</pre><pre name="3470" id="3470" class="graf graf--pre graf-after--pre">throw new TypeError(`${value} is not of type ${this.valueType}`);</pre><pre name="0282" id="0282" class="graf graf--pre graf-after--pre">}</pre><pre name="09f6" id="09f6" class="graf graf--pre graf-after--pre">return super.set(key, value);</pre><pre name="3cb9" id="3cb9" class="graf graf--pre graf-after--pre">}</pre><pre name="425f" id="425f" class="graf graf--pre graf-after--pre">}</pre><p name="3239" id="3239" class="graf graf--p graf-after--pre">You may not use the <code class="markup--code markup--p-code">this</code> keyword in your constructor until after you have invoked the superclass constructor with <code class="markup--code markup--p-code">super()</code>. This enforces a rule that superclasses get to initialize themselves before subclasses do.</p><p name="139f" id="139f" class="graf graf--p graf-after--p">Once private fields are supported, we could change these properties to <code class="markup--code markup--p-code">#keyType</code> and <code class="markup--code markup--p-code">#valueType</code> so that they could not be altered from the outside.</p><h3 name="86ad" id="86ad" class="graf graf--h3 graf-after--p">Class Hierarchies and Abstract Classes</h3><p name="03b7" id="03b7" class="graf graf--p graf-after--h3">Define abstract classes — classes that do not include a complete implementation — to serve as a common superclass for a group of related subclasses.</p><h3 name="c7c6" id="c7c6" class="graf graf--h3 graf-after--p">Modules</h3><h3 name="c9d8" id="c9d8" class="graf graf--h3 graf-after--h3">Automating Closure-Based Modularity</h3><p name="e614" id="e614" class="graf graf--p graf-after--h3">Imagine a tool that takes a set of files, wraps the content of each of those files within an immediately invoked function expression, keeps track of the return value of each function, and concatenates everything into one big file.</p><pre name="26e3" id="26e3" class="graf graf--pre graf-after--p">const modules = {};</pre><pre name="473b" id="473b" class="graf graf--pre graf-after--pre">function require(moduleName) { return modules[moduleName]; }</pre><pre name="fd9b" id="fd9b" class="graf graf--pre graf-after--pre">modules[&quot;sets.js&quot;] = (function() {</pre><pre name="b431" id="b431" class="graf graf--pre graf-after--pre">const exports = {};</pre><pre name="19ff" id="19ff" class="graf graf--pre graf-after--pre">exports.BitSet = class BitSet { ... };</pre><pre name="3ee4" id="3ee4" class="graf graf--pre graf-after--pre">return exports;</pre><pre name="56b9" id="56b9" class="graf graf--pre graf-after--pre">}());</pre><pre name="a1f1" id="a1f1" class="graf graf--pre graf-after--pre">modules[&quot;stats.js&quot;] = (function() {</pre><pre name="b096" id="b096" class="graf graf--pre graf-after--pre">const exports = {};</pre><pre name="d853" id="d853" class="graf graf--pre graf-after--pre">const sum = (x, y) =&gt; x + y;</pre><pre name="9f14" id="9f14" class="graf graf--pre graf-after--pre">const square = x = &gt; x * x;</pre><pre name="79cc" id="79cc" class="graf graf--pre graf-after--pre">exports.mean = function(data) { ... };</pre><pre name="2508" id="2508" class="graf graf--pre graf-after--pre">exports.stddev = function(data) { ... };</pre><pre name="d9e9" id="d9e9" class="graf graf--pre graf-after--pre">return exports;</pre><pre name="bfad" id="bfad" class="graf graf--pre graf-after--pre">}());</pre><p name="b8f6" id="b8f6" class="graf graf--p graf-after--pre">writing code like the following to make use of those modules</p><pre name="e913" id="e913" class="graf graf--pre graf-after--p">const stats = require(&quot;stats.js&quot;);</pre><pre name="b790" id="b790" class="graf graf--pre graf-after--pre">const BitSet = require(&quot;sets.js&quot;).BitSet;</pre><pre name="6350" id="6350" class="graf graf--pre graf-after--pre">// Now write code using those modules</pre><pre name="9023" id="9023" class="graf graf--pre graf-after--pre">let s = new BitSet(100);</pre><pre name="51e0" id="51e0" class="graf graf--pre graf-after--pre">s.insert(10);</pre><pre name="493a" id="493a" class="graf graf--pre graf-after--pre">s.insert(20);</pre><pre name="4e11" id="4e11" class="graf graf--pre graf-after--pre">s.insert(30);</pre><pre name="5724" id="5724" class="graf graf--pre graf-after--pre">let average = stats.mean([...s]);</pre><h3 name="8bd8" id="8bd8" class="graf graf--h3 graf-after--pre">Modules in ES6</h3><p name="77e8" id="77e8" class="graf graf--p graf-after--h3">ES6 adds import and export keywords to JavaScript and finally supports real modularity as a core language feature.</p><p name="493f" id="493f" class="graf graf--p graf-after--p">ES6 modularity is conceptually the same as Node modularity: each file is its own module, and constants, variables, functions, and classes defined within a file are private to that module unless they are explicitly exported.</p><h3 name="a557" id="a557" class="graf graf--h3 graf-after--p">ES6 Exports</h3><p name="3a69" id="3a69" class="graf graf--p graf-after--h3">To export a constant, variable, function, or class from an ES6 module, simply add the keyword export before the declaration</p><pre name="7c22" id="7c22" class="graf graf--pre graf-after--p">export const PI = Math.PI;</pre><pre name="c377" id="c377" class="graf graf--pre graf-after--pre">export function degreesToRadians(d) { return d * PI / 180; }</pre><pre name="e84c" id="e84c" class="graf graf--pre graf-after--pre">export class Circle {</pre><pre name="a59b" id="a59b" class="graf graf--pre graf-after--pre">constructor(r) { this.r = r; }</pre><pre name="d202" id="d202" class="graf graf--pre graf-after--pre">area() { return PI * this.r * this.r; }</pre><pre name="a506" id="a506" class="graf graf--pre graf-after--pre">}</pre><p name="0bca" id="0bca" class="graf graf--p graf-after--pre">or:</p><pre name="fab1" id="fab1" class="graf graf--pre graf-after--p">export { Circle, degreesToRadians, PI };</pre><p name="e273" id="e273" class="graf graf--p graf-after--pre">It is common to write modules that export only one value (typically a function or class), and in this case, we usually use export <code class="markup--code markup--p-code">default</code> instead of <code class="markup--code markup--p-code">export</code></p><pre name="bb1c" id="bb1c" class="graf graf--pre graf-after--p">export default class BitSet {</pre><pre name="f5fa" id="f5fa" class="graf graf--pre graf-after--pre">// implementation omitted</pre><pre name="8007" id="8007" class="graf graf--pre graf-after--pre">}</pre><h3 name="9efc" id="9efc" class="graf graf--h3 graf-after--pre">ES6 Imports</h3><pre name="158c" id="158c" class="graf graf--pre graf-after--h3">import BitSet from &#39;./bitset.js&#39;;</pre><pre name="d070" id="d070" class="graf graf--pre graf-after--pre">import { mean, stddev } from &quot;./stats.js&quot;;</pre><p name="3520" id="3520" class="graf graf--p graf-after--pre">When importing from a module that defines many exports, however, you can easily import everything with an import statement like this:</p><pre name="5392" id="5392" class="graf graf--pre graf-after--p">import * as stats from &quot;./stats.js&quot;;</pre><p name="f2dd" id="f2dd" class="graf graf--p graf-after--pre">With the wildcard import shown in the previous example, the importing module would use the imported <code class="markup--code markup--p-code">mean()</code> and<code class="markup--code markup--p-code"> stddev()</code> functions through the stats object, invoking them as <code class="markup--code markup--p-code">stats.mean()</code> and <code class="markup--code markup--p-code">stats.stddev()</code>.</p><p name="137a" id="137a" class="graf graf--p graf-after--p">Note: not finished.</p><h3 name="63ce" id="63ce" class="graf graf--h3 graf-after--p">The JavaScript Standard Library</h3><h3 name="76e1" id="76e1" class="graf graf--h3 graf-after--h3">The Set Class</h3><p name="ff68" id="ff68" class="graf graf--p graf-after--h3">Sets are not ordered or indexed, and they do not allow duplicates.</p><pre name="fbe3" id="fbe3" class="graf graf--pre graf-after--p">let s = new Set();</pre><pre name="9cac" id="9cac" class="graf graf--pre graf-after--pre">let t = new Set([1, s]);</pre><pre name="08b9" id="08b9" class="graf graf--pre graf-after--pre">let t = new Set(s);</pre><pre name="53b0" id="53b0" class="graf graf--pre graf-after--pre">let unique = new Set(&quot;Mississippi&quot;);</pre><p name="c5f4" id="c5f4" class="graf graf--p graf-after--pre">The argument to the <code class="markup--code markup--p-code">Set()</code> constructor need not be an array: any iterable object (including other Set objects) is allowed.</p><p name="48ac" id="48ac" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">add()</code> method takes a single argument; if you pass an array, it adds the array itself to the set, not the individual array elements. <code class="markup--code markup--p-code">add()</code> always returns the set it is invoked on, however, so if you want to add multiple values to a set, you can used chained method calls like.</p><p name="bba0" id="bba0" class="graf graf--p graf-after--p">it is very important to understand that set membership is based on strict equality checks, like the === operator performs.</p><p name="4072" id="4072" class="graf graf--p graf-after--p">The most important thing we do with sets is not to add and remove elements from them, but to check to see whether a specified value is a member of the set:</p><p name="7b0a" id="7b0a" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let oneDigitPrimes = new Set([2,3,5,7]);</code></p><p name="1568" id="1568" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">oneDigitPrimes.has(2)</code></p><p name="c85a" id="c85a" class="graf graf--p graf-after--p">The Set class is iterable, which means that you can use a <code class="markup--code markup--p-code">for/of</code> loop to enumerate all of the elements of a set:</p><pre name="5f8f" id="5f8f" class="graf graf--pre graf-after--p">let sum = 0;</pre><pre name="542d" id="542d" class="graf graf--pre graf-after--pre">for(let p of oneDigitPrimes) {</pre><pre name="6d30" id="6d30" class="graf graf--pre graf-after--pre">sum += p; // and add them up</pre><pre name="a488" id="a488" class="graf graf--pre graf-after--pre">}</pre><p name="7c38" id="7c38" class="graf graf--p graf-after--pre">Because Set objects are iterable, you can convert them to arrays and argument lists with the … spread operator</p><p name="bfdf" id="bfdf" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[...oneDigitPrimes]</code></p><p name="0474" id="0474" class="graf graf--p graf-after--p">JavaScript Set class always remembers the order that elements were inserted in, and it always uses this order when you iterate a set: the first element inserted will be the first one iterated (assuming you haven’t deleted it first), and the most recently inserted element will be the last one iterated.</p><p name="9dd4" id="9dd4" class="graf graf--p graf-after--p">Set class also implements a <code class="markup--code markup--p-code">forEach()</code> method</p><pre name="d596" id="d596" class="graf graf--pre graf-after--p">let product = 1;</pre><pre name="fa52" id="fa52" class="graf graf--pre graf-after--pre">oneDigitPrimes.forEach(n =&gt; { product *= n; });</pre><h3 name="15eb" id="15eb" class="graf graf--h3 graf-after--pre">The Map Class</h3><pre name="dbb1" id="dbb1" class="graf graf--pre graf-after--h3">let m = new Map();</pre><pre name="68b4" id="68b4" class="graf graf--pre graf-after--pre">let n = new Map([[&quot;one&quot;, 1],[&quot;two&quot;, 2]]);</pre><pre name="89d9" id="89d9" class="graf graf--pre graf-after--pre">let copy = new Map(n);</pre><pre name="5e16" id="5e16" class="graf graf--pre graf-after--pre">let o = { x: 1, y: 2};</pre><pre name="4407" id="4407" class="graf graf--pre graf-after--pre">let p = new Map(Object.entries(o));</pre><p name="d032" id="d032" class="graf graf--p graf-after--pre">map is a set of keys, each of which has an associated value. This is not quite the same as a set of key/value pairs.</p><p name="cef3" id="cef3" class="graf graf--p graf-after--p">use <code class="markup--code markup--p-code">has()</code> to check whether a map includes the specified key; use <code class="markup--code markup--p-code">delete()</code> to remove a key (and its associated value) from the map; use <code class="markup--code markup--p-code">clear()</code> to remove all key/value pairs from the map; and use the size property to find out how many keys a map contains.</p><p name="ac82" id="ac82" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">set()</code> method of Map can be chained.</p><p name="a9c7" id="a9c7" class="graf graf--p graf-after--p">Any JavaScript value can be used as a key or a value in a Map. This includes<code class="markup--code markup--p-code"> null, undefined</code>, and <code class="markup--code markup--p-code">NaN</code>, as well as reference types like objects and arrays.</p><p name="76a5" id="76a5" class="graf graf--p graf-after--p">Map compares keys by identity, not by equality.</p><p name="fc89" id="fc89" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let m = new Map();</code></p><p name="1f75" id="1f75" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">m.set({}, 1);</code></p><p name="be11" id="be11" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">m.set({}, 2);</code></p><p name="ced0" id="ced0" class="graf graf--p graf-after--p">Map a different empty object to the number 2.</p><p name="8a08" id="8a08" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">m.get({})</code></p><p name="6eaa" id="6eaa" class="graf graf--p graf-after--p">undefined:</p><p name="f516" id="f516" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">m.set(m, undefined);</code></p><p name="b8e3" id="b8e3" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">m.has(m)</code></p><p name="890d" id="890d" class="graf graf--p graf-after--p">true</p><p name="a8b8" id="a8b8" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">m.get(m)</code></p><p name="ad3c" id="ad3c" class="graf graf--p graf-after--p">undefined</p><p name="9e07" id="9e07" class="graf graf--p graf-after--p">Iterate over map:</p><p name="944b" id="944b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let m = new Map([[&quot;x&quot;, 1], [&quot;y&quot;, 2]]);</code></p><p name="81d4" id="81d4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[...m]</code></p><p name="0449" id="0449" class="graf graf--p graf-after--p">[[“x”, 1], [“y”, 2]]</p><p name="8dc0" id="8dc0" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">for(let [key, value] of m) {...}</code></p><p name="ecb6" id="ecb6" class="graf graf--p graf-after--p">Map class iterates in insertion order</p><p name="26ee" id="26ee" class="graf graf--p graf-after--p">If you want to iterate just the keys or just the associated values of a map, use the <code class="markup--code markup--p-code">keys()</code> and <code class="markup--code markup--p-code">values()</code> methods: these return iterable objects that iterate keys and values, in insertion order. (The<br> <code class="markup--code markup--p-code">entries()</code> method returns an iterable object that iterates key/value pairs, but this is exactly the same as iterating the map directly.)</p><pre name="efa9" id="efa9" class="graf graf--pre graf-after--p">[...m.keys()]</pre><pre name="13ce" id="13ce" class="graf graf--pre graf-after--pre">[...m.values()]</pre><pre name="0bff" id="0bff" class="graf graf--pre graf-after--pre">[...m.entries()]</pre><p name="7dd2" id="7dd2" class="graf graf--p graf-after--pre">Map objects can also be iterated using the <code class="markup--code markup--p-code">forEach()</code></p><pre name="87d8" id="87d8" class="graf graf--pre graf-after--p">m.forEach((value, key) =&gt; {...}</pre><p name="dc7c" id="dc7c" class="graf graf--p graf-after--pre">Note that the value parameter comes before the key parameter.</p><h3 name="2c2d" id="2c2d" class="graf graf--h3 graf-after--p">WeakMap and WeakSet</h3><p name="cff7" id="cff7" class="graf graf--p graf-after--h3">The <code class="markup--code markup--p-code">WeakMap </code>class is a variant (but not an actual subclass) of the Map class that does not prevent its key values from being garbage collected.</p><p name="8334" id="8334" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">WeakMap </code>keys must be objects or arrays; primitive values are not subject to garbage collection and cannot be used as keys.</p><p name="b433" id="b433" class="graf graf--p graf-after--p">WeakMap implements only the<code class="markup--code markup--p-code"> get(), set(), has(),</code> and <code class="markup--code markup--p-code">delete()</code> methods. In particular, <code class="markup--code markup--p-code">WeakMap</code> is not iterable and does not define <code class="markup--code markup--p-code">keys(), values(),</code> or <code class="markup--code markup--p-code">forEach()</code>. If WeakMap was iterable, then its keys would be reachable and it wouldn’t be weak.</p><p name="f390" id="f390" class="graf graf--p graf-after--p">Similarly, WeakMap does not implement the size property because the <code class="markup--code markup--p-code">size</code> of a WeakMap could change at any time as objects are garbage collected</p><h3 name="5bba" id="5bba" class="graf graf--h3 graf-after--p">Typed Arrays and Binary Data</h3><p name="87e3" id="87e3" class="graf graf--p graf-after--h3">They differ from regular arrays in some very important ways</p><p name="000a" id="000a" class="graf graf--p graf-after--p">· The elements of a typed array are all numbers. Unlike regular JavaScript numbers, however, typed arrays allow you to specify the type (signed and unsigned integers and IEEE-754 floating point) and size (8 bits to 64 bits) of the numbers to be stored in the array.</p><p name="fad2" id="fad2" class="graf graf--p graf-after--p">· You must specify the length of a typed array when you create it, and that length can never change.</p><p name="478c" id="478c" class="graf graf--p graf-after--p">· The elements of a typed array are always initialized to 0 when the array is created.</p><pre name="2158" id="2158" class="graf graf--pre graf-after--p">Int8Array()</pre><pre name="ccf7" id="ccf7" class="graf graf--pre graf-after--pre">Uint8Array()</pre><pre name="7578" id="7578" class="graf graf--pre graf-after--pre">Uint8ClampedArray()</pre><pre name="54a1" id="54a1" class="graf graf--pre graf-after--pre">Int16Array()</pre><pre name="19a7" id="19a7" class="graf graf--pre graf-after--pre">Uint32Array()</pre><pre name="a148" id="a148" class="graf graf--pre graf-after--pre">Uint16Array()</pre><pre name="0f2a" id="0f2a" class="graf graf--pre graf-after--pre">Int32Array()</pre><pre name="3f1e" id="3f1e" class="graf graf--pre graf-after--pre">BigInt64Array()</pre><pre name="9e81" id="9e81" class="graf graf--pre graf-after--pre">BigUint64Array()</pre><pre name="e61b" id="e61b" class="graf graf--pre graf-after--pre">Float32Array()</pre><pre name="b7ee" id="b7ee" class="graf graf--pre graf-after--pre">let bytes = new Uint8Array(1024);</pre><pre name="e54e" id="e54e" class="graf graf--pre graf-after--pre">let matrix = new Float64Array(9);</pre><pre name="06d6" id="06d6" class="graf graf--pre graf-after--pre">let sudoku = new Int8Array(81);</pre><p name="aaaf" id="aaaf" class="graf graf--p graf-after--pre">Initialize with values</p><pre name="fd7b" id="fd7b" class="graf graf--pre graf-after--p">let white = Uint8ClampedArray.of(255, 255, 255, 0);</pre><pre name="bef1" id="bef1" class="graf graf--pre graf-after--pre">let ints = Uint32Array.from(white);</pre><p name="50e4" id="50e4" class="graf graf--p graf-after--pre">one more way to create typed arrays that involves the <code class="markup--code markup--p-code">ArrayBuffer</code> type</p><pre name="1e1b" id="1e1b" class="graf graf--pre graf-after--p">let buffer = new ArrayBuffer(1024*1024);</pre><pre name="430b" id="430b" class="graf graf--pre graf-after--pre">buffer.byteLength</pre><p name="d35a" id="d35a" class="graf graf--p graf-after--pre">1024*1024</p><p name="849d" id="849d" class="graf graf--p graf-after--p">Typed arrays are not true arrays, but they re-implement most array methods, so you can use them pretty much just like you’d use regular arrays:</p><p name="7a49" id="7a49" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let ints = new Int16Array(10);</code></p><p name="96ad" id="96ad" class="graf graf--p graf-after--p">10 short integers</p><p name="5b3d" id="5b3d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">ints.fill(3).map(x=&gt;x*x).join(&quot;&quot;)</code></p><p name="2604" id="2604" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“9999999999”</p><p name="d83b" id="d83b" class="graf graf--p graf-after--p">Remember that typed arrays have fixed lengths, so the length property is read-only, and methods that change the length of the array (such as<code class="markup--code markup--p-code"> push(), pop(), unshift(), shift(),</code> and <code class="markup--code markup--p-code">splice()</code>) are not implemented for typed arrays. Methods that alter the contents of an array without changing the length (such as <code class="markup--code markup--p-code">sort(), reverse()</code>, and <code class="markup--code markup--p-code">fill()</code>) are implemented.</p><h3 name="3b0a" id="3b0a" class="graf graf--h3 graf-after--p">Determine Endianess and DataView</h3><pre name="4ee9" id="4ee9" class="graf graf--pre graf-after--h3">let littleEndian = new Int8Array(new Int32Array([1]).buffer)</pre><pre name="dd08" id="dd08" class="graf graf--pre graf-after--pre">[0] === 1;</pre><p name="f495" id="f495" class="graf graf--p graf-after--pre">You can use the <code class="markup--code markup--p-code">DataView</code> class, which defines methods for reading and writing values from an <code class="markup--code markup--p-code">ArrayBuffer</code> with explicitly specified byte ordering. Refer to book for more examples.</p><h3 name="2f05" id="2f05" class="graf graf--h3 graf-after--p">Pattern Matching with Regular Expressions</h3><p name="59ff" id="59ff" class="graf graf--p graf-after--h3">RegExp objects may be created with the <code class="markup--code markup--p-code">RegExp()</code> constructor, of course, but they are more often created using a special literal syntax.</p><pre name="badc" id="badc" class="graf graf--pre graf-after--p">let pattern = /s$/;</pre><p name="c9f3" id="c9f3" class="graf graf--p graf-after--pre">←&gt;</p><pre name="a838" id="a838" class="graf graf--pre graf-after--p">let pattern = new RegExp(&quot;s$&quot;);</pre><p name="f105" id="f105" class="graf graf--p graf-after--pre">Regular expressions can also have one or more flag characters that affect how they work</p><pre name="8b27" id="8b27" class="graf graf--pre graf-after--p">let pattern = /s$/i;</pre><p name="31f5" id="31f5" class="graf graf--p graf-after--pre">i = case insensitive</p><p name="07d4" id="07d4" class="graf graf--p graf-after--p">Punctuation characters have special meanings in regular expressions: <code class="markup--code markup--p-code">^ $ . * + ? = ! : | \ / ( ) [ ] { }. </code>Other punctuation characters, such as quotation marks and @, do not have special meaning and simply match themselves literally in a regular expression.</p><p name="e772" id="e772" class="graf graf--p graf-after--p">If you use the <code class="markup--code markup--p-code">RegExp()</code> constructor, keep in mind that any backslashes in your regular expression need to be doubled, since strings also use backslashes as an escape character.</p><p name="d9b1" id="d9b1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Character</strong></p><p name="5dda" id="5dda" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Matches</strong></p><p name="4990" id="4990" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[...]</code></p><p name="ce97" id="ce97" class="graf graf--p graf-after--p">Any one character between the brackets.</p><p name="1f9d" id="1f9d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[^...]</code></p><p name="8270" id="8270" class="graf graf--p graf-after--p">Any one character not between the brackets</p><p name="9ecf" id="9ecf" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">.</code></p><p name="1e8f" id="1e8f" class="graf graf--p graf-after--p">Any character except newline or another Unicode line terminator. Or, if the <code class="markup--code markup--p-code">RegExp</code> uses the s flag, then a period matches any character, including line terminators.</p><p name="b35e" id="b35e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">\w</code></p><p name="80b1" id="80b1" class="graf graf--p graf-after--p">Any ASCII word character. Equivalent to [a-zA-Z0–9_].</p><p name="15c6" id="15c6" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">\W</code></p><p name="280f" id="280f" class="graf graf--p graf-after--p">Equivalent to [^a-zA-Z0–9_]</p><p name="c512" id="c512" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">\s</code></p><p name="6d23" id="6d23" class="graf graf--p graf-after--p">Any Unicode whitespace character.</p><p name="3646" id="3646" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">\S</code></p><p name="aec3" id="aec3" class="graf graf--p graf-after--p">Any character that is not Unicode whitespace.</p><p name="b1ac" id="b1ac" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">\d</code></p><p name="5052" id="5052" class="graf graf--p graf-after--p">Equivalent to [0–9].</p><p name="e393" id="e393" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">\D</code></p><p name="5b27" id="5b27" class="graf graf--p graf-after--p">Equivalent to [⁰-9].</p><p name="b800" id="b800" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[\b]</code></p><p name="ea16" id="ea16" class="graf graf--p graf-after--p">A literal backspace (special case).</p><p name="9d8d" id="9d8d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[\s\d]</code></p><p name="9727" id="9727" class="graf graf--p graf-after--p">Any one whitespace character or digit</p><p name="ced8" id="ced8" class="graf graf--p graf-after--p">REPETITIONS</p><p name="8479" id="8479" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Character</strong></p><p name="213d" id="213d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Meaning</strong></p><p name="0c33" id="0c33" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">{n,m}</code></p><p name="1acc" id="1acc" class="graf graf--p graf-after--p">Match the previous item at least n times but no more than m times</p><p name="63ea" id="63ea" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">{n,}</code></p><p name="55c2" id="55c2" class="graf graf--p graf-after--p">Match the previous item n or more times.</p><p name="2001" id="2001" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">{n}</code></p><p name="cf25" id="cf25" class="graf graf--p graf-after--p">Match exactly n occurrences of the previous item.</p><p name="0366" id="0366" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">?</code></p><p name="a25f" id="a25f" class="graf graf--p graf-after--p">Equivalent to {0,1}.</p><p name="6ac3" id="6ac3" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">+</code></p><p name="a194" id="a194" class="graf graf--p graf-after--p">Equivalent to {1,}</p><p name="db7c" id="db7c" class="graf graf--p graf-after--p">*</p><p name="7dc0" id="7dc0" class="graf graf--p graf-after--p">Equivalent to {0,}.</p><p name="48c9" id="48c9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example</strong></p><p name="dee1" id="dee1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Description</strong></p><pre name="e7e0" id="e7e0" class="graf graf--pre graf-after--p">let r = /\d{2,4}/;</pre><p name="f9a3" id="f9a3" class="graf graf--p graf-after--pre">Match between two and four digits</p><pre name="2355" id="2355" class="graf graf--pre graf-after--p">r = /\w{3}\d?/;</pre><p name="b38c" id="b38c" class="graf graf--p graf-after--pre">Match exactly three word characters and an optional digit</p><pre name="95fc" id="95fc" class="graf graf--pre graf-after--p">r = /\s+java\s+/;</pre><p name="1fd9" id="1fd9" class="graf graf--p graf-after--pre">Match “java” with one or more spaces before and after</p><pre name="7e48" id="7e48" class="graf graf--pre graf-after--p">r = /[^(]*/;</pre><p name="656c" id="656c" class="graf graf--p graf-after--pre">Match zero or more characters that are not open parens</p><p name="db46" id="db46" class="graf graf--p graf-after--p">If you want to match repetitions of more complicated expressions, you’ll need to define a group with parentheses</p><p name="7ec0" id="7ec0" class="graf graf--p graf-after--p">Be careful when using the * and ? repetition characters. Since these characters may match zero instances of whatever precedes them, they are allowed to match nothing.</p><h3 name="7a98" id="7a98" class="graf graf--h3 graf-after--p">NON-GREEDY REPETITION</h3><p name="2007" id="2007" class="graf graf--p graf-after--h3">It is also possible to specify that repetition should be done in a non-greedy way. Simply follow the repetition character or characters with a question mark: <code class="markup--code markup--p-code">??, +?, *?</code>, or even {1,5}?.</p><p name="b21a" id="b21a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">String</strong></p><p name="fb24" id="fb24" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Pattern</strong></p><p name="6230" id="6230" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Match</strong></p><pre name="4ac3" id="4ac3" class="graf graf--pre graf-after--p">&quot;aaa&quot;</pre><pre name="0f7e" id="0f7e" class="graf graf--pre graf-after--pre">/a+/</pre><pre name="7139" id="7139" class="graf graf--pre graf-after--pre">&quot;aaa&quot;</pre><pre name="2077" id="2077" class="graf graf--pre graf-after--pre">&quot;aaa&quot;</pre><pre name="3fea" id="3fea" class="graf graf--pre graf-after--pre">/a+?/</pre><pre name="9515" id="9515" class="graf graf--pre graf-after--pre">&quot;a&quot;</pre><p name="3669" id="3669" class="graf graf--p graf-after--pre">Note that using non-greedy repetition may not always produce the results you expect. This is because regular expression pattern matching is done by findingthe first position in the string at which a match is possible. Since a match is possible starting at the first character of the string, shorter matches starting at subsequent characters are never even considered.</p><h3 name="a281" id="a281" class="graf graf--h3 graf-after--p">ALTERNATION, GROUPING, AND REFERENCES</h3><p name="1238" id="1238" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Char</strong></p><p name="835c" id="835c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Pattern</strong></p><p name="8bbd" id="8bbd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Pattern</strong></p><p name="0533" id="0533" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">|</code></p><p name="2895" id="2895" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">/ab|cd|ef/</code></p><p name="1efd" id="1efd" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“ab” or the string “cd” or the string “ef”.</p><p name="b8e4" id="b8e4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">/\d{3}|[a-z]{4}/</code></p><p name="c7d5" id="c7d5" class="graf graf--p graf-after--p">either three digits or four lowercase letters.</p><p name="9874" id="9874" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">/a|ab/</code></p><p name="9c39" id="9c39" class="graf graf--p graf-after--p">matches only the first letter “a”</p><p name="7678" id="7678" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">()</code></p><p name="a431" id="a431" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">/java(script)?/</code></p><p name="c7fc" id="c7fc" class="graf graf--p graf-after--p">matches “java” followed by the optional “script”</p><p name="370d" id="370d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">/(ab|cd)+|ef/</code></p><p name="1609" id="1609" class="graf graf--p graf-after--p">matches “java” followed by the optional “script”</p><p name="1745" id="1745" class="graf graf--p graf-after--p">If the left alternative matches, the right alternative is ignored, even if it would have produced a “better” match</p><p name="ae1a" id="ae1a" class="graf graf--p graf-after--p">Another purpose of parentheses in regular expressions is to define subpatterns within the complete pattern. When a regular expression is successfully matched against a target string, it is possible to extract the portions of the target string that matched any particular parenthesized subpattern. For example, suppose you are looking for one or more lowercase letters followed by one or more digits. You might use the pattern <code class="markup--code markup--p-code">/[a-z]+\d+/</code>. But suppose you only really care about the digits at the end of each match. If you put that part of the pattern in parentheses (/[a-z]+(\d+)/), you can extract the digits from any matches you find,</p><p name="1ea0" id="1ea0" class="graf graf--p graf-after--p">A related use of parenthesized subexpressions is to allow you to refer back to a subexpression later in the same regular expression. This is done by following a \ character by a digit or digits. The digits refer to the position of the parenthesized subexpression within the regular expression. For example, \1 refers back to the first subexpression, and \3 refers to the third.</p><p name="7425" id="7425" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Match</strong></p><p name="9e38" id="9e38" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Pattern</strong></p><p name="38ca" id="38ca" class="graf graf--p graf-after--p">zero or more characters within single or double quotes. However, it does not<br> require the opening and closing quotes to match</p><pre name="98fa" id="98fa" class="graf graf--pre graf-after--p">/[&#39;&quot;][^&#39;&quot;]*[&#39;&quot;]/</pre><p name="4c5e" id="4c5e" class="graf graf--p graf-after--pre">To require the quotes to match,use a reference</p><pre name="65c1" id="65c1" class="graf graf--pre graf-after--p">/([&#39;&quot;])[^&#39;&quot;]*\1/</pre><p name="da04" id="da04" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Character</strong></p><p name="ef0d" id="ef0d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Meaning</strong></p><p name="07db" id="07db" class="graf graf--p graf-after--p">|</p><p name="26cb" id="26cb" class="graf graf--p graf-after--p">match either the subexpression to the left or the subexpression to the right.</p><p name="0a60" id="0a60" class="graf graf--p graf-after--p">(…)</p><p name="6663" id="6663" class="graf graf--p graf-after--p">Grouping: group items into a single unit that can be used with *, +, ?, |, and so on. Also remember the characters that match this group for use with later references</p><p name="db7b" id="db7b" class="graf graf--p graf-after--p">(?:…)</p><p name="99eb" id="99eb" class="graf graf--p graf-after--p">group items into a single unit, but do not remember the characters that match this group.</p><p name="496a" id="496a" class="graf graf--p graf-after--p">Note<code class="markup--code markup--p-code"> (?:...)</code> syntax:</p><p name="2694" id="2694" class="graf graf--p graf-after--p">In pattern<code class="markup--code markup--p-code"> &quot;/([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/</code>&quot; <code class="markup--code markup--p-code">\2</code> refers to the text matched by <code class="markup--code markup--p-code">(fun\w*)</code> since <code class="markup--code markup--p-code">(?:[Ss]cript)?)</code> in not remembered.</p><h3 name="f2c8" id="f2c8" class="graf graf--h3 graf-after--p">SPECIFYING MATCH POSITION</h3><p name="21cf" id="21cf" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">regular expression anchors</em> because they anchor the pattern to a specific position in the search string. The most commonly used anchor elements are ^, which ties the pattern to the beginning of the string, and $, which anchors the pattern to the end of the string.</p><p name="a8b2" id="a8b2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example</strong></p><p name="2381" id="2381" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Pattern</strong></p><p name="c74e" id="c74e" class="graf graf--p graf-after--p">match the word “JavaScript” on a line by itself</p><p name="9f94" id="9f94" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">/^JavaScript$/</code></p><p name="da79" id="da79" class="graf graf--p graf-after--p">To search for “Java” as a word by itself you can try the pattern <code class="markup--code markup--p-code">/\sJava\s/</code>, which requires a space before and after the word. But there are two problems with this solution. First, it does not match &quot;Java&quot; at the beginning or the end of a string, but only if it appears with space on either side. Second, when this pattern does find a match, the matched string it returns has leading and trailing spaces, which is not quite what’s needed. So instead of matching actual space characters with \s, match (or anchor to) word boundaries with \b. The resulting expression is <code class="markup--code markup--p-code">/\bJava\b/</code>.</p><p name="b57b" id="b57b" class="graf graf--p graf-after--p">The element <code class="markup--code markup--p-code">\B</code> anchors the match to a location that is not a word boundary. Thus, the pattern <code class="markup--code markup--p-code">/\B[Ss]cript/</code> matches &quot;JavaScript&quot; and &quot;postscript&quot;, but not &quot;script&quot; or &quot;Scripting&quot;.</p><p name="84f8" id="84f8" class="graf graf--p graf-after--p">You can also use arbitrary regular expressions as anchor conditions.</p><p name="a5a4" id="a5a4" class="graf graf--p graf-after--p">If you include an expression within <code class="markup--code markup--p-code">(?= and )</code> characters, it is a lookahead assertion, and it specifies that the enclosed characters must match, without actually matching them.</p><p name="28a1" id="28a1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example</strong></p><p name="15b7" id="15b7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Pattern</strong></p><p name="71d4" id="71d4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Matches</strong></p><p name="39e4" id="39e4" class="graf graf--p graf-after--p">to match the name of a common programming language, but only if it is followed by a colon</p><p name="2f65" id="2f65" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">/[Jj]ava([Ss]cript)?(?=\:)/</code></p><p name="a4c3" id="a4c3" class="graf graf--p graf-after--p">matches the word “JavaScript” in “JavaScript: The DefinitiveGuide”</p><p name="9718" id="9718" class="graf graf--p graf-after--p">does not match “Java” in “Java in a Nutshell”</p><p name="bd51" id="bd51" class="graf graf--p graf-after--p">If you instead introduce an assertion with <code class="markup--code markup--p-code">(?!</code>, it is a negative lookahead assertion.</p><h3 name="e3c7" id="e3c7" class="graf graf--h3 graf-after--p">FLAGS</h3><p name="e227" id="e227" class="graf graf--p graf-after--h3">Flags are specified after the second / character of a regular expression literal or as a string passed as the second argument to the RegExp() constructor.</p><p name="9f4d" id="9f4d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Flag</strong></p><p name="dfb6" id="dfb6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Meaning</strong></p><p name="d726" id="d726" class="graf graf--p graf-after--p">g</p><p name="0ea8" id="0ea8" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“global” — that is,that we intend to use it to find all matches within a string rather than just finding the first <a href="http://match.it/" data-href="http://match.it/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">match.it</a> does alter the behavior of the String <code class="markup--code markup--p-code">match()</code> method and the <code class="markup--code markup--p-code">RegExp exec()</code> method in important ways.</p><p name="1207" id="1207" class="graf graf--p graf-after--p">i</p><p name="1801" id="1801" class="graf graf--p graf-after--p">case-insensitive</p><p name="d011" id="d011" class="graf graf--p graf-after--p">m</p><p name="6076" id="6076" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“multiline” mode</p><p name="b9a1" id="b9a1" class="graf graf--p graf-after--p">s</p><p name="bdfe" id="bdfe" class="graf graf--p graf-after--p">useful when working with text that includes newlines.Normally, a “.” in a regular expression matches any character except a line terminator. When the s flag is used, however, “.” will match any character, including line terminators.</p><p name="37f8" id="37f8" class="graf graf--p graf-after--p">u</p><p name="8425" id="8425" class="graf graf--p graf-after--p">Unicode.</p><p name="b7d7" id="b7d7" class="graf graf--p graf-after--p">Setting the u flag on a RegExp also allows you to use the new <code class="markup--code markup--p-code">\u{...}</code> escape sequence for Unicode character and also enables the \p{...} notation for Unicode character classes.</p><p name="742f" id="742f" class="graf graf--p graf-after--p">y</p><p name="2062" id="2062" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“sticky”. should match at the beginning of a string or at the first character following the previous match</p><h3 name="4bac" id="4bac" class="graf graf--h3 graf-after--p">String Methods for Pattern Matching</h3><h3 name="3180" id="3180" class="graf graf--h3 graf-after--h3">SEARCH()</h3><p name="6fb3" id="6fb3" class="graf graf--p graf-after--h3">Strings support four methods that use regular expressions.</p><p name="a836" id="a836" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">&quot;JavaScript&quot;.search(/script/ui)</code></p><p name="d8b4" id="d8b4" class="graf graf--p graf-after--p">4</p><p name="c194" id="c194" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">&quot;Python&quot;.search(/script/ui)</code></p><p name="d57e" id="d57e" class="graf graf--p graf-after--p">-1</p><p name="7924" id="7924" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">search()</code> does not support global searches; it ignores the <code class="markup--code markup--p-code">g</code> flag of its regular expression argument.</p><p name="d791" id="d791" class="graf graf--p graf-after--p">REPLACE()</p><p name="d007" id="d007" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">text.replace(/javascript/gi, &quot;JavaScript&quot;);</code></p><p name="5c41" id="5c41" class="graf graf--p graf-after--p">No matter how it is capitalized, replace it with the correct capitalization</p><p name="8df2" id="8df2" class="graf graf--p graf-after--p">parenthesized subexpressions of a regular expression are numbered from left to right and that the regular expression remembers the text that each subexpression matches.</p><p name="0b43" id="0b43" class="graf graf--p graf-after--p">to replace quotation marks in a string with other characters:</p><p name="db1c" id="db1c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let quote = /&quot;([^&quot;]*)&quot;/g;</code></p><p name="9c86" id="9c86" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">&#39;He said &quot;stop&quot;&#39;.replace(quote, &#39;«$1»&#39;)</code></p><p name="354e" id="354e" class="graf graf--p graf--startsWithSingleQuote graf-after--p">‘He said «stop»’</p><p name="a23f" id="a23f" class="graf graf--p graf-after--p">If your RegExp uses named capture groups, then you can refer to the matching text by name rather than by number:</p><p name="0620" id="0620" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let quote = /&quot;(?&lt;quotedText&gt;[^&quot;]*)&quot;/g;</code></p><p name="8c54" id="8c54" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">&#39;He said &quot;stop&quot;&#39;.replace(quote, &#39;«$&lt;quotedText&gt;»&#39;)</code></p><p name="28c6" id="28c6" class="graf graf--p graf--startsWithSingleQuote graf-after--p">‘He said «stop»’</p><p name="e45e" id="e45e" class="graf graf--p graf-after--p">Instead of passing a replacement string as the second argument to replace(), you can also pass a function that will be invoked to compute the replacement value.</p><p name="eb40" id="eb40" class="graf graf--p graf-after--p">Example to convert decimal integers in a string to hexadecimal:</p><p name="8009" id="8009" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let s = &quot;15 times 15 is 225&quot;;</code></p><p name="f2eb" id="f2eb" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">s.replace(/\d+/gu, n =&gt; parseInt(n).toString(16))</code></p><p name="235e" id="235e" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“f times f is e1”</p><h3 name="36ae" id="36ae" class="graf graf--h3 graf-after--p">MATCH()</h3><p name="df0c" id="df0c" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">&quot;7 plus 8 equals 15&quot;.match(/\d+/g)</code></p><p name="b24d" id="b24d" class="graf graf--p graf-after--p">[“7”, “8”, “15”]</p><p name="973e" id="973e" class="graf graf--p graf-after--p">If the regular expression does not have the <code class="markup--code markup--p-code">g</code> flag set, <code class="markup--code markup--p-code">match()</code> does not do a global search; it simply searches for the first match. In this nonglobal case, <code class="markup--code markup--p-code">match()</code> still returns an array, but the array elements are completely different.</p><p name="3d88" id="3d88" class="graf graf--p graf-after--p">Thus, if <code class="markup--code markup--p-code">match()</code> returns an array a, a[0] contains the complete match, a[1] contains the substring that matched the first parenthesized expression, and so on.</p><pre name="5d4b" id="5d4b" class="graf graf--pre graf-after--p">let url = /(\w+):\/\/([\w.]+)\/(\S*)/;</pre><pre name="f6de" id="f6de" class="graf graf--pre graf-after--pre">let text = &quot;Visit my blog at http://www.example.com/~david&quot;;</pre><pre name="00e8" id="00e8" class="graf graf--pre graf-after--pre">let match = text.match(url);</pre><pre name="8c6b" id="8c6b" class="graf graf--pre graf-after--pre">let fullurl, protocol, host, path;</pre><pre name="1d38" id="1d38" class="graf graf--pre graf-after--pre">if (match !== null) {</pre><pre name="f8eb" id="f8eb" class="graf graf--pre graf-after--pre">fullurl = match[0];</pre><p name="1200" id="1200" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre"><a href="http://www.example.com/~david" data-href="http://www.example.com/~david" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">“http://www.example.com/~david</a>&quot;</p><pre name="baf6" id="baf6" class="graf graf--pre graf-after--p">protocol = match[1];</pre><p name="7701" id="7701" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“http”</p><pre name="bbb7" id="bbb7" class="graf graf--pre graf-after--p">host = match[2];</pre><p name="3dac" id="3dac" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre"><a href="http://www.example.com/" data-href="http://www.example.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">“www.example.com</a>&quot;</p><pre name="ce0f" id="ce0f" class="graf graf--pre graf-after--p">path = match[3];</pre><p name="5e7d" id="5e7d" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“~david”</p><p name="e008" id="e008" class="graf graf--p graf-after--p">In this non-global case, the array returned by match() also has some object properties in addition to the numbered array elements.</p><p name="c4ac" id="c4ac" class="graf graf--p graf-after--p">input property refers to the string on which match() was called</p><p name="7b37" id="7b37" class="graf graf--p graf-after--p">The index property is the position within that string at which the match starts.</p><p name="2fa6" id="2fa6" class="graf graf--p graf-after--p">if the regular expression contains named capture groups, then the returned array also has a groups property whose value is an object.</p><p name="12de" id="12de" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let url = /(?&lt;protocol&gt;\w+):\/\/(?&lt;host&gt;[\w.]+)\/(?&lt;path&gt;\S*)/;</code></p><p name="ddd8" id="ddd8" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let text = &quot;Visit my blog at http://www.example.com/~david&quot;;</code></p><p name="cc0f" id="cc0f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let match = text.match(url);</code></p><p name="c579" id="c579" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">match[0]</code></p><p name="5dce" id="5dce" class="graf graf--p graf--startsWithDoubleQuote graf-after--p"><a href="http://www.example.com/~david" data-href="http://www.example.com/~david" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">“http://www.example.com/~david</a>&quot;</p><p name="d001" id="d001" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">match.input</code></p><p name="663b" id="663b" class="graf graf--p graf-after--p">text</p><p name="1d17" id="1d17" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">match.index</code></p><p name="a4bb" id="a4bb" class="graf graf--p graf-after--p">17</p><p name="ff39" id="ff39" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">match.groups.protocol</code></p><p name="4177" id="4177" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“http”</p><p name="8666" id="8666" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">match.groups.host</code></p><p name="4504" id="4504" class="graf graf--p graf--startsWithDoubleQuote graf-after--p"><a href="http://www.example.com/" data-href="http://www.example.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">“www.example.com</a>&quot;</p><p name="4533" id="4533" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">match.groups.path</code></p><p name="3448" id="3448" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“~david”</p><p name="71f6" id="71f6" class="graf graf--p graf-after--p">There are also important but less dramatic differences in behavior when the y flag is set. Refer to book for examples.</p><h3 name="5022" id="5022" class="graf graf--h3 graf-after--p">MATCHALL()</h3><p name="66d2" id="66d2" class="graf graf--p graf-after--h3">Instead of returning an array of matching substrings like <code class="markup--code markup--p-code">match()</code> does, however, it returns an iterator that yields the kind of match objects that match() returns when used with a non-global RegExp.</p><h3 name="839b" id="839b" class="graf graf--h3 graf-after--p">SPLIT()</h3><p name="61d1" id="61d1" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">&quot;123,456,789&quot;.split(&quot;,&quot;)</code></p><p name="ea7d" id="ea7d" class="graf graf--p graf-after--p">[“123”, “456”,”789&quot;]</p><p name="3460" id="3460" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">&quot;1, 2, 3,\n4, 5&quot;.split(/\s*,\s*/)</code></p><p name="3a7f" id="3a7f" class="graf graf--p graf-after--p">[“1”, “2”, “3”, “4”,”5&quot;]</p><p name="0de7" id="0de7" class="graf graf--p graf-after--p">Surprisingly, if you call <code class="markup--code markup--p-code">split()</code> with a RegExp delimiter and the regular expression includes capturing groups, then the text that matches the capturing groups will be included in the returned array.</p><p name="cdb0" id="cdb0" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">const htmlTag = /&lt;([^&gt;]+)&gt;/;</code></p><p name="6b01" id="6b01" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">&quot;Testing&lt;br/&gt;1,2,3&quot;.split(htmlTag)</code></p><p name="193a" id="193a" class="graf graf--p graf-after--p">[“Testing”, “br/”,”1,2,3&quot;]</p><h3 name="61fa" id="61fa" class="graf graf--h3 graf-after--p">The RegExp Class</h3><p name="be2b" id="be2b" class="graf graf--p graf-after--h3">The <code class="markup--code markup--p-code">RegExp()</code> constructor is useful when a regular expression is being dynamically created and thus cannot be represented with the regular expression literal syntax.</p><pre name="ad41" id="ad41" class="graf graf--pre graf-after--p">let zipcode = new RegExp(&quot;\\d{5}&quot;, &quot;g&quot;);</pre><p name="626c" id="626c" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">let exactMatch = /JavaScript/;</code><br> <code class="markup--code markup--p-code">let caseInsensitive = new RegExp(exactMatch, &quot;i&quot;);</code></p><h3 name="06d8" id="06d8" class="graf graf--h3 graf-after--p">TEST()</h3><p name="84e3" id="84e3" class="graf graf--p graf-after--h3">Returns true or false by calling <code class="markup--code markup--p-code">exec()</code>.</p><h3 name="4722" id="4722" class="graf graf--h3 graf-after--p">EXEC()</h3><pre name="dc88" id="dc88" class="graf graf--pre graf-after--h3">let pattern = /Java/g;</pre><pre name="4c3d" id="4c3d" class="graf graf--pre graf-after--pre">let text = &quot;JavaScript &gt; Java&quot;;</pre><pre name="1b8b" id="1b8b" class="graf graf--pre graf-after--pre">let match;</pre><pre name="2989" id="2989" class="graf graf--pre graf-after--pre">while((match = pattern.exec(text)) !== null) {</pre><pre name="b4b6" id="b4b6" class="graf graf--pre graf-after--pre">console.log(`Matched ${match[0]} at ${match.index}`);</pre><pre name="ec45" id="ec45" class="graf graf--pre graf-after--pre">console.log(`Next search begins at ${pattern.lastIndex}`);</pre><pre name="06c6" id="06c6" class="graf graf--pre graf-after--pre">}</pre><h3 name="e8ba" id="e8ba" class="graf graf--h3 graf-after--pre">THE LASTINDEX PROPERTY AND REGEXP REUSE</h3><p name="01e2" id="01e2" class="graf graf--p graf-after--h3">The use of the <code class="markup--code markup--p-code">lastIndex</code> property with the g and y flags is a particularly awkward part of this API. When you use these flags, you need to be particularly careful when calling the <code class="markup--code markup--p-code">match(), exec()</code>, or <code class="markup--code markup--p-code">test()</code> methods because the behavior of these methods depends on <code class="markup--code markup--p-code">lastIndex</code>, and the value of <code class="markup--code markup--p-code">lastIndex</code> depends on what you have previously done with the RegExp object.</p><p name="de1e" id="de1e" class="graf graf--p graf-after--p">To find the index of all &lt;p&gt; tags within a string of HTML text:</p><pre name="499e" id="499e" class="graf graf--pre graf-after--p">let match, positions = [];</pre><pre name="2953" id="2953" class="graf graf--pre graf-after--pre">while((match = /&lt;p&gt;/g.exec(html)) !== null) {</pre><pre name="30cb" id="30cb" class="graf graf--pre graf-after--pre">positions.push(match.index);</pre><pre name="6bc6" id="6bc6" class="graf graf--pre graf-after--pre">}</pre><p name="5d28" id="5d28" class="graf graf--p graf-after--pre">If the html string contains at least one &lt;p&gt; tag, then it will loop forever. For each iteration of the loop, we’re creating a new RegExp object with <code class="markup--code markup--p-code">lastIndex</code> set to 0, so <code class="markup--code markup--p-code">exec()</code> always begins at the start of the string, and if there is a match, it will keep matching over and over. The solution, of course, is to define the RegExp once, and save it to a variable so that we’re using the same RegExp object for each iteration of the loop.</p><p name="f2d8" id="f2d8" class="graf graf--p graf-after--p">On the other hand, sometimes reusing a RegExp object is the wrong thing to do. Suppose, for example, that we want to loop through all of the words in a dictionary to find words that contain pairs of double letters.</p><pre name="4d45" id="4d45" class="graf graf--pre graf-after--p">let dictionary = [ &quot;apple&quot;, &quot;book&quot;, &quot;coffee&quot; ];</pre><pre name="fd51" id="fd51" class="graf graf--pre graf-after--pre">let doubleLetterWords = [];</pre><pre name="3709" id="3709" class="graf graf--pre graf-after--pre">let doubleLetter = /(\w)\1/g;</pre><pre name="a3b5" id="a3b5" class="graf graf--pre graf-after--pre">for(let word of dictionary) {</pre><pre name="3dd3" id="3dd3" class="graf graf--pre graf-after--pre">if (doubleLetter.test(word)) {</pre><pre name="b6a5" id="b6a5" class="graf graf--pre graf-after--pre">doubleLetterWords.push(word);</pre><pre name="bd33" id="bd33" class="graf graf--pre graf-after--pre">}</pre><pre name="007c" id="007c" class="graf graf--pre graf-after--pre">}</pre><p name="4165" id="4165" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">doubleLetterWords</code></p><p name="4424" id="4424" class="graf graf--p graf-after--p">[“apple”, “coffee”]: “book” is missing!</p><p name="5358" id="5358" class="graf graf--p graf-after--p">Because we set the g flag on the RegExp, the <code class="markup--code markup--p-code">lastIndex</code> property is changed after successful matches, and the <code class="markup--code markup--p-code">test()</code> method (which is based on <code class="markup--code markup--p-code">exec()</code>) starts searching for a match at the position specified by <code class="markup--code markup--p-code">lastIndex</code>. After matching the &quot;pp&quot; in &quot;apple&quot;, <code class="markup--code markup--p-code">lastIndex</code> is 3, and so we start searching the word &quot;book&quot; at position 3 and do not see the &quot;oo&quot; that it contains.</p><h3 name="ccfb" id="ccfb" class="graf graf--h3 graf-after--p">Dates and Times</h3><pre name="2f75" id="2f75" class="graf graf--pre graf-after--h3">let now = new Date();</pre><p name="eb95" id="eb95" class="graf graf--p graf-after--pre">The current time</p><pre name="79ef" id="79ef" class="graf graf--pre graf-after--p">let epoch = new Date(0);</pre><p name="210e" id="210e" class="graf graf--p graf-after--pre">Midnight, January 1st, 1970, GMT</p><pre name="6d18" id="6d18" class="graf graf--pre graf-after--p">let century = new Date(2100,</pre><pre name="0c34" id="0c34" class="graf graf--pre graf-after--pre">0,</pre><pre name="8046" id="8046" class="graf graf--pre graf-after--pre">1,</pre><pre name="50ba" id="50ba" class="graf graf--pre graf-after--pre">2, 3, 4, 5);</pre><p name="f1f3" id="f1f3" class="graf graf--p graf-after--pre">Year 2100</p><p name="4409" id="4409" class="graf graf--p graf-after--p">January</p><p name="3c36" id="3c36" class="graf graf--p graf-after--p">1st</p><p name="366a" id="366a" class="graf graf--p graf-after--p">02:03:04.005, local</p><pre name="7fe0" id="7fe0" class="graf graf--pre graf-after--p">let century = new Date(Date.UTC(2100, 0, 1));</pre><p name="fa3a" id="fa3a" class="graf graf--p graf-after--pre">Midnight in GMT, January 1, 2100</p><p name="293b" id="293b" class="graf graf--p graf-after--p">If you print a date (with console.log(century), for example), it will, by default, be printed in your local time zone. If you want to display a date in UTC, you should explicitly convert it to a string with <code class="markup--code markup--p-code">toUTCString()</code> or<code class="markup--code markup--p-code"> toISOString()</code>.</p><p name="9d7e" id="9d7e" class="graf graf--p graf-after--p">if you pass a string to the Date() constructor, it will attempt to parse that string as a date and time specification</p><p name="c6ab" id="c6ab" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let century = new Date(&quot;2100-01-01T00:00:00Z&quot;);</code></p><p name="7e34" id="7e34" class="graf graf--p graf-after--p">Once you have a Date object, various get and set methods allow you to query and modify the year, month, day-of-month, hour, minute, second, and millisecond fields of the Date. Each of these methods hastwo forms: one that gets or sets using local time and one that gets or sets using UTC time.</p><p name="cce8" id="cce8" class="graf graf--p graf-after--p">Note that the methods for querying the day-of-month are <code class="markup--code markup--p-code">getDate()</code> and <code class="markup--code markup--p-code">getUTCDate()</code>. The more natural-sounding functions <code class="markup--code markup--p-code">getDay()</code> and <code class="markup--code markup--p-code">getUTCDay()</code> return the day-of-week (0 for Sunday through 6 for Saturday). The day-of-week is read-only, so there is not a corresponding <code class="markup--code markup--p-code">setDay()</code> method.</p><h3 name="4903" id="4903" class="graf graf--h3 graf-after--p">Timestamps</h3><p name="cec5" id="cec5" class="graf graf--p graf-after--h3">JavaScript represents dates internally as integers that specify the number of milliseconds since (or before) midnight on January 1, 1970, UTC time.</p><p name="0c0a" id="0c0a" class="graf graf--p graf-after--p">For any Date object, the <code class="markup--code markup--p-code">getTime()</code> method returns this internal value, and the <code class="markup--code markup--p-code">setTime()</code> method sets it.</p><pre name="b06b" id="b06b" class="graf graf--pre graf-after--p">d.setTime(d.getTime() + 30000);</pre><p name="343d" id="343d" class="graf graf--p graf-after--pre">add 30 secs</p><p name="2c19" id="2c19" class="graf graf--p graf-after--p">The static Date.now() method returns the current time as a timestamp and is helpful when you want to measure how long your code takes to run</p><pre name="58fe" id="58fe" class="graf graf--pre graf-after--p">let startTime = Date.now();</pre><pre name="5d6a" id="5d6a" class="graf graf--pre graf-after--pre">reticulateSplines(); // Do some time-consuming operation</pre><pre name="a4e7" id="a4e7" class="graf graf--pre graf-after--pre">let endTime = Date.now();</pre><pre name="c537" id="c537" class="graf graf--pre graf-after--pre">console.log(`Spline reticulation took ${endTime -startTime}ms.`);</pre><p name="4875" id="4875" class="graf graf--p graf-after--pre">adds three months and two weeks to the current date:</p><p name="caf9" id="caf9" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let d = new Date();</code><br> <code class="markup--code markup--p-code">d.setMonth(d.getMonth() + 3, d.getDate() + 14);</code></p><h3 name="ea96" id="ea96" class="graf graf--h3 graf-after--p">Formatting and Parsing Date Strings</h3><pre name="853e" id="853e" class="graf graf--pre graf-after--h3">let d = new Date(2020, 0, 1, 17, 10, 30);</pre><pre name="b193" id="b193" class="graf graf--pre graf-after--pre">d.toString()</pre><p name="81a9" id="81a9" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“Wed Jan 01 2020 17:10:30 GMT-0800 (Pacific Standard Time)”</p><pre name="9ee6" id="9ee6" class="graf graf--pre graf-after--p">d.toUTCString()</pre><p name="b9aa" id="b9aa" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“Thu, 02 Jan 2020 01:10:30 GMT”</p><pre name="9745" id="9745" class="graf graf--pre graf-after--p">d.toLocaleDateString()</pre><p name="db30" id="db30" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“1/1/2020”: ‘en-US’ locale</p><pre name="664a" id="664a" class="graf graf--pre graf-after--p">d.toLocaleTimeString()</pre><p name="2a15" id="2a15" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“5:10:30 PM”: ‘en-US’ locale</p><pre name="7bf8" id="7bf8" class="graf graf--pre graf-after--p">d.toISOString()</pre><p name="516e" id="516e" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“2020–01–02T01:10:30.000Z”</p><p name="31ac" id="31ac" class="graf graf--p graf-after--p">there is also a static Date.parse() method that takes a string as its argument, attempts to parse it as a date and time, and returns a timestamp representing that date. <code class="markup--code markup--p-code">Date.parse()</code> is able to parse the same strings that the <code class="markup--code markup--p-code">Date()</code> constructor can and is guaranteed to be able to parse the output of<code class="markup--code markup--p-code"> toISOString(), toUTCString()</code>, and<code class="markup--code markup--p-code"> toString()</code>.</p><h3 name="7684" id="7684" class="graf graf--h3 graf-after--p">Error Classes</h3><p name="9742" id="9742" class="graf graf--p graf-after--h3">One good reason to use an Error object is that, when you create an Error, it captures the state of the JavaScript stack, and if the exception is uncaught, the stack trace will be displayed with the error message, which will help you debug the issue.</p><p name="f821" id="f821" class="graf graf--p graf-after--p">Error objects have two properties: <code class="markup--code markup--p-code">message</code> and <code class="markup--code markup--p-code">name</code>, and a<code class="markup--code markup--p-code"> toString()</code> method. Node and all modern browsers also define a <code class="markup--code markup--p-code">stack</code> property on Error objects.</p><p name="5b7f" id="5b7f" class="graf graf--p graf-after--p">Subclasses are <code class="markup--code markup--p-code">EvalError, RangeError, ReferenceError, SyntaxError, TypeError,</code> and <code class="markup--code markup--p-code">URIError</code>.</p><p name="c322" id="c322" class="graf graf--p graf-after--p">You should feel free to define your own Error subclasses that best encapsulate the error conditions of your own program.</p><pre name="3535" id="3535" class="graf graf--pre graf-after--p">class HTTPError extends Error {</pre><pre name="bc9c" id="bc9c" class="graf graf--pre graf-after--pre">constructor(status, statusText, url) {</pre><pre name="23e9" id="23e9" class="graf graf--pre graf-after--pre">super(`${status} ${statusText}: ${url}`);</pre><pre name="fd2d" id="fd2d" class="graf graf--pre graf-after--pre">this.status = status;</pre><pre name="a3e8" id="a3e8" class="graf graf--pre graf-after--pre">this.statusText = statusText;</pre><pre name="ff6c" id="ff6c" class="graf graf--pre graf-after--pre">this.url = url;</pre><pre name="67d0" id="67d0" class="graf graf--pre graf-after--pre">}</pre><pre name="993f" id="993f" class="graf graf--pre graf-after--pre">get name() { return &quot;HTTPError&quot;; }</pre><pre name="0b08" id="0b08" class="graf graf--pre graf-after--pre">}</pre><pre name="938a" id="938a" class="graf graf--pre graf-after--pre">let error = new HTTPError(404, &quot;Not Found&quot;, &quot;http://example.com/&quot;);</pre><pre name="c1c0" id="c1c0" class="graf graf--pre graf-after--pre">error.status</pre><p name="76c8" id="76c8" class="graf graf--p graf-after--pre">404</p><pre name="2e8d" id="2e8d" class="graf graf--pre graf-after--p">error.message</pre><p name="5bcc" id="5bcc" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“404 Not Found:<a href="http://example.com/" data-href="http://example.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">http://example.com/</a>&quot;</p><pre name="9eb3" id="9eb3" class="graf graf--pre graf-after--p">error.name</pre><p name="0ec4" id="0ec4" class="graf graf--p graf-after--pre">HTTPError</p><h3 name="6fd6" id="6fd6" class="graf graf--h3 graf-after--p">JSON Serialization and Parsing</h3><p name="12f4" id="12f4" class="graf graf--p graf-after--h3">JavaScript supports JSON serialization and deserialization with the two functions <code class="markup--code markup--p-code">JSON.stringify()</code> and <code class="markup--code markup--p-code">JSON.parse().</code></p><pre name="a6fc" id="a6fc" class="graf graf--pre graf-after--p">let o = {s: &quot;&quot;, n: 0, a: [true, false, null]};</pre><pre name="81a5" id="81a5" class="graf graf--pre graf-after--pre">let s = JSON.stringify(o);</pre><p name="d8cb" id="d8cb" class="graf graf--p graf-after--pre">s == ‘{“s”:””,”n”:0,”a”:[true,false,null]}’</p><pre name="40d7" id="40d7" class="graf graf--pre graf-after--p">let copy = JSON.parse(s);</pre><p name="3e98" id="3e98" class="graf graf--p graf-after--pre">copy == {s: “”, n: 0, a:[true, false, null]}</p><p name="503d" id="503d" class="graf graf--p graf-after--p">Inefficient way of creating a deep copy of an object</p><pre name="bdc8" id="bdc8" class="graf graf--pre graf-after--p">function deepcopy(o) {</pre><pre name="8e3f" id="8e3f" class="graf graf--pre graf-after--pre">return JSON.parse(JSON.stringify(o));</pre><pre name="cf40" id="cf40" class="graf graf--pre graf-after--pre">}</pre><p name="135d" id="135d" class="graf graf--p graf-after--pre">Typically, you pass only a single argument to <code class="markup--code markup--p-code">JSON.stringify()</code> and <code class="markup--code markup--p-code">JSON.parse()</code>. Both functions accept an optional second argument that allows us to extend the JSON format.</p><p name="8f61" id="8f61" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">JSON.stringify()</code> also takes an optional third argument. If you would like your JSONformatted string to be human-readable (if it is being used as a configuration file, for example), then you should pass null as the second argument and pass a number or string as the third argument. If the third argument is a number, then it will use that number of spaces for each indentation level. If the third argument is a string of whitespace (such as &#39;\t&#39;), it will use that string for each level of indent.</p><h3 name="dbc9" id="dbc9" class="graf graf--h3 graf-after--p">JSON Customizations</h3><p name="42a3" id="42a3" class="graf graf--p graf-after--h3">If <code class="markup--code markup--p-code">JSON.stringify()</code> is asked to serialize a value that is not natively supported by the JSON format, it looks to see if that value has a <code class="markup--code markup--p-code">toJSON()</code> method, and if so, it calls that method and then stringifies the return value in place of the original value. Date objects implement <code class="markup--code markup--p-code">toJSON()</code>: it returns the same string that <code class="markup--code markup--p-code">toISOString()</code> method does.</p><p name="76d4" id="76d4" class="graf graf--p graf-after--p">If you need to re-create Date objects (or modify the parsed object inany other way), you can pass a “reviver” function as the second argument to <code class="markup--code markup--p-code">JSON.parse()</code>.</p><pre name="15f8" id="15f8" class="graf graf--pre graf-after--p">let data = JSON.parse(text, function(key, value) {</pre><pre name="2588" id="2588" class="graf graf--pre graf-after--pre">if (key[0] === &quot;_&quot;) return undefined;</pre><pre name="ea7e" id="ea7e" class="graf graf--pre graf-after--pre">if (typeof value === &quot;string&quot; &amp;&amp; /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ$/.test(value)) {</pre><pre name="986c" id="986c" class="graf graf--pre graf-after--pre">return new Date(value);</pre><pre name="ac7a" id="ac7a" class="graf graf--pre graf-after--pre">}</pre><pre name="c568" id="c568" class="graf graf--pre graf-after--pre">return value;</pre><pre name="a050" id="a050" class="graf graf--pre graf-after--pre">});</pre><h3 name="619a" id="619a" class="graf graf--h3 graf-after--pre">The Console API</h3><p name="345d" id="345d" class="graf graf--p graf-after--h3">Console functions that print their arguments like console.log() have a little-known feature: if the first argument is a string that includes <code class="markup--code markup--p-code">%s, %i, %d, %f, %o, %O, or %c</code>, then this first argument is treated as format string, and the values of subsequent arguments are substituted into the string in place of the two-character % sequences.</p><h3 name="c9a6" id="c9a6" class="graf graf--h3 graf-after--p">URL API</h3><pre name="afc4" id="afc4" class="graf graf--pre graf-after--h3">let url = new URL(&quot;https://example.com:8000/path/name?q=term#fragment&quot;);</pre><pre name="29a5" id="29a5" class="graf graf--pre graf-after--pre">url.href</pre><p name="b285" id="b285" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre"><a href="https://example.com:8000/path/name" data-href="https://example.com:8000/path/name" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">“https://example.com:8000/path/name</a>?q=term#fragment&quot;</p><pre name="3c4e" id="3c4e" class="graf graf--pre graf-after--p">url.origin</pre><p name="b2f4" id="b2f4" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre"><a href="https://example.com:8000/" data-href="https://example.com:8000/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">“https://example.com:8000</a>&quot;</p><pre name="b726" id="b726" class="graf graf--pre graf-after--p">url.protocol</pre><p name="e69c" id="e69c" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“https:”</p><pre name="6f74" id="6f74" class="graf graf--pre graf-after--p">url.host</pre><p name="a559" id="a559" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre"><a href="http://example.com/" data-href="http://example.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">“example.com</a>:8000”</p><pre name="30fa" id="30fa" class="graf graf--pre graf-after--p">url.hostname</pre><p name="22e9" id="22e9" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre"><a href="http://example.com/" data-href="http://example.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">“example.com</a>”</p><pre name="8e76" id="8e76" class="graf graf--pre graf-after--p">url.port</pre><p name="a4c7" id="a4c7" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“8000”</p><pre name="d8de" id="d8de" class="graf graf--pre graf-after--p">url.pathname</pre><p name="96ac" id="96ac" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“/path/name”</p><pre name="9045" id="9045" class="graf graf--pre graf-after--p">url.search</pre><p name="7bbf" id="7bbf" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“?q=term”</p><pre name="0fe6" id="0fe6" class="graf graf--pre graf-after--p">url.hash</pre><p name="9aec" id="9aec" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“#fragment”</p><pre name="9eb2" id="9eb2" class="graf graf--pre graf-after--p">let url = new URL(&quot;https://example.com&quot;);</pre><pre name="fdde" id="fdde" class="graf graf--pre graf-after--pre">url.pathname = &quot;api/search&quot;;</pre><p name="299f" id="299f" class="graf graf--p graf-after--pre">Add a path to an API endpoint</p><pre name="6932" id="6932" class="graf graf--pre graf-after--p">url.search = &quot;q=test&quot;;</pre><p name="290e" id="290e" class="graf graf--p graf-after--pre">Add a query parameter</p><pre name="6628" id="6628" class="graf graf--pre graf-after--p">url.toString()</pre><p name="3eab" id="3eab" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre"><a href="https://example.com/api/search?q=test" data-href="https://example.com/api/search?q=test" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">“https://example.com/api/search?q=test</a>&quot;</p><p name="c5bc" id="c5bc" class="graf graf--p graf-after--p">One of the important features of the URL class is that it correctly adds punctuation and escapes special characters in URLs when that is needed</p><pre name="99e4" id="99e4" class="graf graf--pre graf-after--p">let url = new URL(&quot;https://example.com&quot;);</pre><pre name="4c61" id="4c61" class="graf graf--pre graf-after--pre">url.pathname = &quot;path with spaces&quot;;</pre><pre name="0046" id="0046" class="graf graf--pre graf-after--pre">url.pathname</pre><p name="717c" id="717c" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“/path%20with%20spaces”</p><pre name="d493" id="d493" class="graf graf--pre graf-after--p">url.search = &quot;q=foo#bar&quot;;</pre><pre name="16f9" id="16f9" class="graf graf--pre graf-after--pre">url.search</pre><p name="68c1" id="68c1" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">“?q=foo%23bar”</p><pre name="9ce6" id="9ce6" class="graf graf--pre graf-after--p">url.href</pre><p name="c3a3" id="c3a3" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre"><a href="https://example.com/path%20with%20spaces?q=foo%23bar" data-href="https://example.com/path%20with%20spaces?q=foo%23bar" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">“https://example.com/path%20with%20spaces?q=foo%23bar</a>&quot;</p><p name="8818" id="8818" class="graf graf--p graf-after--p">Often, however, HTTP requests encode the values of multiple form fields or multiple API parameters into the query portion of a URL. In this format, the query portion of the URL is a question mark followed by one or more name/value pairs, which are separated from one another by ampersands.</p><p name="46ba" id="46ba" class="graf graf--p graf-after--p">If you want to encode these kinds of name/value pairs into the query portion of a URL, then the searchParams property will be more useful than the search property.</p><p name="6b62" id="6b62" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let url = new URL(&quot;https://example.com/search&quot;);</code></p><p name="5326" id="5326" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">url.search</code></p><p name="10de" id="10de" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“”</p><p name="679d" id="679d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">url.searchParams.append(&quot;q&quot;, &quot;term&quot;);</code></p><p name="1173" id="1173" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">url.search</code></p><p name="c5c6" id="c5c6" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“?q=term”</p><p name="ccf2" id="ccf2" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">url.searchParams.set(&quot;q&quot;, &quot;x&quot;);</code></p><p name="dab4" id="dab4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">url.search</code></p><p name="6bf3" id="6bf3" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“?q=x”</p><p name="6edd" id="6edd" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">url.searchParams.append(&quot;opts&quot;, &quot;1&quot;);</code></p><p name="7a0c" id="7a0c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">url.search</code></p><p name="3f7d" id="3f7d" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“?q=x&amp;opts=1”</p><p name="85e4" id="85e4" class="graf graf--p graf-after--p">The value of the searchParams property is a URLSearchParams object.</p><p name="f671" id="f671" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let url = new URL(&quot;http://example.com&quot;);</code></p><p name="c2ce" id="c2ce" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let params = new URLSearchParams();</code></p><p name="b8d6" id="b8d6" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">params.append(&quot;q&quot;, &quot;term&quot;);</code></p><p name="8e7e" id="8e7e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">params.append(&quot;opts&quot;, &quot;exact&quot;);</code></p><p name="18bb" id="18bb" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">params.toString()</code></p><p name="5ea7" id="5ea7" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“q=term&amp;opts=exact”</p><p name="6ae7" id="6ae7" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">url.search = params;</code></p><p name="28fd" id="28fd" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">url.href</code></p><p name="b54c" id="b54c" class="graf graf--p graf--startsWithDoubleQuote graf-after--p"><a href="http://example.com/" data-href="http://example.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">“http://example.com/</a>?q=term&amp;opts=exact&quot;</p><h3 name="3033" id="3033" class="graf graf--h3 graf-after--p">Timers</h3><p name="0eaa" id="0eaa" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">setTimeout()</code> and<code class="markup--code markup--p-code"> setInterval()</code>—that allow programs to ask the browser to invoke a function after a specified amount of time has elapsed or to invoke the function repeatedly at a specified interval.</p><pre name="d6a0" id="d6a0" class="graf graf--pre graf-after--p">setTimeout(() =&gt; { console.log(&quot;Ready...&quot;); }, 1000);</pre><pre name="ffb8" id="ffb8" class="graf graf--pre graf-after--pre">setTimeout(() =&gt; { console.log(&quot;set...&quot;); }, 2000);</pre><pre name="f190" id="f190" class="graf graf--pre graf-after--pre">setTimeout(() =&gt; { console.log(&quot;go!&quot;); }, 3000);</pre><p name="4da6" id="4da6" class="graf graf--p graf-after--pre">If you want to invoke a function repeatedly, use <code class="markup--code markup--p-code">setInterval()</code></p><p name="85b0" id="85b0" class="graf graf--p graf-after--p">Both <code class="markup--code markup--p-code">setTimeout()</code> and <code class="markup--code markup--p-code">setInterval()</code> return a value. If you save this value in a variable, you can then use it later to cancel the execution of the function by passing it to <code class="markup--code markup--p-code">clearTimeout()</code> or <code class="markup--code markup--p-code">clearInterval()</code>.</p><pre name="1b25" id="1b25" class="graf graf--pre graf-after--p">let clock = setInterval(() =&gt; {</pre><pre name="64c9" id="64c9" class="graf graf--pre graf-after--pre">console.clear();</pre><pre name="bb86" id="bb86" class="graf graf--pre graf-after--pre">console.log(new Date().toLocaleTimeString());</pre><pre name="435e" id="435e" class="graf graf--pre graf-after--pre">}, 1000);</pre><pre name="6308" id="6308" class="graf graf--pre graf-after--pre">setTimeout(() =&gt; { clearInterval(clock); }, 10000);</pre><p name="81e6" id="81e6" class="graf graf--p graf-after--pre">After 10 seconds: stop the repeating code above</p><h3 name="5d42" id="5d42" class="graf graf--h3 graf-after--p">Iterators and Generators</h3><p name="6b8f" id="6b8f" class="graf graf--p graf-after--h3">The iterator method of an iterable object does not have a conventional name but uses the Symbol, Symbol.iterator as its name. So a simple for/of loop over an iterable object iterable could also be written the hard way, like this:</p><pre name="32fa" id="32fa" class="graf graf--pre graf-after--p">let iterable = [99];</pre><pre name="11f7" id="11f7" class="graf graf--pre graf-after--pre">let iterator = iterable[Symbol.iterator]();</pre><pre name="a7d7" id="a7d7" class="graf graf--pre graf-after--pre">for(let result = iterator.next(); !result.done; result =iterator.next()) {</pre><pre name="a507" id="a507" class="graf graf--pre graf-after--pre">console.log(result.value) // result.value == 99</pre><pre name="f614" id="f614" class="graf graf--pre graf-after--pre">}</pre><p name="2c72" id="2c72" class="graf graf--p graf-after--pre">When you want to iterate though a “partially used” iterator:</p><p name="7fbf" id="7fbf" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let list = [1,2,3,4,5];</code><br> <code class="markup--code markup--p-code">let iter = list[Symbol.iterator]();</code></p><p name="91be" id="91be" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let head = iter.next().value;</code></p><p name="6c47" id="6c47" class="graf graf--p graf-after--p">head == 1</p><p name="12c0" id="12c0" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let tail = [...iter];</code></p><p name="b04d" id="b04d" class="graf graf--p graf-after--p">tail == [2,3,4,5]</p><h3 name="770c" id="770c" class="graf graf--h3 graf-after--p">Implementing Iterable Objects</h3><p name="afad" id="afad" class="graf graf--p graf-after--h3">we will implement the Range class one more time, making it iterable without relying on a generator.</p><p name="4df8" id="4df8" class="graf graf--p graf-after--p">In order to make a class iterable, you must implement a method whose name is the Symbol <code class="markup--code markup--p-code">Symbol.iterator</code></p><pre name="bba2" id="bba2" class="graf graf--pre graf-after--p">class Range {</pre><pre name="0022" id="0022" class="graf graf--pre graf-after--pre">constructor (from, to) {</pre><pre name="0214" id="0214" class="graf graf--pre graf-after--pre">this.from = from;</pre><pre name="536f" id="536f" class="graf graf--pre graf-after--pre">this.to = to;</pre><pre name="b099" id="b099" class="graf graf--pre graf-after--pre">}</pre><pre name="880b" id="880b" class="graf graf--pre graf-after--pre">has(x) { return typeof x === &quot;number&quot; &amp;&amp; this.from &lt;= x &amp;&amp; x &lt;= this.to; }</pre><pre name="054d" id="054d" class="graf graf--pre graf-after--pre">toString() { return `{ x | ${this.from} ≤ x ≤ ${this.to}}`; }</pre><pre name="10af" id="10af" class="graf graf--pre graf-after--pre">[Symbol.iterator]() {</pre><pre name="95a2" id="95a2" class="graf graf--pre graf-after--pre">let next = Math.ceil(this.from);</pre><pre name="aeef" id="aeef" class="graf graf--pre graf-after--pre">let last = this.to;</pre><pre name="a7b8" id="a7b8" class="graf graf--pre graf-after--pre">return {</pre><pre name="fb76" id="fb76" class="graf graf--pre graf-after--pre">next() {</pre><pre name="5cac" id="5cac" class="graf graf--pre graf-after--pre">return (next &lt;= last) ? { value: next++ } : { done: true };</pre><pre name="201e" id="201e" class="graf graf--pre graf-after--pre">},</pre><pre name="0542" id="0542" class="graf graf--pre graf-after--pre">[Symbol.iterator]() { return this; }</pre><pre name="85ba" id="85ba" class="graf graf--pre graf-after--pre">};</pre><pre name="6c04" id="6c04" class="graf graf--pre graf-after--pre">}</pre><pre name="a3bd" id="a3bd" class="graf graf--pre graf-after--pre">}</pre><pre name="f18d" id="f18d" class="graf graf--pre graf-after--pre">for(let x of new Range(1,10)) console.log(x);</pre><p name="3f0d" id="3f0d" class="graf graf--p graf-after--pre">Logs numbers 1 to 10</p><pre name="aa05" id="aa05" class="graf graf--pre graf-after--p">[...new Range(-2,2)]</pre><p name="69e2" id="69e2" class="graf graf--p graf-after--pre">[-2, -1, 0,1, 2]</p><p name="2ed2" id="2ed2" class="graf graf--p graf-after--p">In addition to making your classes iterable, it can be quite useful to define functions that return iterable values.</p><p name="baf9" id="baf9" class="graf graf--p graf-after--p">Return an iterable object that iterates the result of applying <code class="markup--code markup--p-code">f()</code> to each value from the source iterable</p><pre name="46c2" id="46c2" class="graf graf--pre graf-after--p">function map(iterable, f) {</pre><pre name="34b7" id="34b7" class="graf graf--pre graf-after--pre">let iterator = iterable[Symbol.iterator]();</pre><pre name="92ed" id="92ed" class="graf graf--pre graf-after--pre">return {</pre><pre name="a674" id="a674" class="graf graf--pre graf-after--pre">[Symbol.iterator]() { return this; },</pre><pre name="e5b6" id="e5b6" class="graf graf--pre graf-after--pre">next() {</pre><pre name="2838" id="2838" class="graf graf--pre graf-after--pre">let v = iterator.next();</pre><pre name="b0d9" id="b0d9" class="graf graf--pre graf-after--pre">if (v.done) {</pre><pre name="6bce" id="6bce" class="graf graf--pre graf-after--pre">return v;</pre><pre name="54ce" id="54ce" class="graf graf--pre graf-after--pre">}</pre><pre name="4616" id="4616" class="graf graf--pre graf-after--pre">else {</pre><pre name="acf1" id="acf1" class="graf graf--pre graf-after--pre">return { value: f(v.value) };</pre><pre name="0484" id="0484" class="graf graf--pre graf-after--pre">}</pre><pre name="5b41" id="5b41" class="graf graf--pre graf-after--pre">}</pre><pre name="db6e" id="db6e" class="graf graf--pre graf-after--pre">};</pre><pre name="4719" id="4719" class="graf graf--pre graf-after--pre">}</pre><p name="54ca" id="54ca" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">[...map(new Range(1,4), x =&gt; x*x)]</code></p><p name="4427" id="4427" class="graf graf--p graf-after--p">[1, 4, 9, 16]</p><p name="d3d1" id="d3d1" class="graf graf--p graf-after--p">Return an iterable object that filters the specified iterable, iterating only those elements for which the predicate returns true</p><pre name="4ada" id="4ada" class="graf graf--pre graf-after--p">function filter(iterable, predicate) {</pre><pre name="4403" id="4403" class="graf graf--pre graf-after--pre">let iterator = iterable[Symbol.iterator]();</pre><pre name="336c" id="336c" class="graf graf--pre graf-after--pre">return {</pre><pre name="4ed5" id="4ed5" class="graf graf--pre graf-after--pre">[Symbol.iterator]() { return this; },</pre><pre name="144b" id="144b" class="graf graf--pre graf-after--pre">next() {</pre><pre name="072d" id="072d" class="graf graf--pre graf-after--pre">for(;;) {</pre><pre name="e4d4" id="e4d4" class="graf graf--pre graf-after--pre">let v = iterator.next();</pre><pre name="a42f" id="a42f" class="graf graf--pre graf-after--pre">if (v.done || predicate(v.value)) {</pre><pre name="727d" id="727d" class="graf graf--pre graf-after--pre">return v;</pre><pre name="153c" id="153c" class="graf graf--pre graf-after--pre">}</pre><pre name="a526" id="a526" class="graf graf--pre graf-after--pre">}</pre><pre name="7ef3" id="7ef3" class="graf graf--pre graf-after--pre">}</pre><pre name="33fb" id="33fb" class="graf graf--pre graf-after--pre">};</pre><pre name="047f" id="047f" class="graf graf--pre graf-after--pre">}</pre><p name="696f" id="696f" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">[...filter(new Range(1,10), x =&gt; x % 2 === 0)]</code></p><p name="e462" id="e462" class="graf graf--p graf-after--p">[2,4,6,8,10]</p><h3 name="d56d" id="d56d" class="graf graf--h3 graf-after--p">Generators</h3><p name="7d02" id="7d02" class="graf graf--p graf-after--h3">Particularly useful when the values to be iterated are not the elements of a data structure, but the result of a computation.</p><p name="7e03" id="7e03" class="graf graf--p graf-after--p">To create a generator, you must first define a generator function — defined with the keyword <code class="markup--code markup--p-code">function*</code> rather than <code class="markup--code markup--p-code">function</code></p><p name="008e" id="008e" class="graf graf--p graf-after--p">When you invoke a generator function, it does not actually execute the function body, but instead returns a generator object. This generator object is an iterator.</p><p name="7c4f" id="7c4f" class="graf graf--p graf-after--p">Calling its <code class="markup--code markup--p-code">next()</code> method causes the body of the generator function to run from the start (or whatever its current position is) until it reaches a <code class="markup--code markup--p-code">yield</code> statement.</p><p name="bff1" id="bff1" class="graf graf--p graf-after--p">The value of the <code class="markup--code markup--p-code">yield</code> statement becomes the value returned by the <code class="markup--code markup--p-code">next()</code> call on the iterator.</p><pre name="e523" id="e523" class="graf graf--pre graf-after--p">function* oneDigitPrimes() {</pre><pre name="f531" id="f531" class="graf graf--pre graf-after--pre">yield 2;</pre><pre name="03af" id="03af" class="graf graf--pre graf-after--pre">yield 3;</pre><pre name="3368" id="3368" class="graf graf--pre graf-after--pre">yield 5;</pre><pre name="4dfc" id="4dfc" class="graf graf--pre graf-after--pre">yield 7;</pre><pre name="cf72" id="cf72" class="graf graf--pre graf-after--pre">}</pre><pre name="b4f9" id="b4f9" class="graf graf--pre graf-after--pre">let primes = oneDigitPrimes();</pre><p name="2ea8" id="2ea8" class="graf graf--p graf-after--pre">we get a generator</p><pre name="2efe" id="2efe" class="graf graf--pre graf-after--p">primes.next().value</pre><p name="a464" id="a464" class="graf graf--p graf-after--pre">2</p><pre name="3395" id="3395" class="graf graf--pre graf-after--p">primes.next().value</pre><p name="39da" id="39da" class="graf graf--p graf-after--pre">3</p><pre name="9f7f" id="9f7f" class="graf graf--pre graf-after--p">primes.next().value</pre><p name="634a" id="634a" class="graf graf--p graf-after--pre">5</p><pre name="d3af" id="d3af" class="graf graf--pre graf-after--p">primes.next().value</pre><p name="9f77" id="9f77" class="graf graf--p graf-after--pre">7</p><pre name="576c" id="576c" class="graf graf--pre graf-after--p">primes.next().done</pre><p name="8dba" id="8dba" class="graf graf--p graf-after--pre">true</p><p name="60c8" id="60c8" class="graf graf--p graf-after--p">Generators have a <code class="markup--code markup--p-code">Symbol.iterator</code> method to make them iterable</p><p name="ce96" id="ce96" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">primes[Symbol.iterator]()</code></p><p name="461a" id="461a" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">[...oneDigitPrimes()]</code></p><p name="736b" id="736b" class="graf graf--p graf-after--p">[2,3,5,7]</p><pre name="4936" id="4936" class="graf graf--pre graf-after--p">let sum = 0;</pre><pre name="a71c" id="a71c" class="graf graf--pre graf-after--pre">for(let prime of oneDigitPrimes()) sum += prime;</pre><pre name="813d" id="813d" class="graf graf--pre graf-after--pre">sum</pre><p name="2b7f" id="2b7f" class="graf graf--p graf-after--pre">17</p><p name="88a5" id="88a5" class="graf graf--p graf-after--p">Like regular functions, however, we can also define generators in expression form.</p><pre name="9de0" id="9de0" class="graf graf--pre graf-after--p">const seq = function*(from,to) {</pre><pre name="8e38" id="8e38" class="graf graf--pre graf-after--pre">for(let i = from; i &lt;= to; i++) yield i;</pre><pre name="3875" id="3875" class="graf graf--pre graf-after--pre">};</pre><pre name="dbef" id="dbef" class="graf graf--pre graf-after--pre">[...seq(3,5)]</pre><p name="0c3e" id="0c3e" class="graf graf--p graf-after--pre">[3, 4, 5]</p><p name="ea53" id="ea53" class="graf graf--p graf-after--p">In classes and object literals, we can use shorthand notation to omit the function keyword entirely when we define methods.</p><pre name="6df5" id="6df5" class="graf graf--pre graf-after--p">let o = {</pre><pre name="c2f0" id="c2f0" class="graf graf--pre graf-after--pre">x: 1, y: 2, z: 3,</pre><pre name="6d4c" id="6d4c" class="graf graf--pre graf-after--pre">*g() {</pre><pre name="19f7" id="19f7" class="graf graf--pre graf-after--pre">for(let key of Object.keys(this)) {</pre><pre name="4a13" id="4a13" class="graf graf--pre graf-after--pre">yield key;</pre><pre name="d886" id="d886" class="graf graf--pre graf-after--pre">}</pre><pre name="9229" id="9229" class="graf graf--pre graf-after--pre">}</pre><pre name="2800" id="2800" class="graf graf--pre graf-after--pre">};</pre><p name="8d5a" id="8d5a" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">[...o.g()]</code></p><p name="6e0b" id="6e0b" class="graf graf--p graf-after--p">[“x”, “y”, “z”, “g”]</p><p name="9a52" id="9a52" class="graf graf--p graf-after--p">Generators often make it particularly easy to define iterable classes.</p><pre name="fda4" id="fda4" class="graf graf--pre graf-after--p">*[Symbol.iterator]() {</pre><pre name="dda8" id="dda8" class="graf graf--pre graf-after--pre">for(let x = Math.ceil(this.from); x &lt;= this.to; x++)</pre><pre name="5355" id="5355" class="graf graf--pre graf-after--pre">yield x;</pre><pre name="e816" id="e816" class="graf graf--pre graf-after--pre">}</pre><h3 name="7abd" id="7abd" class="graf graf--h3 graf-after--pre">Generator Examples</h3><p name="0e83" id="0e83" class="graf graf--p graf-after--h3">Generators are more interesting if they actually generate the values they yield by doing some kind of computation.</p><p name="9fc5" id="9fc5" class="graf graf--p graf-after--p">generator function that yields Fibonacci numbers</p><pre name="373b" id="373b" class="graf graf--pre graf-after--p">function* fibonacciSequence() {</pre><pre name="7819" id="7819" class="graf graf--pre graf-after--pre">let x = 0, y = 1;</pre><pre name="df25" id="df25" class="graf graf--pre graf-after--pre">for(;;) {</pre><pre name="824a" id="824a" class="graf graf--pre graf-after--pre">yield y;</pre><pre name="8994" id="8994" class="graf graf--pre graf-after--pre">[x, y] = [y, x+y];</pre><pre name="f409" id="f409" class="graf graf--pre graf-after--pre">}</pre><pre name="b1b4" id="b1b4" class="graf graf--pre graf-after--pre">}</pre><p name="79da" id="79da" class="graf graf--p graf-after--pre">If this generator is used with the … spread operator, it will loop until memory is exhausted and the program crashes.</p><p name="1049" id="1049" class="graf graf--p graf-after--p">Use it in a <code class="markup--code markup--p-code">for/of</code> loop, however</p><pre name="7eb7" id="7eb7" class="graf graf--pre graf-after--p">function fibonacci(n) {</pre><pre name="220f" id="220f" class="graf graf--pre graf-after--pre">for(let f of fibonacciSequence()) {</pre><pre name="0ec6" id="0ec6" class="graf graf--pre graf-after--pre">if (n-- &lt;= 0) return f;</pre><pre name="50ab" id="50ab" class="graf graf--pre graf-after--pre">}</pre><pre name="4d97" id="4d97" class="graf graf--pre graf-after--pre">}</pre><pre name="6b10" id="6b10" class="graf graf--pre graf-after--pre">fibonacci(20)</pre><p name="efff" id="efff" class="graf graf--p graf-after--pre">10946</p><p name="cd1f" id="cd1f" class="graf graf--p graf-after--p">This kind of infinite generator becomes more useful with a <code class="markup--code markup--p-code">take()</code> generator like this</p><pre name="569c" id="569c" class="graf graf--pre graf-after--p">function* take(n, iterable) {</pre><pre name="ae34" id="ae34" class="graf graf--pre graf-after--pre">let it = iterable[Symbol.iterator]();</pre><pre name="6495" id="6495" class="graf graf--pre graf-after--pre">while(n-- &gt; 0) {</pre><pre name="3677" id="3677" class="graf graf--pre graf-after--pre">let next = it.next();</pre><pre name="4b4a" id="4b4a" class="graf graf--pre graf-after--pre">if (next.done) return;</pre><pre name="b512" id="b512" class="graf graf--pre graf-after--pre">else yield next.value;</pre><pre name="97ed" id="97ed" class="graf graf--pre graf-after--pre">}</pre><pre name="5762" id="5762" class="graf graf--pre graf-after--pre">}</pre><pre name="87bf" id="87bf" class="graf graf--pre graf-after--pre">[...take(5, fibonacciSequence())]</pre><p name="62ae" id="62ae" class="graf graf--p graf-after--pre">[1, 1, 2, 3, 5]</p><h3 name="703d" id="703d" class="graf graf--h3 graf-after--p">Asynchronous Javascript</h3><p name="191e" id="191e" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">Promises</code>, new in ES6, are objects that represent the not-yet-available result of an asynchronous operation.</p><p name="53ec" id="53ec" class="graf graf--p graf-after--p">The keywords <code class="markup--code markup--p-code">async</code> and <code class="markup--code markup--p-code">await</code> were introduced in ES2017 and provide new syntax that simplifies asynchronous programming by allowing you to structure your Promise based code as if it was synchronous.</p><p name="b27e" id="b27e" class="graf graf--p graf-after--p">Asynchronous iterators and the<code class="markup--code markup--p-code"> for/await</code> loop were introduced in ES2018 and allow you to work with streams of asynchronous events using simple loops that appear synchronous.</p><h3 name="53ed" id="53ed" class="graf graf--h3 graf-after--p">Asynchronous Programming with Callbacks</h3><h3 name="3f8c" id="3f8c" class="graf graf--h3 graf-after--h3">Timers</h3><p name="2f3e" id="2f3e" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">setTimeout(checkForUpdates, 60000);</code></p><pre name="a7a6" id="a7a6" class="graf graf--pre graf-after--p">let updateIntervalId = setInterval(checkForUpdates, 60000);</pre><pre name="73a8" id="73a8" class="graf graf--pre graf-after--pre">function stopCheckingForUpdates() {</pre><pre name="1f94" id="1f94" class="graf graf--pre graf-after--pre">clearInterval(updateIntervalId);</pre><pre name="5ca0" id="5ca0" class="graf graf--pre graf-after--pre">}</pre><h3 name="4bd3" id="4bd3" class="graf graf--h3 graf-after--pre">Events</h3><p name="56ba" id="56ba" class="graf graf--p graf-after--h3">Event-driven JavaScript programs register callback functions for specified types of events in specified contexts, and the web browser invokes those functions whenever the specified events occur.</p><p name="1b22" id="1b22" class="graf graf--p graf-after--p">These callback functions are called event handlers or event listeners, and they are registered with <code class="markup--code markup--p-code">addEventListener()</code></p><p name="d2ca" id="d2ca" class="graf graf--p graf-after--p">Ask the web browser to return an object representing the HTML &lt;button&gt; element that matches this CSS selector:</p><p name="cb33" id="cb33" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">let okay = document.querySelector(&#39;#confirmUpdateDialogbutton.okay&#39;);</code></p><p name="cbf4" id="cbf4" class="graf graf--p graf-after--p">Now register a callback function to be invoked when the user clicks on that button</p><p name="9e58" id="9e58" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">okay.addEventListener(&#39;click&#39;, applyUpdate);</code></p><h3 name="5cb8" id="5cb8" class="graf graf--h3 graf-after--p">Network Events</h3><p name="fbd8" id="fbd8" class="graf graf--p graf-after--h3">JavaScript running in the browser can fetch data from a web server with code like this:</p><pre name="e07c" id="e07c" class="graf graf--pre graf-after--p">function getCurrentVersionNumber(versionCallback) {</pre><pre name="bf59" id="bf59" class="graf graf--pre graf-after--pre">let request = new XMLHttpRequest();</pre><pre name="3cb3" id="3cb3" class="graf graf--pre graf-after--pre">request.open(&quot;GET&quot;, &quot;http://www.example.com/api/version&quot;);</pre><pre name="c9c2" id="c9c2" class="graf graf--pre graf-after--pre">request.send();</pre><pre name="66a6" id="66a6" class="graf graf--pre graf-after--pre">request.onload = function() {</pre><pre name="0ff9" id="0ff9" class="graf graf--pre graf-after--pre">if (request.status === 200) {</pre><pre name="5643" id="5643" class="graf graf--pre graf-after--pre">let currentVersion = parseFloat(request.responseText);</pre><pre name="19c1" id="19c1" class="graf graf--pre graf-after--pre">versionCallback(null, currentVersion);</pre><pre name="016f" id="016f" class="graf graf--pre graf-after--pre">}</pre><pre name="b57a" id="b57a" class="graf graf--pre graf-after--pre">else {</pre><pre name="27fe" id="27fe" class="graf graf--pre graf-after--pre">versionCallback(response.statusText, null);</pre><pre name="80db" id="80db" class="graf graf--pre graf-after--pre">}</pre><pre name="0562" id="0562" class="graf graf--pre graf-after--pre">};</pre><pre name="ba9f" id="ba9f" class="graf graf--pre graf-after--pre">request.onerror = request.ontimeout = function(e) {</pre><pre name="964d" id="964d" class="graf graf--pre graf-after--pre">versionCallback(e.type, null);</pre><pre name="b7dc" id="b7dc" class="graf graf--pre graf-after--pre">};</pre><pre name="8c7b" id="8c7b" class="graf graf--pre graf-after--pre">}</pre><h3 name="efbc" id="efbc" class="graf graf--h3 graf-after--pre">Promises</h3><p name="ee75" id="ee75" class="graf graf--p graf-after--h3">Promises, a core language feature designed to simplify asynchronous programming.</p><p name="21c8" id="21c8" class="graf graf--p graf-after--p">A Promise is an object that represents the result of an asynchronous computation. That result may or may not be ready yet, and the Promise API is intentionally vague about this: there is no way to synchronously get the value of a Promise; you can only ask the Promise to call a callback function when the value is ready.</p><p name="94f0" id="94f0" class="graf graf--p graf-after--p">One real problem with callback-based asynchronous programming is that it is common to end up with callbacks inside callbacks inside callbacks, with lines of code so highly indented that it is difficult to read.</p><p name="4e93" id="4e93" class="graf graf--p graf-after--p">Promises allow this kind of nested callback to be re-expressed as a more linear Promise chain that tends to be easier to read and easier to reason about.</p><p name="b616" id="b616" class="graf graf--p graf-after--p">Another problem with callbacks is that they can make handling errors difficult. If an asynchronous function (or an asynchronously invoked callback) throws an exception, there is no way for that exception to propagate back to the initiator of the asynchronous operation. This is a fundamental fact about asynchronous programming: it breaks exception handling. Promises help here by standardizing a way to handle errors and providing a way for errors to propagate correctly through a chain of promises.</p><p name="5e37" id="5e37" class="graf graf--p graf-after--p">Note that Promises represent the future results of single asynchronous computations. They cannot be used to represent repeated asynchronous computations, however.</p><p name="3e64" id="3e64" class="graf graf--p graf-after--p">We can’t use Promises to replace <code class="markup--code markup--p-code">setInterval()</code> because that function invokes a callback function repeatedly, which is something that Promises are just not designed to do.</p><h3 name="55ce" id="55ce" class="graf graf--h3 graf-after--p">Using Promises</h3><p name="b466" id="b466" class="graf graf--p graf-after--h3">How we would use this Promise returning utility function</p><pre name="7efc" id="7efc" class="graf graf--pre graf-after--p">getJSON(url).then(jsonData =&gt; {</pre><pre name="1c14" id="1c14" class="graf graf--pre graf-after--pre">// callback function that will be asynchronously invoked with the parsed JSON value when it becomes available.</pre><pre name="ac13" id="ac13" class="graf graf--pre graf-after--pre">});</pre><p name="a64f" id="a64f" class="graf graf--p graf-after--pre">The Promise object defines a then() instance method. Instead of passing our callback function directly to <code class="markup--code markup--p-code">getJSON()</code>, we instead pass it to the then() method. When the HTTP response arrives, the body of that response is parsed as JSON, and the resulting parsed value is passed to the function that we passed to <code class="markup--code markup--p-code">then()</code>.</p><p name="4423" id="4423" class="graf graf--p graf-after--p">If you call the <code class="markup--code markup--p-code">then()</code> method of a Promise object multiple times, each of the functions you specify will be called when the promised computation is complete.</p><p name="9d19" id="9d19" class="graf graf--p graf-after--p">Unlike many event listeners, though, a Promise represents a single computation, and each function registered with then() will be invoked only once.</p><pre name="8e63" id="8e63" class="graf graf--pre graf-after--p">function displayUserProfile(profile) { ...}</pre><pre name="c325" id="c325" class="graf graf--pre graf-after--pre">getJSON(&quot;/api/user/profile&quot;).then(displayUserProfile);</pre><h3 name="92c3" id="92c3" class="graf graf--h3 graf-after--pre">HANDLING ERRORS WITH PROMISES</h3><p name="7e91" id="7e91" class="graf graf--p graf-after--h3">Asynchronous operations, particularly those that involve networking, can typically fail in a number of ways, and robust code has to be written to handle the errors that will inevitably occur.</p><p name="54c7" id="54c7" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">getJSON(&quot;/api/user/profile&quot;).then(displayUserProfile, handleProfileError);</code></p><p name="33c1" id="33c1" class="graf graf--p graf-after--p">if <code class="markup--code markup--p-code">getJSON()</code> runs normally, it passes its result to <code class="markup--code markup--p-code">displayUserProfile()</code>. If there is an error (the user is not logged in, the server is down, the user’s internet connection dropped, the request timed out, etc.), then <code class="markup--code markup--p-code">getJSON()</code> passes an Error object to <code class="markup--code markup--p-code">handleProfileError()</code>.</p><p name="5f02" id="5f02" class="graf graf--p graf-after--p">In practice, it is rare to see two functions passed to then(). There is a better and more idiomatic way of handling errors when working with Promises.</p><p name="4055" id="4055" class="graf graf--p graf-after--p">To understand it, first consider what happens if <code class="markup--code markup--p-code">getJSON()</code> completes normally but an error occurs in <code class="markup--code markup--p-code">displayUserProfile()</code>. That callback function is invoked asynchronously when <code class="markup--code markup--p-code">getJSON()</code> returns, so it is also asynchronous and cannot meaningfully throw an exception (because there is no code on the call stack to handle it).</p><pre name="26fd" id="26fd" class="graf graf--pre graf-after--p">getJSON(&quot;/api/user/profile&quot;).then(displayUserProfile).catch(handleProfileError);</pre><p name="e1ee" id="e1ee" class="graf graf--p graf-after--pre">With this code, a normal result from<code class="markup--code markup--p-code"> getJSON()</code> is still passed to <code class="markup--code markup--p-code">displayUserProfile()</code>, but any error in <code class="markup--code markup--p-code">getJSON()</code> or in <code class="markup--code markup--p-code">displayUserProfile()</code> (including any exceptions thrown by <code class="markup--code markup--p-code">displayUserProfile</code>) get passed to <code class="markup--code markup--p-code">handleProfileError()</code>.</p><h3 name="d268" id="d268" class="graf graf--h3 graf-after--p">Chaining Promises</h3><p name="21c0" id="21c0" class="graf graf--p graf-after--h3">One of the most important benefits of Promises is that they provide a natural way to express a sequence of asynchronous operations as a linear chain of <code class="markup--code markup--p-code">then()</code> method invocations, without having to nest each operation within the callback of the previous one.</p><pre name="193e" id="193e" class="graf graf--pre graf-after--p">fetch(documentURL)</pre><pre name="2a33" id="2a33" class="graf graf--pre graf-after--pre">.then(response =&gt; response.json())</pre><pre name="2c3b" id="2c3b" class="graf graf--pre graf-after--pre">.then(document =&gt; {return render(document); })</pre><pre name="25c8" id="25c8" class="graf graf--pre graf-after--pre">.then(rendered =&gt; {cacheInDatabase(rendered); })</pre><pre name="6318" id="6318" class="graf graf--pre graf-after--pre">.catch(error =&gt; handle(error));</pre><p name="65ad" id="65ad" class="graf graf--p graf-after--pre">has largely been replaced by the newer, Promise-based Fetch API. In its simplest form, this new HTTP API is just the function fetch(). That promise is fulfilled when the HTTP response begins to arrive and the HTTP status and headers are available.</p><pre name="80bc" id="80bc" class="graf graf--pre graf-after--p">fetch(&quot;/api/user/profile&quot;)</pre><pre name="524d" id="524d" class="graf graf--pre graf-after--pre">.then(response =&gt; {</pre><pre name="dc31" id="dc31" class="graf graf--pre graf-after--pre">if (response.ok &amp;&amp;  response.headers.get(&quot;Content-Type&quot;) === &quot;application/json&quot;) {</pre><pre name="33c5" id="33c5" class="graf graf--pre graf-after--pre">// What can we do here? We don&#39;t actually have the response body yet.</pre><pre name="f623" id="f623" class="graf graf--pre graf-after--pre">}</pre><pre name="fb98" id="fb98" class="graf graf--pre graf-after--pre">});</pre><p name="9802" id="9802" class="graf graf--p graf-after--pre">But although the initial Promise is fulfilled, the body of the response may not yet have arrived. So these <code class="markup--code markup--p-code">text()</code> and<code class="markup--code markup--p-code"> json()</code> methods for accessing the body of the response themselves return Promises.</p><pre name="dbe3" id="dbe3" class="graf graf--pre graf-after--p">fetch(&quot;/api/user/profile&quot;)</pre><pre name="3be2" id="3be2" class="graf graf--pre graf-after--pre">.then(response =&gt; {</pre><pre name="0091" id="0091" class="graf graf--pre graf-after--pre">return response.json();</pre><pre name="d801" id="d801" class="graf graf--pre graf-after--pre">})</pre><pre name="f72a" id="f72a" class="graf graf--pre graf-after--pre">.then(profile =&gt; {</pre><pre name="dfab" id="dfab" class="graf graf--pre graf-after--pre">displayUserProfile(profile);</pre><pre name="498c" id="498c" class="graf graf--pre graf-after--pre">});</pre><p name="9c61" id="9c61" class="graf graf--p graf-after--pre">There is a second <code class="markup--code markup--p-code">then()</code> in the chain, which means that the first invocation of the <code class="markup--code markup--p-code">then()</code> method must itself return a Promise. That is not how Promises work, however.</p><p name="f2b1" id="f2b1" class="graf graf--p graf-after--p">When we write a chain of <code class="markup--code markup--p-code">.then()</code> invocations, we are not registering multiple callbacks on a single Promise object. Instead, each invocation of the <code class="markup--code markup--p-code">then()</code> method returns a new Promise object. That new Promise object is not fulfilled until the function passed to <code class="markup--code markup--p-code">then()</code> is complete.</p><pre name="0299" id="0299" class="graf graf--pre graf-after--p">fetch(theURL)       // task 1; returns promise 1</pre><pre name="6d49" id="6d49" class="graf graf--pre graf-after--pre">.then(callback1)  // task 2; returns promise 2</pre><pre name="11fc" id="11fc" class="graf graf--pre graf-after--pre">.then(callback2); // task 3; returns promise 3</pre><h3 name="fb18" id="fb18" class="graf graf--h3 graf-after--pre">Resolving Promises</h3><p name="66f3" id="66f3" class="graf graf--p graf-after--h3">There is actually a fourth Promise object involved as which brings up the point of what it means for a Promise to be “resolved.”</p><p name="89c3" id="89c3" class="graf graf--p graf-after--p">fetch() returns a Promise object which, when fulfilled, passes a Response object to the callback function we register. This Response object has <code class="markup--code markup--p-code">.text(), .json(),</code> and other methods to request the body of the HTTP response in various forms. But since the body may not yet have arrived, these methods must return Promise objects.</p><p name="11a7" id="11a7" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“task 2” calls the <code class="markup--code markup--p-code">.json()</code> method and returns its value. This is the fourth Promise object, and it is the return value of the <code class="markup--code markup--p-code">callback1()</code> function.</p><p name="67f6" id="67f6" class="graf graf--p graf-after--p">Let’s consider:</p><pre name="2a7f" id="2a7f" class="graf graf--pre graf-after--p">function c1(response) {</pre><pre name="f5f0" id="f5f0" class="graf graf--pre graf-after--pre">let p4 = response.json();</pre><pre name="658b" id="658b" class="graf graf--pre graf-after--pre">return p4;</pre><pre name="e1c0" id="e1c0" class="graf graf--pre graf-after--pre">}</pre><pre name="3f76" id="3f76" class="graf graf--pre graf-after--pre">// callback 1</pre><pre name="113b" id="113b" class="graf graf--pre graf-after--pre">// returns promise 4</pre><pre name="7950" id="7950" class="graf graf--pre graf-after--pre">function c2(profile) {</pre><pre name="8f6c" id="8f6c" class="graf graf--pre graf-after--pre">displayUserProfile(profile);</pre><pre name="d756" id="d756" class="graf graf--pre graf-after--pre">}</pre><pre name="9ed6" id="9ed6" class="graf graf--pre graf-after--pre">// callback 2</pre><pre name="2f3d" id="2f3d" class="graf graf--pre graf-after--pre">let p1 = fetch(&quot;/api/user/profile&quot;);</pre><pre name="62e5" id="62e5" class="graf graf--pre graf-after--pre">promise 1, task 1</pre><pre name="0338" id="0338" class="graf graf--pre graf-after--pre">let p2 = p1.then(c1);</pre><pre name="633e" id="633e" class="graf graf--pre graf-after--pre">promise 2, task 2</pre><pre name="470b" id="470b" class="graf graf--pre graf-after--pre">let p3 = p2.then(c2);</pre><pre name="308c" id="308c" class="graf graf--pre graf-after--pre">promise 3, task 3</pre><p name="47bb" id="47bb" class="graf graf--p graf-after--pre">In order for Promise chains to work usefully, the output of task 2 must become the input to task 3. The input to task 3 is the body of the URL that was fetched, parsed as a JSON object. But the return value of callback c1 is not a JSON object, but Promise p4 for that JSON object.</p><p name="da46" id="da46" class="graf graf--p graf-after--p">When p1 is fulfilled, c1 is invoked, and task 2 begins. And when p2 is fulfilled, c2 is invoked, and task 3 begins.</p><p name="761d" id="761d" class="graf graf--p graf-after--p">And when p2 is fulfilled, c2 is invoked, and task 3 begins. But just because task 2 begins when c1 is invoked,it does not mean that task 2 must end when c1 returns.</p><p name="dd20" id="dd20" class="graf graf--p graf-after--p">Promises are about managing asynchronous tasks, and if task 2 is asynchronous, then that task will not be complete by the time the callback returns.</p><p name="c8fb" id="c8fb" class="graf graf--p graf-after--p">When you pass a callback c to the <code class="markup--code markup--p-code">then()</code> method, <code class="markup--code markup--p-code">then()</code> returns a Promise p and arranges to asynchronously invoke c at some later time. The callback performs some computation and returns a value v. When the callback returns, p is resolved with the value v. When a Promise is resolved with a value that is not itself a Promise, it is immediately fulfilled with that value.</p><p name="3a21" id="3a21" class="graf graf--p graf-after--p">So if c returns a non-Promise, that return value becomes the value of p, p is fulfilled and we are done. But if the return value v is itself a Promise, then p is resolved but not yet fulfilled.</p><p name="0574" id="0574" class="graf graf--p graf-after--p">At this stage, p cannot settle until the Promise v settles. If v is fulfilled, then p will be fulfilled to the same value. If v is rejected, then p will be rejected for the same reason. This is what the “resolved” state of a Promise means</p><p name="7df1" id="7df1" class="graf graf--p graf-after--p">the Promise has become associated with, or “locked onto,” another Promise. We don’t know yet whether p will be fulfilled or rejected, but our callback c no longer has any control over that. p is “resolved” in the sense that its fate now depends entirely on what happens to Promise v.</p><p name="9c1c" id="9c1c" class="graf graf--p graf-after--p">Let’s bring this back to our URL-fetching example. When c1 returns p4, p2 is resolved. But being resolved is not the same as being fulfilled, so task 3 does not begin yet. When the full body of the HTTP response becomes available, then the .<code class="markup--code markup--p-code">json()</code> method can parse it and use that parsed value to fulfill p4. When p4 is fulfilled, p2 is automatically fulfilled as well, with the same parsed JSON value. At this point, the parsed JSON object is passed to c2, and task 3 begins.</p><h3 name="e698" id="e698" class="graf graf--h3 graf-after--p">More on Promises and Errors</h3><p name="06da" id="06da" class="graf graf--p graf-after--h3">With synchronous code, if you leave out error-handling code, you’ll at least get an exception and a stack trace that you can use to figure out what is going wrong. With asynchronous code, unhandled exceptions will often go unreported, and errors can occur silently, making them much harder to debug. The good news is that the <code class="markup--code markup--p-code">.catch()</code> method makes it easy to handle errors when working with Promises.</p><p name="86fb" id="86fb" class="graf graf--p graf-after--p">THE CATCH AND FINALLY METHODS</p><p name="dcd9" id="dcd9" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">.catch()</code> method of a Promise is simply a shorthand way to call <code class="markup--code markup--p-code">.then()</code> with null as the first argument and an error-handling callback as the second argument.</p><p name="a9ab" id="a9ab" class="graf graf--p graf-after--p">Normal exceptions don’t work with asynchronous code. The <code class="markup--code markup--p-code">.catch()</code> method of Promises is an alternative that does work for asynchronous code.</p><pre name="1ac5" id="1ac5" class="graf graf--pre graf-after--p">fetch(&quot;/api/user/profile&quot;)</pre><pre name="c4bc" id="c4bc" class="graf graf--pre graf-after--pre">.then(response =&gt; {</pre><pre name="8b1b" id="8b1b" class="graf graf--pre graf-after--pre">if (!response.ok) {</pre><pre name="2651" id="2651" class="graf graf--pre graf-after--pre">return null;</pre><pre name="04ac" id="04ac" class="graf graf--pre graf-after--pre">}</pre><pre name="1e2b" id="1e2b" class="graf graf--pre graf-after--pre">let type = response.headers.get(&quot;content-type&quot;);</pre><pre name="d1fa" id="d1fa" class="graf graf--pre graf-after--pre">if (type !== &quot;application/json&quot;) {</pre><pre name="5ad5" id="5ad5" class="graf graf--pre graf-after--pre">throw new TypeError(`Expected JSON, got ${type}`);</pre><pre name="7abe" id="7abe" class="graf graf--pre graf-after--pre">}</pre><pre name="2720" id="2720" class="graf graf--pre graf-after--pre">return response.json();</pre><pre name="12ee" id="12ee" class="graf graf--pre graf-after--pre">})</pre><pre name="fcd4" id="fcd4" class="graf graf--pre graf-after--pre">.then(profile =&gt; {</pre><pre name="8faf" id="8faf" class="graf graf--pre graf-after--pre">if (profile) {</pre><pre name="c0f1" id="c0f1" class="graf graf--pre graf-after--pre">displayUserProfile(profile);</pre><pre name="5202" id="5202" class="graf graf--pre graf-after--pre">}</pre><pre name="f880" id="f880" class="graf graf--pre graf-after--pre">else {</pre><pre name="00ad" id="00ad" class="graf graf--pre graf-after--pre">displayLoggedOutProfilePage();</pre><pre name="3a96" id="3a96" class="graf graf--pre graf-after--pre">}</pre><pre name="5742" id="5742" class="graf graf--pre graf-after--pre">})</pre><pre name="fc19" id="fc19" class="graf graf--pre graf-after--pre">.catch(e =&gt; {</pre><pre name="aaee" id="aaee" class="graf graf--pre graf-after--pre">if (e instanceof NetworkError) {</pre><pre name="f01e" id="f01e" class="graf graf--pre graf-after--pre">displayErrorMessage(&quot;Check your internet connection.&quot;);</pre><pre name="5954" id="5954" class="graf graf--pre graf-after--pre">}</pre><pre name="6444" id="6444" class="graf graf--pre graf-after--pre">else if (e instanceof TypeError) {</pre><pre name="0f27" id="0f27" class="graf graf--pre graf-after--pre">displayErrorMessage(&quot;Something is wrong with our server!&quot;);</pre><pre name="abfc" id="abfc" class="graf graf--pre graf-after--pre">}</pre><pre name="496f" id="496f" class="graf graf--pre graf-after--pre">else {</pre><pre name="cd9a" id="cd9a" class="graf graf--pre graf-after--pre">console.error(e);</pre><pre name="f2e2" id="f2e2" class="graf graf--pre graf-after--pre">}</pre><pre name="0443" id="0443" class="graf graf--pre graf-after--pre">});</pre><p name="eed9" id="eed9" class="graf graf--p graf-after--pre">p1 is the Promise returned by the <code class="markup--code markup--p-code">fetch()</code> call</p><p name="fb74" id="fb74" class="graf graf--p graf-after--p">p2 is the Promise returned by the first <code class="markup--code markup--p-code">.then()</code> call</p><p name="adc8" id="adc8" class="graf graf--p graf-after--p">c1 is the callback that we pass to that .<code class="markup--code markup--p-code">then()</code> call</p><p name="f940" id="f940" class="graf graf--p graf-after--p">p3 is the Promise returned by the second <code class="markup--code markup--p-code">.then()</code> call</p><p name="b01f" id="b01f" class="graf graf--p graf-after--p">c2 is the callback we pass to that call</p><p name="a5da" id="a5da" class="graf graf--p graf-after--p">c3 is the callback that we pass to the <code class="markup--code markup--p-code">.catch()</code> call</p><p name="d78f" id="d78f" class="graf graf--p graf-after--p">The first thing that could fail is the fetch() request itself. Let’s say p1 was rejected with a NetworkError object.</p><p name="fc0b" id="fc0b" class="graf graf--p graf-after--p">We didn’t pass an error-handling callback function as the second argument to the <code class="markup--code markup--p-code">.then()</code> call, so p2 rejects as well with the same NetworkError object.</p><p name="69b5" id="69b5" class="graf graf--p graf-after--p">Without a handler, though, p2 is rejected, and then p3 is rejected for the same reason.</p><p name="57aa" id="57aa" class="graf graf--p graf-after--p">At this point, the c3 error-handling callback is called, and the NetworkError-specific code within it runs.</p><p name="2a2e" id="2a2e" class="graf graf--p graf-after--p">There are a couple of things worth noting about this code. First, notice that the error object thrown with a regular, synchronous throw statement ends up being handled asynchronously with a <code class="markup--code markup--p-code">.catch()</code> method invocation in a Promise chain. This should make it clear why this shorthand method is preferred over passing a second argument to .<code class="markup--code markup--p-code">then()</code>, and also why it is so idiomatic to end Promise chains with a <code class="markup--code markup--p-code">.catch()</code> call.</p><p name="9e26" id="9e26" class="graf graf--p graf-after--p">it is also perfectly valid to use <code class="markup--code markup--p-code">.catch()</code> elsewhere in a Promise chain. If one of the stages in your Promise chain can fail with an error, and if the error is some kind of recoverable error that should not stop the rest of the chain from running, then you can insert a <code class="markup--code markup--p-code">.catch()</code> call in the chain, resulting in code that might look like this:</p><pre name="f770" id="f770" class="graf graf--pre graf-after--p">startAsyncOperation()</pre><pre name="db14" id="db14" class="graf graf--pre graf-after--pre">.then(doStageTwo)</pre><pre name="0050" id="0050" class="graf graf--pre graf-after--pre">.catch(recoverFromStageTwoError)</pre><pre name="62b6" id="62b6" class="graf graf--pre graf-after--pre">.then(doStageThree)</pre><pre name="9f53" id="9f53" class="graf graf--pre graf-after--pre">.then(doStageFour)</pre><pre name="7ff4" id="7ff4" class="graf graf--pre graf-after--pre">.catch(logStageThreeAndFourErrors);</pre><p name="1b14" id="1b14" class="graf graf--p graf-after--pre">If the callback returns normally, then the <code class="markup--code markup--p-code">.catch()</code> callback will be skipped, and the return value of the previous callback will become the input to the next .<code class="markup--code markup--p-code">then()</code> callback.</p><p name="fc1d" id="fc1d" class="graf graf--p graf-after--p">Once an error has been passed to a <code class="markup--code markup--p-code">.catch()</code> callback, it stops propagating down the Promise chain. A <code class="markup--code markup--p-code">.catch()</code> callback can throw a new error, but if it returns normally, than that return value is used to resolve and/or fulfill the associated Promise, and<br> the error stops propagating.</p><p name="fbf6" id="fbf6" class="graf graf--p graf-after--p">Sometimes, in complex network environments, errors can occur more or less at random, and it can be appropriate to handle those errors by simply retrying the asynchronous request.</p><pre name="9275" id="9275" class="graf graf--pre graf-after--p">queryDatabase()</pre><pre name="9a54" id="9a54" class="graf graf--pre graf-after--pre">.catch(e =&gt; wait(500).then(queryDatabase))</pre><pre name="07c8" id="07c8" class="graf graf--pre graf-after--pre">.then(displayTable)</pre><pre name="4c10" id="4c10" class="graf graf--pre graf-after--pre">.catch(displayDatabaseError);</pre><h3 name="1082" id="1082" class="graf graf--h3 graf-after--pre">Promises in Parallel</h3><p name="00f8" id="00f8" class="graf graf--p graf-after--h3">Sometimes,we want to execute a number of asynchronous operations in parallel. The function <code class="markup--code markup--p-code">Promise.all()</code> can do this. <code class="markup--code markup--p-code">Promise.all()</code> takes an array of Promise objects as its input and returns a Promise.</p><p name="7dca" id="7dca" class="graf graf--p graf-after--p">The returned Promise will be rejected if any of the input Promises are rejected. Otherwise, it will be fulfilled with an array of the fulfillment values of each of the input Promises.</p><pre name="53a3" id="53a3" class="graf graf--pre graf-after--p">const urls = [ /* zero or more URLs here */ ];</pre><pre name="fa65" id="fa65" class="graf graf--pre graf-after--pre">promises = urls.map(url =&gt; fetch(url).then(r =&gt; r.text()));</pre><pre name="fe09" id="fe09" class="graf graf--pre graf-after--pre">Promise.all(promises)</pre><pre name="54ed" id="54ed" class="graf graf--pre graf-after--pre">.then(bodies =&gt; { /* do something with the array of strings */ })</pre><pre name="c346" id="c346" class="graf graf--pre graf-after--pre">.catch(e =&gt; console.error(e));</pre><p name="b408" id="b408" class="graf graf--p graf-after--pre">The Promise returned by <code class="markup--code markup--p-code">Promise.all()</code> rejects when any of the input Promises is rejected. This happens immediately upon the first rejection and can happen while other input Promises are still pending. In ES2020, <code class="markup--code markup--p-code">Promise.allSettled()</code> takes an array of input<br> Promises and returns a Promise, just like Promise.all() does. But <code class="markup--code markup--p-code">Promise.allSettled()</code> never rejects the returned Promise, and it does not fulfill that Promise until all of the input Promises have settled. The Promise resolves to an array of objects, with one object for each input Promise. Each of these returned objects has a status property set to &quot;fulfilled&quot; or &quot;rejected.&quot; If the status is &quot;fulfilled&quot;, then the object will also have a value property that gives the fulfillment value. And if the status is &quot;rejected&quot;, then the object will also have a reason property that gives the error or rejection value of the corresponding Promise.</p><pre name="4379" id="4379" class="graf graf--pre graf-after--p">Promise.allSettled([Promise.resolve(1), Promise.reject(2),3]).then(results =&gt; {</pre><pre name="0e84" id="0e84" class="graf graf--pre graf-after--pre">results[0] // =&gt; { status: &quot;fulfilled&quot;, value: 1 }</pre><pre name="d129" id="d129" class="graf graf--pre graf-after--pre">results[1] // =&gt; { status: &quot;rejected&quot;, reason: 2 }</pre><pre name="b705" id="b705" class="graf graf--pre graf-after--pre">results[2] // =&gt; { status: &quot;fulfilled&quot;, value: 3 }</pre><pre name="54f9" id="54f9" class="graf graf--pre graf-after--pre">});</pre><p name="d2a5" id="d2a5" class="graf graf--p graf-after--pre">Occasionally, you may want to run a number of Promises at once but may only care about the value of the first one to fulfill. In that case, you can use <code class="markup--code markup--p-code">Promise.race()</code> instead of <code class="markup--code markup--p-code">Promise.all()</code>. It returns a Promise that is fulfilled or rejected when the first of the Promises in the input array is fulfilled or rejected.</p><h3 name="ff11" id="ff11" class="graf graf--h3 graf-after--p">Making Promises</h3><h3 name="d013" id="d013" class="graf graf--h3 graf-after--h3">Promises in Sequence</h3><h3 name="a552" id="a552" class="graf graf--h3 graf-after--h3">async and await</h3><p name="e0ac" id="e0ac" class="graf graf--p graf-after--h3">These new keywords dramatically simplify the use of Promises and allow us to write Promise-based, asynchronous code that looks like synchronous code that blocks while waiting for network responses or other asynchronous events.</p><p name="f10a" id="f10a" class="graf graf--p graf-after--p">Asynchronous code can’t return a value or throw an exception the way that regular synchronous code can. And this is why Promises are designed the way the are. The value of a fulfilled Promise is like the return value of a synchronous function. And the value of a rejected Promise is like a value thrown by a synchronous function.</p><p name="8d90" id="8d90" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">async</code> and <code class="markup--code markup--p-code">await</code> take efficient, Promise-based code and hide the Promises so that your asynchronous code can be as easy to read and as easy to reason about as inefficient, blocking, synchronous code.</p><p name="06d4" id="06d4" class="graf graf--p graf-after--p">Given a Promise object p, the expression await p waits until p settles. If p fulfills, then the value of await p is the fulfillment value of p. On the other hand, if p is rejected, then the await p expression throws the rejection value of p.</p><pre name="938c" id="938c" class="graf graf--pre graf-after--p">let response = await fetch(&quot;/api/user/profile&quot;);</pre><pre name="4b52" id="4b52" class="graf graf--pre graf-after--pre">let profile = await response.json();</pre><p name="0e94" id="0e94" class="graf graf--p graf-after--pre">It is critical to understand right away that the <code class="markup--code markup--p-code">await</code> keyword does not cause your program to block and literally do nothing until the specified Promise settles. The code remains asynchronous, and the <code class="markup--code markup--p-code">await</code> simply disguises this fact. This means that any code that uses await is itself asynchronous.</p><h3 name="f2e6" id="f2e6" class="graf graf--h3 graf-after--p">async Functions</h3><p name="49f5" id="49f5" class="graf graf--p graf-after--h3">Because any code that uses await is asynchronous, there is one critical rule: you can only use the await keyword within functions that have been declared with the <code class="markup--code markup--p-code">async</code> keyword.</p><pre name="2971" id="2971" class="graf graf--pre graf-after--p">async function getHighScore() {</pre><pre name="af49" id="af49" class="graf graf--pre graf-after--pre">let response = await fetch(&quot;/api/user/profile&quot;);</pre><pre name="af68" id="af68" class="graf graf--pre graf-after--pre">let profile = await response.json();</pre><pre name="b2b9" id="b2b9" class="graf graf--pre graf-after--pre">return profile.highScore;</pre><pre name="5b46" id="5b46" class="graf graf--pre graf-after--pre">}</pre><p name="53ab" id="53ab" class="graf graf--p graf-after--pre">Declaring a function <code class="markup--code markup--p-code">async</code> means that the return value of the function will be a Promise even if no Promise-related code appears in the body of the function.</p><p name="1944" id="1944" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">getHighScore()</code> function is declared <code class="markup--code markup--p-code">async</code>, so it returns a Promise. And because it returns a Promise, we can use the <code class="markup--code markup--p-code">await</code> keyword with it:</p><pre name="c6de" id="c6de" class="graf graf--pre graf-after--p">displayHighScore(await getHighScore());</pre><h3 name="e92f" id="e92f" class="graf graf--h3 graf-after--pre">Awaiting Multiple Promises</h3><p name="bce7" id="bce7" class="graf graf--p graf-after--h3">Suppose that we’ve written our <code class="markup--code markup--p-code">getJSON()</code> function using async:</p><pre name="f3a7" id="f3a7" class="graf graf--pre graf-after--p">async function getJSON(url) {</pre><pre name="88e3" id="88e3" class="graf graf--pre graf-after--pre">let response = await fetch(url);</pre><pre name="fff0" id="fff0" class="graf graf--pre graf-after--pre">let body = await response.json();</pre><pre name="1a83" id="1a83" class="graf graf--pre graf-after--pre">return body;</pre><pre name="90c9" id="90c9" class="graf graf--pre graf-after--pre">}</pre><p name="ac75" id="ac75" class="graf graf--p graf-after--pre">And now suppose that we want to fetch two JSON values with this function</p><pre name="3426" id="3426" class="graf graf--pre graf-after--p">let value1 = await getJSON(url1);</pre><pre name="8fa7" id="8fa7" class="graf graf--pre graf-after--pre">let value2 = await getJSON(url2);</pre><p name="b7b0" id="b7b0" class="graf graf--p graf-after--pre">The problem with this code is that it is unnecessarily sequential: the fetch of the second URL will not begin until the first fetch is complete. If the second URL does not depend on the value obtained from the firstURL, then we should probably try to fetch the two values at the same time.</p><pre name="681e" id="681e" class="graf graf--pre graf-after--p">let [value1, value2] = await Promise.all([getJSON(url1), getJSON(url2)]);</pre><h3 name="5799" id="5799" class="graf graf--h3 graf-after--pre">The for/await Loop</h3><p name="4f9d" id="4f9d" class="graf graf--p graf-after--h3">Suppose you have an array of URLs:</p><pre name="1671" id="1671" class="graf graf--pre graf-after--p">const urls = [url1, url2, url3];</pre><p name="3a32" id="3a32" class="graf graf--p graf-after--pre">You can call fetch() on each URL to get an array of Promises:</p><pre name="4fe7" id="4fe7" class="graf graf--pre graf-after--p">const promises = urls.map(url =&gt; fetch(url));</pre><p name="d30b" id="d30b" class="graf graf--p graf-after--pre">We could now use<code class="markup--code markup--p-code"> Promise.all()</code> to wait for all the Promises in the array to be fulfilled. But suppose we want the results of the first fetch as soon as they become available and don’t want to wait for all the URLs to be fetched.</p><pre name="20ad" id="20ad" class="graf graf--pre graf-after--p">for(const promise of promises) {</pre><pre name="9c0e" id="9c0e" class="graf graf--pre graf-after--pre">response = await promise;</pre><pre name="3998" id="3998" class="graf graf--pre graf-after--pre">handle(response);</pre><pre name="cd84" id="cd84" class="graf graf--pre graf-after--pre">}</pre><p name="cf3f" id="cf3f" class="graf graf--p graf-after--pre">←&gt;</p><pre name="9160" id="9160" class="graf graf--pre graf-after--p">for await (const response of promises) {</pre><pre name="432e" id="432e" class="graf graf--pre graf-after--pre">handle(response);</pre><pre name="bc51" id="bc51" class="graf graf--pre graf-after--pre">}</pre><p name="ca2f" id="ca2f" class="graf graf--p graf-after--pre">both examples will only work if they are within functions declared async; a <code class="markup--code markup--p-code">for/await</code> loop is no different than a regular await expression in that way</p><h4 name="4372" id="4372" class="graf graf--h4 graf-after--p">If you found this guide helpful feel free to checkout my GitHub/gist’s where I host similar content:</h4><p name="56e5" id="56e5" class="graf graf--p graf-after--h4"><a href="https://gist.github.com/bgoonz" data-href="https://gist.github.com/bgoonz" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">bgoonz’s</strong> gists · GitHub</a></p><div name="3585" id="3585" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/bgoonz" data-href="https://github.com/bgoonz" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/bgoonz"><strong class="markup--strong markup--mixtapeEmbed-strong">bgoonz — Overview</strong><br><em class="markup--em markup--mixtapeEmbed-em">Web Developer, Electrical Engineer JavaScript | CSS | Bootstrap | Python | React | Node.js | Express | Sequelize…</em>github.com</a><a href="https://github.com/bgoonz" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="6ee74d5200d495ddc7ddad0c92bd6dce" data-thumbnail-img-id="0*Udg3rbeFyslZ9dyl" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Udg3rbeFyslZ9dyl);"></a></div><p name="cb1a" id="cb1a" class="graf graf--p graf-after--mixtapeEmbed">Or checkout my personal resource site:</p><div name="4bce" id="4bce" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://goofy-euclid-1cd736.netlify.app/" data-href="https://goofy-euclid-1cd736.netlify.app/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://goofy-euclid-1cd736.netlify.app/"><strong class="markup--strong markup--mixtapeEmbed-strong">a/A-Student-Resources</strong><br><em class="markup--em markup--mixtapeEmbed-em">Edit description</em>goofy-euclid-1cd736.netlify.app</a><a href="https://goofy-euclid-1cd736.netlify.app/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="260adefce95974b3b8f27566d0434b9c" data-thumbnail-img-id="0*kHvsYWw7LFYl0PB_" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*kHvsYWw7LFYl0PB_);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bryanguner" class="p-author h-card">Bryan Guner</a> on <a href="https://medium.com/p/64306cd6b0db"><time class="dt-published" datetime="2021-03-08T09:27:51.495Z">March 8, 2021</time></a>.</p><p><a href="https://medium.com/@bryanguner/complete-javascript-reference-guide-64306cd6b0db" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 10, 2021.</p></footer></article></body></html>