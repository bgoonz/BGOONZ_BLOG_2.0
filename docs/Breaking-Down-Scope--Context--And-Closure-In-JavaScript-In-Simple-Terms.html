<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Breaking Down Scope, Context, And Closure In JavaScript In Simple Terms.</title><style>
</head><body><article class="h-entry">
<header>
<h1 class="p-name">Breaking Down Scope, Context, And Closure In JavaScript In Simple Terms.</h1>
</header>
<section data-field="subtitle" class="p-summary">
â€œJavaScriptâ€™s global scope is like a public toilet. You canâ€™t avoid going in there, but try to limit your contact with surfaces when youâ€¦
</section>
<section data-field="body" class="e-content">
<section name="e560" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="ba93" id="ba93" class="graf graf--h3 graf--leading graf--title">Breaking Down Scope, Context, And Closure In JavaScript In SimpleÂ Terms.</h3><figure name="bd74" id="bd74" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*5M3vbTjiEYMUWvLu" data-width="6000" data-height="4000" data-unsplash-photo-id="4hbJ-eymZ1o" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*5M3vbTjiEYMUWvLu"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@florianolv?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@florianolv?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Florian Olivo</a> onÂ <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><p name="4c60" id="4c60" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf--startsWithDoubleQuote graf-after--figure"><span class="graf-dropCap"><span class="graf-dropCapQuote">â€œ</span>J</span>avaScriptâ€™s global scope is like a public toilet. You canâ€™t avoid going in there, but try to limit your contact with surfaces when you do.â€<br>â€• <strong class="markup--strong markup--p-strong">Dmitry Baranowski</strong></p><p name="b736" id="b736" class="graf graf--p graf-after--p">Hereâ€™s another (much) more simple article I wrote on the subject:</p><div name="4250" id="4250" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://dev.to/bgoonz/closures-in-javascript-1moc" data-href="https://dev.to/bgoonz/closures-in-javascript-1moc" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://dev.to/bgoonz/closures-in-javascript-1moc"><strong class="markup--strong markup--mixtapeEmbed-strong">Closures In Javascript</strong><br><em class="markup--em markup--mixtapeEmbed-em">Answer A closure is a function defined inside another function and has access to its lexical scope even when it isâ€¦</em>dev.to</a><a href="https://dev.to/bgoonz/closures-in-javascript-1moc" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="b15c3539975d0aefd2ecf4c33448e133" data-thumbnail-img-id="0*gg5eRc4Qyjn8q8V2" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*gg5eRc4Qyjn8q8V2);"></a></div><p name="b34d" id="b34d" class="graf graf--p graf-after--mixtapeEmbed">I made this website in support of the articleâ€¦ it links to a navigation page as well as the repo where more examples are keptâ€¦</p><p name="1cc1" id="1cc1" class="graf graf--p graf-after--p"><a href="https://scopeclosurecontext.netlify.app/" data-href="https://scopeclosurecontext.netlify.app/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://scopeclosurecontext.netlify.app/</a></p><h3 name="dcc6" id="dcc6" class="graf graf--h3 graf-after--p">Prerequisites</h3><ul class="postList"><li name="dcbf" id="dcbf" class="graf graf--li graf-after--h3">creating and initializing a variable</li><li name="80e3" id="80e3" class="graf graf--li graf-after--li">creating a function</li><li name="3d43" id="3d43" class="graf graf--li graf-after--li">invoking a function</li><li name="1291" id="1291" class="graf graf--li graf-after--li">logging to the console</li></ul><figure name="adc1" id="adc1" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/bgoonz/ccfa6907e213cebc5fb78b00c72a13c1.js"></script></figure><h3 name="b551" id="b551" class="graf graf--h3 graf-after--figure">further prerequisites:</h3><figure name="190a" id="190a" class="graf graf--figure graf--iframe graf-after--h3"><iframe src="https://codepen.io/bgoonz/embed/preview/oNZoZqP?default-tabs=html%2Cresult&amp;height=600&amp;host=https%3A%2F%2Fcodepen.io&amp;slug-hash=oNZoZqP" width="700" height="525" frameborder="0" scrolling="no"></iframe></figure><p name="b7c4" id="b7c4" class="graf graf--p graf-after--figure">Quiz yourself with this website I made:</p><div name="488f" id="488f" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://web-dev-interview-prep-quiz-website.netlify.app/index.html" data-href="https://web-dev-interview-prep-quiz-website.netlify.app/index.html" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://web-dev-interview-prep-quiz-website.netlify.app/index.html"><strong class="markup--strong markup--mixtapeEmbed-strong">WebDevQuizzes</strong><br><em class="markup--em markup--mixtapeEmbed-em">Resource-sharing-hub</em>web-dev-interview-prep-quiz-website.netlify.app</a><a href="https://web-dev-interview-prep-quiz-website.netlify.app/index.html" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="61419dab371e3b714ec4e46278ac1718"></a></div><h3 name="2699" id="2699" class="graf graf--h3 graf-after--mixtapeEmbed">Vocab (most of these will be detailed many times over in this article!)</h3><ul class="postList"><li name="4f93" id="4f93" class="graf graf--li graf-after--h3"><strong class="markup--strong markup--li-strong">Scope:</strong> â€œScope is the set of rules that determines where and how a variable (identifier) can be looked-up.â€â€Šâ€”â€ŠKyle Simpson, You Donâ€™t Know JS: Scope &amp; Closure</li><li name="ceff" id="ceff" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Function Scope:</strong> Every variable defined in a function, is available for the entirety of that function.</li><li name="b34e" id="b34e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Global Scope:</strong> â€œThe scope that is visible in all other scopes.â€â€Šâ€”â€ŠMDN</li><li name="df88" id="df88" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Global Variable:</strong> A variable defined at the Global Scope.</li><li name="ae7a" id="ae7a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">IIFE:</strong> Imediatly-Invoked Function Expressionâ€Šâ€”â€Ša function wrapped in <code class="markup--code markup--li-code">()</code> to create an expression, and immediatly followed by a pair of <code class="markup--code markup--li-code">()</code> to invoke that function imediatly.</li><li name="42a6" id="42a6" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Closure:</strong> â€œClosures are functions that refer to independent (free) variables. In other words, the function defined in the closure â€˜remembersâ€™ the environment in which it was created.â€â€Šâ€”â€ŠMDN</li><li name="023f" id="023f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Variable Shadowing:</strong> â€œoccurs when a variable declared within a certain scopeÂ â€¦ has the same name as a variable declared in an outer scope.â€â€Šâ€”â€ŠWikipedia</li><li name="7ba5" id="7ba5" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">for statement:</strong> â€œThe for statement creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement or a set of statements executed in the loop.â€â€Šâ€”â€ŠMDN</li><li name="6f95" id="6f95" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">initialization:</strong> â€œAn expression (including assignment expressions) or variable declaration. Typically used to initialize a counter variable. This expression may optionally declare new variables with the var keyword. These variables are not local to the loop, i.e. they are in the same scope the for loop is in. The result of this expression is discarded.â€â€Šâ€”â€ŠMDN</li><li name="c763" id="c763" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">condition:</strong> â€œAn expression to be evaluated before each loop iteration. If this expression evaluates to true, statement is executed. This conditional test is optional. If omitted, the condition always evaluates to true. If the expression evaluates to false, execution skips to the first expression following the for construct.â€â€Šâ€”â€ŠMDN</li><li name="0954" id="0954" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">final-expression:</strong> â€œAn expression to be evaluated at the end of each loop iteration. This occurs before the next evaluation of condition. Generally used to update or increment the counter variable.â€â€Šâ€”â€ŠMDN</li><li name="76ee" id="76ee" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">statement:</strong> â€œA statement that is executed as long as the condition evaluates to true. To execute multiple statements within the loop, use a block statement ({Â â€¦ }) to group those statements.â€â€Šâ€”â€ŠMDN</li><li name="31bf" id="31bf" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Arrays:</strong> â€œJavaScript arrays are used to store multiple values in a single variable.â€â€Šâ€”â€ŠW3Schools</li></div><div class="section-inner sectionLayout--fullWidth"></ul><figure name="bc6a" id="bc6a" class="graf graf--figure graf--layoutFillWidth graf-after--li"><img class="graf-image" data-image-id="1*A1vTM5TdeUhUIfWxemwUEw.png" data-width="1350" data-height="764" src="https://cdn-images-1.medium.com/max/2560/1*A1vTM5TdeUhUIfWxemwUEw.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h4 name="7907" id="7907" class="graf graf--h4 graf-after--figure">I am going to try something new this articleâ€¦ itâ€™s called <strong class="markup--strong markup--h4-strong">spaced repetition.</strong></h4><blockquote name="d2e0" id="d2e0" class="graf graf--blockquote graf--hasDropCapModel graf--startsWithDoubleQuote graf-after--h4"><a href="https://en.wikipedia.org/wiki/Spaced_repetition" data-href="https://en.wikipedia.org/wiki/Spaced_repetition" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--blockquote-strong">â€œSpaced repetition</strong></a> is an <a href="https://en.wikipedia.org/wiki/Evidence-based_learning" data-href="https://en.wikipedia.org/wiki/Evidence-based_learning" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">evidence-based learning</a> technique that is usually performed with <a href="https://en.wikipedia.org/wiki/Flashcard" data-href="https://en.wikipedia.org/wiki/Flashcard" class="markup--anchor markup--blockquote-anchor" title="Flashcard" rel="noopener" target="_blank">flashcards</a>. Newly introduced and more difficult flashcards are shown more frequently, while older and less difficult flashcards are shown less frequently in order to exploit the psychological <a href="https://en.wikipedia.org/wiki/Spacing_effect" data-href="https://en.wikipedia.org/wiki/Spacing_effect" class="markup--anchor markup--blockquote-anchor" title="Spacing effect" rel="noopener" target="_blank">spacing effect</a>. The use of spaced repetition has been proven to increase rate of learning.â€</blockquote><div name="df75" id="df75" class="graf graf--mixtapeEmbed graf-after--blockquote graf--trailing"><a href="https://en.wikipedia.org/wiki/Spaced_repetition" data-href="https://en.wikipedia.org/wiki/Spaced_repetition" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://en.wikipedia.org/wiki/Spaced_repetition"><strong class="markup--strong markup--mixtapeEmbed-strong">Spaced repetitionâ€Šâ€”â€ŠWikipedia</strong><br><em class="markup--em markup--mixtapeEmbed-em">Spaced repetition is an evidence-based learning technique that is usually performed with flashcards. Newly introducedâ€¦</em>en.wikipedia.org</a><a href="https://en.wikipedia.org/wiki/Spaced_repetition" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="95195ea4682196a0957c39326164a522" data-thumbnail-img-id="0*S_6EJeVIl2ByFWnW" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*S_6EJeVIl2ByFWnW);"></a></div></div></div></section><section name="cc87" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a1c8" id="a1c8" class="graf graf--h3 graf--leading">CodePen For You To PracticeÂ With:</h3><p name="c6a6" id="c6a6" class="graf graf--p graf-after--h3">Open it in another tabâ€¦ it will only display the html file that existed when I pasted it into this articleâ€¦ for access to the JavaScript file and the most up to date html page you need to Open the sandboxâ€¦ feel free to create a fork of it if you like!</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="b628" id="b628" class="graf graf--figure graf--iframe graf--layoutOutsetCenter graf-after--p graf--trailing"><iframe src="https://codepen.io/bgoonz/embed/preview/bGqYBQY?default-tabs=html%2Cresult&amp;height=600&amp;host=https%3A%2F%2Fcodepen.io&amp;slug-hash=bGqYBQY" width="1192" height="894" frameborder="0" scrolling="no"></iframe></figure></div></div></section><section name="1c1a" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="80bf" id="80bf" class="graf graf--h3 graf--leading">SCOPE:</h3><ul class="postList"><li name="8522" id="8522" class="graf graf--li graf-after--h3">The <code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">scope</strong></code> of a program in JS is the set of variables that are available for use within the program.</li><li name="dc76" id="dc76" class="graf graf--li graf-after--li">Scope in JavaScript defines which variables and functions you have access to, depending on where you are (a <em class="markup--em markup--li-em">physical position</em>) within your code.</li><li name="1243" id="1243" class="graf graf--li graf-after--li">The current context of execution. The context in which <a href="https://developer.mozilla.org/en-US/docs/Glossary/Value" data-href="https://developer.mozilla.org/en-US/docs/Glossary/Value" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">values</a> and <strong class="markup--strong markup--li-strong">expressions</strong> are â€œvisibleâ€ or can be referenced. If a <a href="https://developer.mozilla.org/en-US/docs/Glossary/Variable" data-href="https://developer.mozilla.org/en-US/docs/Glossary/Variable" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">variable</strong></a> or other expression is not â€œin the current scope,â€ then it is unavailable for use. Scopes can also be layered in a hierarchy, so that child scopes have access to parent scopes, but not vice versa.</li></ul><figure name="5e76" id="5e76" class="graf graf--figure graf--layoutOutsetLeft graf-after--li"><img class="graf-image" data-image-id="1*RaM-5KbhUOZ_HoP5j-kNWQ.png" data-width="969" data-height="601" src="https://cdn-images-1.medium.com/max/600/1*RaM-5KbhUOZ_HoP5j-kNWQ.png"></figure><ul class="postList"><li name="def6" id="def6" class="graf graf--li graf-after--figure">A <a href="https://developer.mozilla.org/en-US/docs/Glossary/Function" data-href="https://developer.mozilla.org/en-US/docs/Glossary/Function" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">function</strong></a> serves as a <strong class="markup--strong markup--li-strong">closure</strong> in <a href="https://developer.mozilla.org/en-US/docs/Glossary/JavaScript" data-href="https://developer.mozilla.org/en-US/docs/Glossary/JavaScript" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">JavaScript</a>, and thus creates a scope, so that (for example) a variable defined exclusively within the function cannot be accessed from outside the function or within other functions:<a href="https://developer.mozilla.org/en-US/docs/Glossary/Scope" data-href="https://developer.mozilla.org/en-US/docs/Glossary/Scope" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://developer.mozilla.org/en-US/docs/Glossary/Scope</a></li><li name="16a2" id="16a2" class="graf graf--li graf-after--li">In <a href="https://en.wikipedia.org/wiki/Computer_programming" data-href="https://en.wikipedia.org/wiki/Computer_programming" class="markup--anchor markup--li-anchor" title="Computer programming" rel="noopener" target="_blank">computer programming</a>, the <strong class="markup--strong markup--li-strong">scope</strong> of a <a href="https://en.wikipedia.org/wiki/Name_binding" data-href="https://en.wikipedia.org/wiki/Name_binding" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">name binding</a>â€Šâ€”â€Šan association of a name to an entity, such as a <a href="https://en.wikipedia.org/wiki/Variable_%28programming%29" data-href="https://en.wikipedia.org/wiki/Variable_(programming)" class="markup--anchor markup--li-anchor" title="Variable (programming)" rel="noopener" target="_blank">variable</a>â€Šâ€”â€Šis the part of a <a href="https://en.wikipedia.org/wiki/Computer_program" data-href="https://en.wikipedia.org/wiki/Computer_program" class="markup--anchor markup--li-anchor" title="Computer program" rel="noopener" target="_blank">program</a> where the name binding is valid, that is where the name can be used to refer to the entity. In other parts of the program the name may refer to a different entity (it may have a different binding), or to nothing at all (it may be unbound). The scope of a name binding is also known as the <strong class="markup--strong markup--li-strong">visibility</strong> of an entity, particularly in older or more technical literatureâ€Šâ€”â€Šthis is from the perspective of the referenced entity, not the referencing name:<a href="https://en.wikipedia.org/wiki/Scope_%28computer_science%29" data-href="https://en.wikipedia.org/wiki/Scope_(computer_science)" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://en.wikipedia.org/wiki/Scope_(computer_science)</a></li></ul><p name="5ee9" id="5ee9" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Advantages of utilizing scope</strong></p><ul class="postList"><li name="857d" id="857d" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">Security</strong></code>Â : Adds security by ensuring variables can only be access by pre-defined parts of our program.</li><li name="a55d" id="a55d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">Reduced Variable Name Collisions</strong></code>Â : Restricts re-using variable names; helps prevent overwriting variable names.</li></ul><h3 name="4ef0" id="4ef0" class="graf graf--h3 graf-after--li">Lexical Scope</h3><p name="0d52" id="0d52" class="graf graf--p graf-after--h3">Lexical scope is the ability of the inner function to access the outer scope in which it is defined.</p><figure name="5fda" id="5fda" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://jsfiddle.net/bgoonz/7xfs4ew1/embedded/" width="600" height="400" frameborder="0" scrolling="no"></iframe></figure><ul class="postList"><li name="62b5" id="62b5" class="graf graf--li graf-after--figure"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">Lexing Time</strong></code>Â : When you run a piece of JS code that is parsed before it is run.</li><li name="9320" id="9320" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">Lexical environment</em> is a place where variables and functions live during the program execution.</li></ul><figure name="8a40" id="8a40" class="graf graf--figure graf--iframe graf-after--li"><iframe src="https://jsfiddle.net/bgoonz/1zc2vkqe/embedded/" width="600" height="400" frameborder="0" scrolling="no"></iframe></figure><h3 name="d280" id="d280" class="graf graf--h3 graf-after--figure">Different Variables in JavaScript</h3><ul class="postList"><li name="25bd" id="25bd" class="graf graf--li graf-after--h3"><em class="markup--em markup--li-em">A variable always evaluates to the value it contains no matter how you declare it.</em></li></ul><p name="3fb6" id="3fb6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">The different ways to declare variables</strong></p><ul class="postList"><li name="1cff" id="1cff" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">let</strong></code>Â : can be re-assigned; block-scoped.</li><li name="a2e4" id="a2e4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">const</strong></code>Â : no re-assignment; block scoped.</li><li name="c933" id="c933" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">var</strong></code>Â : May or may not be re-assigned; scoped to a function.</li></ul><p name="e77f" id="e77f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Hoisting and Scoping with Variables</strong></p><p name="90ab" id="90ab" class="graf graf--p graf-after--p graf--trailing"><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">Hoisting</strong></code> is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.</p></div></div></section><section name="f283" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><figure name="694b" id="694b" class="graf graf--figure graf--leading"><img class="graf-image" data-image-id="0*Tb-9wd4RBvBCwIR2.jpeg" data-width="651" data-height="383" src="https://cdn-images-1.medium.com/max/800/0*Tb-9wd4RBvBCwIR2.jpeg"><figcaption class="imageCaption">I am afraidÂ â€¦ sometimesâ€¦ one simply doesâ€¦ at least analogous-ley</figcaption></figure><h3 name="5773" id="5773" class="graf graf--h3 graf-after--figure">!!!Only function declarations are hoisted in JavaScript, function expressions are not hoisted!!!</h3><h3 name="15c4" id="15c4" class="graf graf--h3 graf-after--h3">&amp;&amp;</h3><h3 name="ba6a" id="ba6a" class="graf graf--h3 graf-after--h3 graf--trailing">!!! Only variables declared with var are hoisted!!!!</h3></div></div></section><section name="eed6" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c5d7" id="c5d7" class="graf graf--h3 graf--leading">Slightly modified excerptÂ from:</h3><h4 name="4fe2" id="4fe2" class="graf graf--h4 graf-after--h3"><a href="https://ui.dev/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/" data-href="https://ui.dev/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">source</a>Â : https://ui.dev/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/</h4><p name="cbb9" id="cbb9" class="graf graf--p graf-after--h4">The first <em class="markup--em markup--p-em">Execution Context</em> ( a word that we donâ€™t have to worry about the exact meaning of yet) that gets created when the JavaScript engine runs your code is called the â€œGlobal Execution Contextâ€.</p><p name="7824" id="7824" class="graf graf--p graf-after--p">Initially this Execution Context will consist of two things â€”</p><ul class="postList"><li name="ba1b" id="ba1b" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">a global object</strong></li></ul><blockquote name="aa4a" id="aa4a" class="graf graf--blockquote graf-after--li"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">and</em></strong></blockquote><ul class="postList"><li name="bdfe" id="bdfe" class="graf graf--li graf-after--blockquote"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">a</em> variable called</strong> <code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">this</strong></code>.</li></ul><blockquote name="e365" id="e365" class="graf graf--blockquote graf-after--li">By default the<code class="markup--code markup--blockquote-code"><strong class="markup--strong markup--blockquote-strong">this</strong></code> keyword will act as a reference to global object which will be <code class="markup--code markup--blockquote-code">window</code> if youâ€™re running JavaScript in the browser or <code class="markup--code markup--blockquote-code"><strong class="markup--strong markup--blockquote-strong">global</strong></code> if youâ€™re running it in a Node environment.</blockquote><h3 name="f4c6" id="f4c6" class="graf graf--h3 graf-after--blockquote">REMEMBER:</h3><blockquote name="2c74" id="2c74" class="graf graf--blockquote graf-after--h3">Node: <code class="markup--code markup--blockquote-code"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">this</em></strong></code> references a global object called <strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">window</em></strong> (like the window that comprises the content of a tab in chrome)</blockquote><blockquote name="eee5" id="eee5" class="graf graf--blockquote graf-after--blockquote">Browsers:<code class="markup--code markup--blockquote-code"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">this</em></strong></code> references a global object called <strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">global</em></strong></blockquote><figure name="002d" id="002d" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="0*NMGRtcYlwffqSUSH.png" data-width="1696" data-height="796" src="https://cdn-images-1.medium.com/max/800/0*NMGRtcYlwffqSUSH.png"></figure><p name="ed77" id="ed77" class="graf graf--p graf-after--figure">Above we can see that even without any code, the Global Execution Context will still consist of two thingsâ€Šâ€”â€Š<code class="markup--code markup--p-code">window</code> and <code class="markup--code markup--p-code">this</code>. This is the Global Execution Context in its most basic form.</p><p name="d98d" id="d98d" class="graf graf--p graf-after--p">Letâ€™s step things up and see what happens when we start actually adding code to our program. Letâ€™s start with adding a few variables.</p><figure name="9a4f" id="9a4f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*P8DG5hIKJO7thsnz.png" data-width="1972" data-height="1002" src="https://cdn-images-1.medium.com/max/800/0*P8DG5hIKJO7thsnz.png"></figure><figure name="b744" id="b744" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="0*J9juq03-KlcKReSF.png" data-width="1972" data-height="1002" src="https://cdn-images-1.medium.com/max/800/0*J9juq03-KlcKReSF.png"></figure><p name="b62f" id="b62f" class="graf graf--p graf-after--figure graf--trailing">The key take away is that each Execution Context has two separate phases, a <code class="markup--code markup--p-code">Creation</code> phase and an <code class="markup--code markup--p-code">Execution</code> phase and each phase has its own unique responsibilities.</p></div></div></section><section name="d090" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7aa4" id="7aa4" class="graf graf--h3 graf--leading">Exaction Context:</h3><h4 name="ad89" id="ad89" class="graf graf--h4 graf-after--h3">Execution Context â‰ (NOT EQUAL)â‰ â‰ â‰ Scope</h4><ol class="postList"><li name="0fcc" id="0fcc" class="graf graf--li graf-after--h4">The <strong class="markup--strong markup--li-strong">global execution context</strong> is created <strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">before</em> </strong>any code is executed.</li><li name="de32" id="de32" class="graf graf--li graf-after--li">Whenever a function is <em class="markup--em markup--li-em">executed </em>invoked (this means the function is told to runâ€¦ i.e. after the doSomething function has been declaredÂ â€¦ calling â€˜doSomething()â€™, a <strong class="markup--strong markup--li-strong">new execution context</strong> gets created.</li><li name="20c3" id="20c3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Every</strong> execution context provides <code class="markup--code markup--li-code">this</code> keyword, which points to an <strong class="markup--strong markup--li-strong">object</strong> to which the current code thatâ€™s being executed belongs.</li></ol><p name="5921" id="5921" class="graf graf--p graf-after--li graf--trailing">For more info read about <a href="https://medium.com/@Rahulx1/understanding-event-loop-call-stack-event-job-queue-in-javascript-63dcd2c71ecd" data-href="https://medium.com/@Rahulx1/understanding-event-loop-call-stack-event-job-queue-in-javascript-63dcd2c71ecd" class="markup--anchor markup--p-anchor" target="_blank">Event Queue and Call Stack</a></p></div></div></section><section name="c8a0" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="e359" id="e359" class="graf graf--h4 graf--leading">More formal definition from: <a href="https://codeburst.io/js-demystified-04-execution-context-97dea52c8ac6" data-href="https://codeburst.io/js-demystified-04-execution-context-97dea52c8ac6" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">Misa Oguraâ€™s article on theÂ subject</a></h4><p name="b429" id="b429" class="graf graf--p graf-after--h4">In JavaScript, <strong class="markup--strong markup--p-strong">execution context</strong> is an abstract concept that holds <em class="markup--em markup--p-em">information about the environment </em>within which the current code is being executed.</p><p name="32ec" id="32ec" class="graf graf--p graf-after--p graf--trailing"><strong class="markup--strong markup--p-strong">Remember</strong>: the JavaScript engine creates the global execution context before it starts to execute any code. From that point on, a new execution context gets created <em class="markup--em markup--p-em">every time</em> a function is executed, as the engine parses through your code. In fact, the global execution context is nothing special. Itâ€™s just like any other execution context, except that it gets created by default.</p></div></div></section><section name="1963" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="114f" id="114f" class="graf graf--p graf--leading">In the Global <code class="markup--code markup--p-code">Creation</code> phase, the JavaScript engine will</p><ol class="postList"><li name="0634" id="0634" class="graf graf--li graf-after--p">Create a global object.</li><li name="ed12" id="ed12" class="graf graf--li graf-after--li">Create an object called â€œthisâ€.</li><li name="b1a7" id="b1a7" class="graf graf--li graf-after--li">Set up memory space for variables and functions.</li><li name="7656" id="7656" class="graf graf--li graf-after--li">Assign variable declarations a default value of â€œundefinedâ€ while placing any function declarations in memory.</li></ol><p name="6c9f" id="6c9f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Itâ€™s not until the </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">Execution</strong></code><strong class="markup--strong markup--p-strong"> phase where the JavaScript engine starts running your code line by line and executing it.</strong></p><p name="3375" id="3375" class="graf graf--p graf-after--p">We can see this flow from<strong class="markup--strong markup--p-strong"> </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">Creation</strong></code><strong class="markup--strong markup--p-strong"> phase to </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">Execution</strong></code><strong class="markup--strong markup--p-strong"> phase</strong> in the GIF <strong class="markup--strong markup--p-strong">below. </strong>ğŸ —ğŸ —ğŸ —ğŸ —ğŸ —ğŸ —</p><figure name="1dfd" id="1dfd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*QHJcijvusr0_rqAH.gif" data-width="1056" data-height="790" src="https://cdn-images-1.medium.com/max/800/0*QHJcijvusr0_rqAH.gif"></figure><p name="1135" id="1135" class="graf graf--p graf-after--figure">During the <code class="markup--code markup--p-code">Creation</code> phase:</p><p name="bc60" id="bc60" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The JavaScript engine said â€˜let there be </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">window</strong></code><strong class="markup--strong markup--p-strong"> and </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">this</strong></code>â€˜</p><blockquote name="9cc2" id="9cc2" class="graf graf--blockquote graf-after--p">and there was <code class="markup--code markup--blockquote-code">window</code> and <code class="markup--code markup--blockquote-code">this</code>â€¦ and it was good</blockquote><p name="f95b" id="f95b" class="graf graf--p graf-after--blockquote">Once the <code class="markup--code markup--p-code">window</code> and <code class="markup--code markup--p-code">this</code> are created;</p><p name="bea3" id="bea3" class="graf graf--p graf-after--p">Variable declarations are assigned a default value of <code class="markup--code markup--p-code">undefined</code></p><p name="dc58" id="dc58" class="graf graf--p graf-after--p">Any function declarations (<code class="markup--code markup--p-code">getUser</code>) are placed entirely into memory.</p><p name="55a8" id="55a8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Exaction Phase:</strong></p><p name="4f79" id="4f79" class="graf graf--p graf-after--p graf--trailing">Then once we enter the <code class="markup--code markup--p-code">Execution</code> phase, the JavaScript engine starts executing the code line by line and assigns the real values to the variables already living in memory.</p></div></div></section><section name="6902" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><figure name="b483" id="b483" class="graf graf--figure graf--iframe graf--leading graf--trailing"><script src="https://gist.github.com/bgoonz/1c19ac4b7644e3263a3e01e166f5146e.js"></script></figure></div></div></section><section name="43f5" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="cfdd" id="cfdd" class="graf graf--h3 graf--leading"><strong class="markup--strong markup--h3-strong">Function-Scoped Variables</strong></h3><figure name="830c" id="830c" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*blt2vI9_uDtV7_pM9Cclkg.png" data-width="676" data-height="430" src="https://cdn-images-1.medium.com/max/800/1*blt2vI9_uDtV7_pM9Cclkg.png"></figure><p name="84f5" id="84f5" class="graf graf--p graf-after--figure">Function scope means that parameters and variables defined in a function are visible everywhere within the function, but are not visible outside of the function.</p><p name="2efe" id="2efe" class="graf graf--p graf-after--p">Consider the next function that auto-executes, called IIFE.</p><pre name="9b24" id="9b24" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">(function autoexecute() {<br>    let x = 1;<br>})();</code></pre><pre name="8fa1" id="8fa1" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(x);<br>//Uncaught ReferenceError: x is not defined</code></pre><p name="1e57" id="1e57" class="graf graf--p graf-after--pre">IIFE stands for Immediately Invoked Function Expression and is a function that runs immediately after its definition.</p><p name="e3be" id="e3be" class="graf graf--p graf-after--p">Variables declared with <code class="markup--code markup--p-code">var</code> have only function scope. Even more, variables declared with <code class="markup--code markup--p-code">var</code> are hoisted to the top of their scope. This way they can be accessed before being declared. Take a look at the code below:</p><pre name="fa53" id="fa53" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function doSomething(){<br>  console.log(x);<br>  var x = 1;<br>}</code></pre><pre name="69f8" id="69f8" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">doSomething(); //undefined</code></pre><p name="96cd" id="96cd" class="graf graf--p graf-after--pre">This does not happen for <code class="markup--code markup--p-code">let</code>. A variable declared with <code class="markup--code markup--p-code">let</code> can be accessed only after its definition.</p><pre name="cf7e" id="cf7e" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function doSomething(){<br>  console.log(x);<br>  let x = 1;<br>}</code></pre><pre name="6133" id="6133" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">doSomething();<br>//Uncaught ReferenceError: x is not defined</code></pre><p name="1eac" id="1eac" class="graf graf--p graf-after--pre">A variable declared with <code class="markup--code markup--p-code">var</code> can be re-declared multiple times in the same scope. The following code is just fine:</p><pre name="8ca1" id="8ca1" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function doSomething(){<br>  var x = 1<br>  var x = 2;<br>  console.log(x);<br>}</code></pre><pre name="59e4" id="59e4" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">doSomething();</code></pre><p name="0b7f" id="0b7f" class="graf graf--p graf-after--pre">Variables declared with <code class="markup--code markup--p-code">let</code> or <code class="markup--code markup--p-code">const</code> cannot be re-declared in the same scope:</p><pre name="1fa8" id="1fa8" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function doSomething(){<br>  let x = 1<br>  let x = 2;<br>}<br>//Uncaught SyntaxError: Identifier &#39;x&#39; has already been declared</code></pre><p name="985c" id="985c" class="graf graf--p graf-after--pre">Maybe we donâ€™t even have to care about this, as <code class="markup--code markup--p-code">var</code> has started to become obsolete.</p><ul class="postList"><li name="504b" id="504b" class="graf graf--li graf-after--p">Only the var keyword creates function-scoped variables (however a var declared variable may be globally scoped if it is declared outside of a nested function in the global scope), this means our declared var keyword variable will be confined to the scope of our current function.</li></ul><figure name="cedf" id="cedf" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/bgoonz/2684265178db1a729436c620b1c21a75.js"></script></figure><p name="4e9d" id="4e9d" class="graf graf--p graf-after--figure">Why you shouldnâ€™t use var:</p><ol class="postList"><li name="491f" id="491f" class="graf graf--li graf-after--p">No error is thrown if you declare the same variable twice using var (conversely, both let and const will throw an error if a variable is declared twice)</li><li name="b04e" id="b04e" class="graf graf--li graf-after--li">Variables declared with var are not block scoped (although they are function scoped), while with let and const they are. This is important because whatâ€™s the point of block scoping if youâ€™re not going to use it. So using var in this context would require a situation in which a variable declared inside a function would need to be used in the global scope. Iâ€™m not able to think of any situations where that would be absolutely necessary, but perhaps they exist.</li></ol><figure name="8863" id="8863" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/bgoonz/7a22c1d6fa4bdddb3a5c3eaadb4dcc84.js"></script></figure><h3 name="0cae" id="0cae" class="graf graf--h3 graf-after--figure">REMEMBER:</h3><h3 name="487d" id="487d" class="graf graf--h3 graf-after--h3">Var===ğŸ—‘ğŸš®ğŸ‘ğŸ½ğŸ¤®</h3><figure name="fbd0" id="fbd0" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*wseqGvDH8TpNBGq9" data-width="361" data-height="348" src="https://cdn-images-1.medium.com/max/800/0*wseqGvDH8TpNBGq9"><figcaption class="imageCaption"><strong class="markup--strong markup--figure-strong">My response to anyone who might comment in defense of usingÂ var</strong></figcaption></figure><blockquote name="bfe3" id="bfe3" class="graf graf--blockquote graf-after--figure">Also on a more serious noteâ€¦ if you have var in your projects in 2021Â â€¦hiring managers who peek at your projects to see your code quality will assume it was copy pasted from someone elseâ€™s legacy code circa 2014.</blockquote><figure name="a627" id="a627" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="0*KRoeNth4AXswt_9s.jpg" data-width="561" data-height="552" src="https://cdn-images-1.medium.com/max/800/0*KRoeNth4AXswt_9s.jpg"></figure><p name="c2c3" id="c2c3" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Hoisting with function-scoped variables</strong></p><pre name="72d1" id="72d1" class="graf graf--pre graf-after--p">function test() {<br>  // var hoistedVar;<br>  console.log(hoistedVar); // =&gt;  undefined<br>  var hoistedVar = 10;<br>}</pre><ul class="postList"><li name="b52d" id="b52d" class="graf graf--li graf-after--pre">Even though we initially declared &amp; initialized our variable underneath the console.log var variables are â€œhoistedâ€ to the top, but only in declaration (default value undefined until the exaction arrives at the line on which it was initialized.</li></ul><h3 name="a0d5" id="a0d5" class="graf graf--h3 graf-after--li">Scope Spaced Repetition:</h3><p name="e9a9" id="e9a9" class="graf graf--p graf-after--h3">Scope is defined as which variables we currently have access to and where. So far in this course, we have mostly been working in <code class="markup--code markup--p-code">global</code> scope, in that we can access any variable we have created, anywhere in our code. There are a couple different levels of scope: <code class="markup--code markup--p-code">block</code> level scope is used in <code class="markup--code markup--p-code">if</code> statements and <code class="markup--code markup--p-code">for</code> loops. In <code class="markup--code markup--p-code">block</code> level scope, a variable declared using either <code class="markup--code markup--p-code">let</code> or <code class="markup--code markup--p-code">const</code> is only available within the statement or loop (like <code class="markup--code markup--p-code">i</code> in a <code class="markup--code markup--p-code">for</code> loop). Similarly, there is function scope, where <code class="markup--code markup--p-code">temperature</code> exists inside the function, but not elsewhere in your code file.</p><h3 name="c306" id="c306" class="graf graf--h3 graf-after--p">More on hoisting:</h3><h4 name="71d2" id="71d2" class="graf graf--h4 graf-after--h3">source:<a href="https://blog.bitsrc.io/hoisting-in-modern-javascript-let-const-and-var-b290405adfda" data-href="https://blog.bitsrc.io/hoisting-in-modern-javascript-let-const-and-var-b290405adfda" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank"> <em class="markup--em markup--h4-em">Hoisting in Modern JavaScriptâ€Šâ€”â€Šlet, const, andÂ var</em></a></h4><pre name="fd48" id="fd48" class="graf graf--pre graf-after--h4">helloWorld();  // prints &#39;Hello World!&#39; to the consolefunction helloWorld(){<br>  console.log(&#39;Hello World!&#39;);<br>}</pre><p name="4f4c" id="4f4c" class="graf graf--p graf-after--pre">Function declarations are added to the memory during the compile stage, so we are able to access it in our code before the actual function declaration</p><p name="1297" id="1297" class="graf graf--p graf-after--p">When the JavaScript engine encounters a call to <code class="markup--code markup--p-code">helloWorld()</code>, it will look into the lexical environment, finds the function and will be able to execute it.</p><h3 name="ef0a" id="ef0a" class="graf graf--h3 graf-after--p">Hoisting Function Expressions</h3><p name="2d52" id="2d52" class="graf graf--p graf-after--h3">Only function declarations are hoisted in JavaScript, function expressions are not hoisted. For example: this code wonâ€™t work.</p><pre name="53d9" id="53d9" class="graf graf--pre graf-after--p">helloWorld();  // TypeError: helloWorld is not a functionvar helloWorld = function(){<br>  console.log(&#39;Hello World!&#39;);<br>}</pre><p name="b90d" id="b90d" class="graf graf--p graf-after--pre">As JavaScript only hoist declarations, not initializations (assignments), so the <code class="markup--code markup--p-code">helloWorld </code>will be treated as a variable, not as a function. Because <code class="markup--code markup--p-code">helloWorld</code> is a <code class="markup--code markup--p-code">var</code> variable, so the engine will assign is the <code class="markup--code markup--p-code">undefined</code> value during hoisting.</p><p name="0a04" id="0a04" class="graf graf--p graf-after--p">So this code will work.</p><pre name="5f7c" id="5f7c" class="graf graf--pre graf-after--p">var helloWorld = function(){<br>  console.log(&#39;Hello World!&#39;);  prints &#39;Hello World!&#39;<br>}helloWorld();</pre><h3 name="9f9f" id="9f9f" class="graf graf--h3 graf-after--pre">Hoisting var variables:</h3><p name="2233" id="2233" class="graf graf--p graf-after--h3">Letâ€™s look at some examples to understand hoisting in case of <code class="markup--code markup--p-code">var</code> variables.</p><pre name="8e3f" id="8e3f" class="graf graf--pre graf-after--p">console.log(a); // outputs &#39;undefined&#39;<br>var a = 3;</pre><p name="57b8" id="57b8" class="graf graf--p graf-after--pre">We expected <code class="markup--code markup--p-code">3</code> but instead got <code class="markup--code markup--p-code">undefined</code>. Why?</p><p name="adfb" id="adfb" class="graf graf--p graf-after--p">Remember JavaScript only hoist declarations, not initializations<em class="markup--em markup--p-em">. </em>That is, during compile time, JavaScript only stores function and variable<em class="markup--em markup--p-em"> </em>declarations in the memory, not their assignments (value).</p><p name="bc62" id="bc62" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">But why </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">undefined</strong></code><strong class="markup--strong markup--p-strong">?</strong></p><p name="6fab" id="6fab" class="graf graf--p graf-after--p">When JavaScript engine finds a <code class="markup--code markup--p-code">var</code> variable declaration during the compile phase, it will add that variable to the lexical environment and initialize it with <code class="markup--code markup--p-code">undefined</code> and later during the execution when it reaches the line where the actual assignment is done in the code, it will assign that value to the variable.</p><p name="74a7" id="74a7" class="graf graf--p graf-after--p graf--trailing"><a href="https://codeburst.io/js-demystified-03-scope-f841ecad5c23" data-href="https://codeburst.io/js-demystified-03-scope-f841ecad5c23" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://codeburst.io/js-demystified-03-scope-f841ecad5c23</a> is a really great articleâ€¦ skip down to Hoisting and Scope to pursue this topic further!</p></div></div></section><section name="43c1" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="607e" id="607e" class="graf graf--h3 graf--leading"><strong class="markup--strong markup--h3-strong">Block-Scoped Variables</strong></h3><p name="60c2" id="60c2" class="graf graf--p graf-after--h3">Things that create block-scopes:</p><ul class="postList"><li name="66e4" id="66e4" class="graf graf--li graf-after--p">If Statements</li><li name="9a99" id="9a99" class="graf graf--li graf-after--li">While Loops</li><li name="dc88" id="dc88" class="graf graf--li graf-after--li">Switch Statements</li><li name="c5fb" id="c5fb" class="graf graf--li graf-after--li">For Loops</li><li name="089b" id="089b" class="graf graf--li graf-after--li">Curly Boiz<strong class="markup--strong markup--li-strong"> â€˜{}â€™Â â€¦.. anything between cury brackets is scoped to within those brackets.</strong></li></ul><h4 name="1ade" id="1ade" class="graf graf--h4 graf-after--li"><strong class="markup--strong markup--h4-strong">Properties of Const declared variables:</strong></h4><ul class="postList"><li name="2c52" id="2c52" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">They are block-scoped like let.</strong></li><li name="3d0c" id="3d0c" class="graf graf--li graf-after--li">JS will enforce constants by raising an error if you try to change them.</li><li name="67b6" id="67b6" class="graf graf--li graf-after--li">Constants that are assigned to <a href="https://bryanguner.medium.com/fundamental-javascript-concepts-you-should-understand-81c4d839b827" data-href="https://bryanguner.medium.com/fundamental-javascript-concepts-you-should-understand-81c4d839b827" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Reference Types</a> are <a href="https://doesitmutate.xyz/" data-href="https://doesitmutate.xyz/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">mutable</strong></a></li></ul><p name="4670" id="4670" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Hoisting with block-scoped variables</strong></p><ul class="postList"><li name="329c" id="329c" class="graf graf--li graf-after--p">Unlike vars in function scopes,</li><li name="f15b" id="f15b" class="graf graf--li graf-after--li">let and const in their block scopes <strong class="markup--strong markup--li-strong">do not get their declarations hoisted.</strong></li><li name="a2f6" id="a2f6" class="graf graf--li graf-after--li">Instead they are not initialized until their definitions are evaluated instead of undefined we will get an error.</li><li name="f0c6" id="f0c6" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">Temporal Dead Zone</strong></code><strong class="markup--strong markup--li-strong">Â : The time before a let or const variable is declared.</strong></li></ul><p name="26b1" id="26b1" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Function Scope vs Block Scope</strong></p><ul class="postList"><li name="1764" id="1764" class="graf graf--li graf-after--p">The downside of the flexibility of var is that it can easily overwrite previously declared variables.</li><li name="456f" id="456f" class="graf graf--li graf-after--li">The block-scope limitations of let and const were introduced to easily avoid accidentally overwriting variable values.</li></ul><h3 name="4b48" id="4b48" class="graf graf--h3 graf-after--li"><strong class="markup--strong markup--h3-strong">Global Variables</strong></h3><ul class="postList"><li name="f3a2" id="f3a2" class="graf graf--li graf-after--h3">Any variables declared without a declaration term will be considered <code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">global scope</strong></code>.</li><li name="fc02" id="fc02" class="graf graf--li graf-after--li">Every time a variable is declared on the global scope, the change of collision increases.</li><li name="5c6a" id="5c6a" class="graf graf--li graf-after--li">Use the proper declarations to manage your code: Avoid being a sloppy programmer!</li></ul><figure name="e711" id="e711" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*hpZDzz--eVsA-3o7.png" data-width="1024" data-height="850" src="https://cdn-images-1.medium.com/max/800/0*hpZDzz--eVsA-3o7.png"></figure><p name="a16e" id="a16e" class="graf graf--p graf-after--figure">Variables defined outside any function, block, or module scope have global scope. Variables in global scope can be accessed from everywhere in the application.</p><p name="0f8e" id="0f8e" class="graf graf--p graf-after--p">When a module system is enabled itâ€™s harder to make global variables, but one can still do it. By defining a variable in HTML, outside any function, a global variable can be created:</p><p name="2211" id="2211" class="graf graf--p graf-after--p">When there is no module system in place, it is a lot easier to create global variables. A variable declared outside any function, in any file, is a global variable.</p><p name="c96b" id="c96b" class="graf graf--p graf-after--p">Global variables are available for the lifetime of the application.</p><p name="0729" id="0729" class="graf graf--p graf-after--p">Another way for creating a global variable is to use the <code class="markup--code markup--p-code">window</code> global object anywhere in the application:</p><pre name="8b2e" id="8b2e" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">window.GLOBAL_DATA = { value: 1 };</code></pre><p name="4acb" id="4acb" class="graf graf--p graf-after--pre">At this point, the <code class="markup--code markup--p-code">GLOBAL_DATA</code> variable is visible everywhere.</p><pre name="77b3" id="77b3" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">console.log(GLOBAL_DATA)</code></pre><p name="32f2" id="32f2" class="graf graf--p graf-after--pre">As you can imagine these practices are bad practices.</p><h4 name="8815" id="8815" class="graf graf--h4 graf-after--p">*Module scope</h4><p name="c3cb" id="c3cb" class="graf graf--p graf-after--h4">Before modules, a variable declared outside any function was a global variable. In modules, a variable declared outside any function is hidden and not available to other modules unless it is explicitly exported.</p><p name="7d7f" id="7d7f" class="graf graf--p graf-after--p">Exporting makes a function or object available to other modules. In the next example, I export a function from the <code class="markup--code markup--p-code">sequence.js</code> module file:</p><pre name="734c" id="734c" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// in sequence.js<br>export { sequence, toList, take };</code></pre><p name="9597" id="9597" class="graf graf--p graf-after--pre">Importing makes a function or object, from other modules, available to the current module.</p><pre name="2ce9" id="2ce9" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">import { sequence, toList, toList } from &quot;./sequence&quot;;</code></pre><p name="31ed" id="31ed" class="graf graf--p graf-after--pre">In a way, we can imagine a module as a self-executing function that takes the import data as inputs and returns the export data.</p><h3 name="0dd2" id="0dd2" class="graf graf--h3 graf-after--p">Closures</h3><figure name="c9cf" id="c9cf" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*r5JXVTIjV1nztgKN.jpg" data-width="942" data-height="466" src="https://cdn-images-1.medium.com/max/800/0*r5JXVTIjV1nztgKN.jpg"></figure><p name="6648" id="6648" class="graf graf--p graf-after--figure"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Calculating Closures</em></strong></a></p><ul class="postList"><li name="46b0" id="46b0" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Closure</strong>Â : The combination of a function and the lexical environment within which that function is declared.</li><li name="0323" id="0323" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Use</strong>Â : A closure is when an inner function uses, or changes, variables in an outer function.</li><li name="05be" id="05be" class="graf graf--li graf-after--li">Very important for creativity, flexibility, and security of your code.</li><li name="d71c" id="d71c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">Lexical Environment</strong></code>Â : Consists of any variables available within the scope in which a closure was declared (local inner, outer, and global).</li></ul><h3 name="cc5c" id="cc5c" class="graf graf--h3 graf-after--li"><strong class="markup--strong markup--h3-strong">Closures and Scope</strong><br>Basic ClosureÂ Rules:</h3><figure name="2af7" id="2af7" class="graf graf--figure graf--layoutOutsetLeft graf-after--h3"><img class="graf-image" data-image-id="0*iyFQ5y0LysnsrvOc.png" data-width="544" data-height="389" src="https://cdn-images-1.medium.com/max/600/0*iyFQ5y0LysnsrvOc.png"></figure><ul class="postList"><li name="cb9d" id="cb9d" class="graf graf--li graf-after--figure">Closures have access to all variables in itâ€™s lexical environment.</li><li name="f579" id="f579" class="graf graf--li graf-after--li">A closure will keep reference to all the variables when it was defined <strong class="markup--strong markup--li-strong">even if the outer function has returned</strong>.</li></ul><p name="881e" id="881e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Applications of Closures</strong></p><ul class="postList"><li name="12de" id="12de" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Private State</strong></li><li name="f3e5" id="f3e5" class="graf graf--li graf-after--li">JS does not have a way of declaring a function as exclusively private, however we can use closures to make a private state.</li><li name="dbf8" id="dbf8" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Passing Arguments Implicitly</strong></li><li name="f07b" id="f07b" class="graf graf--li graf-after--li">We can use closures to pass down arguments to helper functions.</li></ul><figure name="0cf1" id="0cf1" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/bgoonz/d553f093450bcf8dbe402674ec419d84.js"></script></figure><h3 name="7159" id="7159" class="graf graf--h3 graf-after--figure">OVERVIEW</h3><p name="e582" id="e582" class="graf graf--p graf-after--h3">Letâ€™s look at the Window/Console in a browser/node environment. Type <code class="markup--code markup--p-code">window</code> to your chrome console. JavaScript is executed in this context, also known as the <code class="markup--code markup--p-code">global scope</code>.</p><p name="220c" id="220c" class="graf graf--p graf-after--p">There are two types of scope in javascript, <code class="markup--code markup--p-code">Global Vs. Local</code> and that this is important to understand in terms of a computer program written in JavaScript.</p><p name="aeb7" id="aeb7" class="graf graf--p graf-after--p">When a function is declared and created, a new <code class="markup--code markup--p-code">scope</code> is also created. Any variables declared within that function&#39;s scope will be <code class="markup--code markup--p-code">enclosed</code> in a lexical/private scope that belongs to that function. Also, it is important to remember that functions look <code class="markup--code markup--p-code">outward</code> for context. If some variable isn&#39;t defined in a function&#39;s scope, the function will look outside the scope chain and search for a variable being referenced in the outer scope. This is what closure is all about.</p><p name="76ec" id="76ec" class="graf graf--p graf-after--p">In itâ€™s most simplest of forms this is a closure:</p><pre name="ec5d" id="ec5d" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const foo = &#39;bar&#39;;<br>function returnFoo () {<br>  return foo;<br>}<br>returnFoo();<br>// -&gt; reaches outside its scope to find foo because it doesn&#39;t exist inside of return Foo&#39;s scope when foo is referenced.</code></pre><p name="4a8e" id="4a8e" class="graf graf--p graf-after--pre">The function body (code inside returnFoo) has access to the outside scope (code outside of returnFoo) and can access that â€˜fooâ€™ variable.</p><p name="8969" id="8969" class="graf graf--p graf-after--p">Letâ€™s look at another example:</p><pre name="89b2" id="89b2" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const lastName = &#39;Bob&#39;;<br>function greet() {<br>  const firstName = &#39;Jim&#39;;<br>  alert(`The name&#39;s ${lastName}, ${firstName} ${lastName}`);<br>}<br>console.log(lastName);</code></pre><p name="477b" id="477b" class="graf graf--p graf-after--pre">Not much different than the idea presented above, but the thought remains the same. When â€˜greetâ€™ is called, it has no context in its local scope of finding <code class="markup--code markup--p-code">lastName</code> so, it looks outside its scope to find it and use the <code class="markup--code markup--p-code">lastName</code> that is found there.</p><p name="b077" id="b077" class="graf graf--p graf-after--p">Letâ€™s take this a step further. In the given examples, weâ€™ve seen that we have created two environments for our code. The first would be the global environment where <code class="markup--code markup--p-code">lastName</code> and <code class="markup--code markup--p-code">greet</code> exist. The second would be the local environment where the alert function is called. Let&#39;s represent those two environments like this:</p><figure name="ea3f" id="ea3f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/bb198dcd742ddef1f9c2db1a66fa8fe0.js"></script></figure><figure name="cd0d" id="cd0d" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="0*fpIwHvwpDYxatfE9.png" data-width="1060" data-height="440" src="https://cdn-images-1.medium.com/max/800/0*fpIwHvwpDYxatfE9.png"></figure><h3 name="bb8c" id="bb8c" class="graf graf--h3 graf-after--figure">What is aÂ closure?</h3><p name="4275" id="4275" class="graf graf--p graf-after--h3">A closure is an inner function that has access to the outer (enclosing) functionâ€™s variablesâ€Šâ€”â€Šscope chain. The closure has three scope chains: it has access to its own scope (variables defined between its curly brackets), it has access to the outer functionâ€™s variables, and it has access to the global variables.</p><p name="1202" id="1202" class="graf graf--p graf-after--p">The inner function has access not only to the outer functionâ€™s variables, but also to the outer functionâ€™s parameters. Note that the inner function cannot call the outer functionâ€™s arguments object, however, even though it can call the outer functionâ€™s parameters directly.</p><p name="cde5" id="cde5" class="graf graf--p graf-after--p">You create a closure by adding a function inside another function.</p><p name="2cea" id="2cea" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">A Basic Example:</strong></p><figure name="5e55" id="5e55" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/dbb08d456e801829533fea731083d176.js"></script></figure><h3 name="ba52" id="ba52" class="graf graf--h3 graf-after--figure">Scope chain</h3><p name="c861" id="c861" class="graf graf--p graf-after--h3">Every scope has a link to the parent scope. When a variable is used, JavaScript looks down the scope chain until it either finds the requested variable or until it reaches the global scope, which is the end of the scope chain.</p><h3 name="06e5" id="06e5" class="graf graf--h3 graf-after--p">Context in JavaScript</h3><ul class="postList"><li name="ac33" id="ac33" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">Scope</strong></code>Â : Refers to the visibility and availability of variables.</li><li name="3117" id="3117" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">Context</strong></code>Â : Refers to the value of the <code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">this</strong></code> keyword when code is executed.</li></ul><p name="51b2" id="51b2" class="graf graf--p graf-after--li">Every function invocation has both a scope and a context. Even though technically functions are objects in JS, you can think of scope as pertaining to functions in which a variable was defined, and context as the object on which some variable or method (function) may exist. Scope describes a function has access to when it is invoked (unique to each invocation). Context is always the value of the <code class="markup--code markup--p-code">this</code> keyword which in turn is a reference to the object that a piece of code exists within.</p><p name="c530" id="c530" class="graf graf--p graf-after--p">Context is most often determined by how a function is invoked. When a function is called as a method of an object, <code class="markup--code markup--p-code">this</code> is set to the object the method is called on:</p><h3 name="78f9" id="78f9" class="graf graf--h3 graf-after--p"><code class="markup--code markup--h3-code"><strong class="markup--strong markup--h3-strong">this</strong></code><strong class="markup--strong markup--h3-strong">Â ?</strong></h3><ul class="postList"><li name="2c6d" id="2c6d" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">This</strong></code>Â : Keyword that exists in every function and evaluates to the object that is currently invoking that function.</li><li name="2b18" id="2b18" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Method-Style Invocation</strong>Â : syntax goes like <code class="markup--code markup--li-code">object.method(arg)</code>. (i.e. array.push, str.toUpperCase()</li><li name="17bb" id="17bb" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">Context</strong></code> refers to the value of this within a function and <code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">this</strong></code> refers to where a function is invoked.</li></ul><p name="206f" id="206f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Issues with Scope and Context</strong></p><ul class="postList"><li name="dd07" id="dd07" class="graf graf--li graf-after--p">If <code class="markup--code markup--li-code">this</code> is called using normal function style invocation, our output will be the contents of the global object.</li></ul><p name="16d1" id="16d1" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">When Methods have an Unexpected Context</strong></p><figure name="7c2c" id="7c2c" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/ecca5a88f2b77562321889c175c77ee5.js"></script></figure><ul class="postList"><li name="bf17" id="bf17" class="graf graf--li graf-after--figure">In the above example we get undefined when we assign our this function to a variable bc there is no obj to reference except the global one!</li></ul><p name="3fc2" id="3fc2" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Strictly Protecting the Global Object</strong></p><p name="6b63" id="6b63" class="graf graf--p graf-after--p">We can run JS in strict mode by tagging <code class="markup--code markup--p-code">use strict</code> at the top of our program.</p><ul class="postList"><li name="3c6e" id="3c6e" class="graf graf--li graf-after--p">If we try to invoke this on our global function in strict mode we will no longer be able to access it and instead just get undefined.</li></ul><p name="300a" id="300a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Changing Context using Bind</strong></p><p name="6bac" id="6bac" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">â€œThe simplest use of <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">bind()</strong></code> is to make a function that, no matter how it is called, is called with a particular this value&quot;.</p><figure name="e41f" id="e41f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/550835dfb10f803c6cbd16fd43e3e4e6.js"></script></figure><p name="f2bf" id="f2bf" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Binding with Arguments</strong></p><ul class="postList"><li name="208d" id="208d" class="graf graf--li graf-after--p">We can also use bind() to bind arguments to a function.</li></ul><figure name="0129" id="0129" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/bgoonz/84b650eeaee5806b592481e088b39ceb.js"></script></figure><h3 name="fd76" id="fd76" class="graf graf--h3 graf-after--figure">Arrow Functions (FatÂ Arrows)</h3><p name="9e46" id="9e46" class="graf graf--p graf-after--h3">side noteÂ â€¦ if you donâ€™t know what this means ignore itâ€¦ but if you write an arrow function that utilizes an implicit returnâ€¦ thatâ€™s roughly equivalent to what is referred to as a lambda function in other languages.</p><ul class="postList"><li name="4190" id="4190" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">=&gt;</strong></code>Â : A more concise way of declaring a function and also considers the behavior of <code class="markup--code markup--li-code">this</code> and context.</li></ul><p name="60df" id="60df" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Arrow Functions Solving Problems</strong></p><figure name="710e" id="710e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/37632cbc3e95bb4e8f52432bacbe7e52.js"></script></figure><p name="169c" id="169c" class="graf graf--p graf-after--figure">As you can see the arrow function is shorter and easier to read.</p><p name="0ca4" id="0ca4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Anatomy of an Arrow Function</strong></p><ul class="postList"><li name="a35b" id="a35b" class="graf graf--li graf-after--p">If there is only a single parameter there is no need to add parenthesis before the arrow function.</li><li name="e68f" id="e68f" class="graf graf--li graf-after--li">However if there are zero parameters then you must add an empty set of parentheses.</li></ul><p name="1888" id="1888" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Single Expression Arrow Functions</strong></p><ul class="postList"><li name="635b" id="635b" class="graf graf--li graf-after--p">Arrow functions, <em class="markup--em markup--li-em">unlike</em> normal functions, carry over context, binding <code class="markup--code markup--li-code">this</code> lexically.</li><li name="b4db" id="b4db" class="graf graf--li graf-after--li">Value of <code class="markup--code markup--li-code">this</code> inside an arrow function is not dependent on how it is invoked.</li><li name="4b3f" id="4b3f" class="graf graf--li graf-after--li graf--trailing">Because arrow functions already have a <em class="markup--em markup--li-em">bound context</em>, you canâ€™t reassign <code class="markup--code markup--li-code">this</code>.</li></ul></div></div></section><section name="f4a9" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="e311" id="e311" class="graf graf--h4 graf--leading">Phewhâ€¦ thatâ€™s a lotâ€¦ letâ€™s go over some of thatÂ again!</h4><h3 name="19df" id="19df" class="graf graf--h3 graf-after--h4">Block ScopeÂ Review:</h3><p name="7587" id="7587" class="graf graf--p graf-after--h3">Block scope is defined with curly braces. It is separated by <code class="markup--code markup--p-code">{</code> and <code class="markup--code markup--p-code">}</code>.</p><p name="0813" id="0813" class="graf graf--p graf-after--p">Variables declared with <code class="markup--code markup--p-code">let</code> and <code class="markup--code markup--p-code">const</code> can have block scope. They can only be accessed in the block in which they are defined.</p><p name="13f6" id="13f6" class="graf graf--p graf-after--p">Consider the next code that emphasizes <code class="markup--code markup--p-code">let</code> block scope:</p><pre name="9a75" id="9a75" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">let x = 1;<br>{ <br>  let x = 2;<br>}<br>console.log(x); //1</code></pre><p name="64f6" id="64f6" class="graf graf--p graf-after--pre">In contrast, the <code class="markup--code markup--p-code">var</code> declaration has no block scope:</p><pre name="602d" id="602d" class="graf graf--pre graf-after--p graf--trailing"><code class="markup--code markup--pre-code">var x = 1;<br>{ <br>  var x = 2;<br>}<br>console.log(x); //2</code></pre></div></div></section><section name="4355" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7ebc" id="7ebc" class="graf graf--h3 graf--leading">Closures Spaced Repetition</h3><p name="c5b4" id="c5b4" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">1. Closures have access to the outer functionâ€™s variable even after the outer function returns:</strong></p><p name="d66a" id="d66a" class="graf graf--p graf-after--p">One of the most important features with closures is that the inner function still has access to the outer functionâ€™s variables even after the outer function has returned.</p><p name="d923" id="d923" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">When functions in JavaScript execute, they use the same scope chain that was in effect when they were created.</strong></p><p name="4189" id="4189" class="graf graf--p graf-after--p">This means that even after the outer function has returned, the inner function still has access to the outer functionâ€™s variables. Therefore, you can call the inner function later in your program.</p><p name="2843" id="2843" class="graf graf--p graf-after--p">See here:</p><figure name="14d0" id="14d0" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/a5b33393142144f62ceec005890fbc6e.js"></script></figure><p name="5352" id="5352" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">2. Closures store references to the outer functionâ€™s variables:</strong></p><blockquote name="1b59" id="1b59" class="graf graf--blockquote graf-after--p">They do not store the actual value.</blockquote><p name="18ee" id="18ee" class="graf graf--p graf-after--blockquote">Closures get more interesting when the value of the outer functionâ€™s variable changes before the closure is called.</p><p name="ba9a" id="ba9a" class="graf graf--p graf-after--p">And this powerful feature can be harnessed in creative waysâ€¦namely private variables.</p><figure name="1d47" id="1d47" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/63ebd231760390207e0c6332421ed73f.js"></script></figure><p name="add7" id="add7" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">3. Closures Gone Bad</strong></p><p name="5abc" id="5abc" class="graf graf--p graf-after--p">Because closures have access to the updated values of the outer functionâ€™s variables, they can also lead to bugs when the outer functionâ€™s variable changes with a for loop.</p><p name="45d3" id="45d3" class="graf graf--p graf-after--p">For example:</p><figure name="881b" id="881b" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/52a9664ce17b072b6157543adae4bb96.js"></script></figure><p name="cf7b" id="cf7b" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--figure"><span class="graf-dropCap">C</span>closure is a word we use to refer to the context of a given function. Normally our function starts from scratch every time we run it.</p><p name="ca5b" id="ca5b" class="graf graf--p graf-after--p">However, if we were to return a function from <code class="markup--code markup--p-code">addOne()</code> that referenced <code class="markup--code markup--p-code">counter</code>, counter would become part of the context of that new function, even after <code class="markup--code markup--p-code">addOne()</code> finishes executing. This is easier to see in code than to explain in words:</p><figure name="d493" id="d493" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/f1cf6457948c70e326f4081e44bb0832.js"></script></figure><p name="083b" id="083b" class="graf graf--p graf-after--figure">This works! we only instantiate counter when <code class="markup--code markup--p-code">createAdder()</code> is called, but it&#39;s value gets updated whenever the function it returns is called.</p><blockquote name="3a84" id="3a84" class="graf graf--blockquote graf-after--p">We say that this inner function is closed around the variable <code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">counter</em></code></blockquote><blockquote name="1293" id="1293" class="graf graf--blockquote graf-after--blockquote graf--trailing">Definition<em class="markup--em markup--blockquote-em">: (According to MDN) A closure is the combination of a function and the lexical environment within which that function was declared.</em></blockquote></div></div></section><section name="933f" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9135" id="9135" class="graf graf--h3 graf--leading">Global Scope Spaced Repetition:</h3><p name="b030" id="b030" class="graf graf--p graf-after--h3">Scope in JavaScript works like it does in most languages. If something is defined at the root level, thatâ€™s global scopeâ€Šâ€”â€Šwe can <em class="markup--em markup--p-em">access (and modify)</em> that variable from anywhere. If itâ€™s a function we defined, we can <em class="markup--em markup--p-em">call</em> it from anywhere.</p><figure name="cb64" id="cb64" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/99dce5241259da9f2982d6e8c84acd7d.js"></script></figure><h3 name="aaee" id="aaee" class="graf graf--h3 graf-after--figure">The Problem with GlobalÂ Scope</h3><p name="b112" id="b112" class="graf graf--p graf-after--h3">So it seems we should declare all of our variables at the global scope.</p><blockquote name="3053" id="3053" class="graf graf--blockquote graf-after--p">Why could this be a problem?</blockquote><figure name="6ca2" id="6ca2" class="graf graf--figure graf--iframe graf-after--blockquote"><script src="https://gist.github.com/bgoonz/0fb383ae9e4dc4075a4f2b393bc375a1.js"></script></figure><p name="6d2c" id="6d2c" class="graf graf--p graf-after--figure">It seems reasonable to want <code class="markup--code markup--p-code">counter</code> to <em class="markup--em markup--p-em">only</em> be accessed/modified through our <code class="markup--code markup--p-code">addOne()</code> function, but if our variable is defined within the global scope, it&#39;s simply not so.</p><p name="d893" id="d893" class="graf graf--p graf-after--p">This may not seem like a major concernâ€Šâ€”â€Šwe can just make sure we donâ€™t access it directly.</p><p name="6b49" id="6b49" class="graf graf--p graf-after--p">We need some form of encapsulationâ€Šâ€”â€Ši.e. the data our function relies on is <em class="markup--em markup--p-em">completely</em> contained within the logic of that function</p><figure name="969d" id="969d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/81d4c33841cf7d7ef21d18af6418210c.js"></script></figure><h3 name="48d4" id="48d4" class="graf graf--h3 graf-after--figure">Inner Scope</h3><p name="c1ac" id="c1ac" class="graf graf--p graf-after--h3">OK, this seems to work as expected, however</p><blockquote name="4599" id="4599" class="graf graf--blockquote graf-after--p">What about inside of our <code class="markup--code markup--blockquote-code">addOne()</code> function?</blockquote><figure name="b99b" id="b99b" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="0*hCP3tX_zDtTQLRQT.png" data-width="1464" data-height="567" src="https://cdn-images-1.medium.com/max/800/0*hCP3tX_zDtTQLRQT.png"></figure><p name="fecd" id="fecd" class="graf graf--p graf-after--figure">Every function creates itâ€™s own local scope.</p><p name="1272" id="1272" class="graf graf--p graf-after--p">Compared to itâ€™s context (i.e. <em class="markup--em markup--p-em">where</em> our function is defined), we call this the inner scope</p><p name="b646" id="b646" class="graf graf--p graf-after--p">Our function can access/modify anything outside of itâ€™s scope, so the body of our function, <code class="markup--code markup--p-code">{ counter++; }</code>, has an effect that persists in the outside scope.</p><blockquote name="13b7" id="13b7" class="graf graf--blockquote graf-after--p">What about the other way aroundâ€¦Can global scope modify inner scope?</blockquote><figure name="ae07" id="ae07" class="graf graf--figure graf--iframe graf-after--blockquote"><script src="https://gist.github.com/bgoonz/a3d63f1a23af067d21665ffb2def89eb.js"></script></figure><p name="0e3c" id="0e3c" class="graf graf--p graf-after--figure">Because <code class="markup--code markup--p-code">counter</code> is <em class="markup--em markup--p-em">defined</em> within our function&#39;s scope, it doesn&#39;t exist within the global scope, so referencing it there doesn&#39;t make sense.</p><figure name="0862" id="0862" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="0*K-GktN0XO2Gw6BPK.png" data-width="637" data-height="220" src="https://cdn-images-1.medium.com/max/800/0*K-GktN0XO2Gw6BPK.png"></figure></div></div></section><section name="7ec4" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="783b" id="783b" class="graf graf--h3 graf--leading">Context vs.Â Scope</h3><p name="9861" id="9861" class="graf graf--p graf-after--h3">The first important thing to clear up is that context and scope are not the same. I have noticed many developers over the years often confuse the two terms (myself included), incorrectly describing one for the other.</p><p name="ea5f" id="ea5f" class="graf graf--p graf-after--p">Every function invocation has both a scope and a context associated with it.</p><p name="6174" id="6174" class="graf graf--p graf-after--p">To condense it down to a single concept, scope is function-based while context is object-based.</p><h4 name="3241" id="3241" class="graf graf--h4 graf-after--p">In other words, scope pertains to the variable access of a function when it is invoked and is unique to each invocation. Context is always the value of the <code class="markup--code markup--h4-code">this</code> keyword which is a reference to the object that &quot;owns&quot; the currently executing code.</h4><h3 name="aaa6" id="aaa6" class="graf graf--h3 graf-after--h4">Variable Scope</h3><p name="3921" id="3921" class="graf graf--p graf-after--h3">A variable can be defined in either local or global scope, which establishes the variablesâ€™ accessibility from different scopes during runtime.</p><p name="ef19" id="ef19" class="graf graf--p graf-after--p">Local variables exist only within the function body of which they are defined and will have a different scope for every call of that function. There it is subject for value assignment, retrieval, and manipulation only within that call and is not accessible outside of that scope.</p><p name="557f" id="557f" class="graf graf--p graf-after--p">ECMAScript 6 (ES6/ES2015) introduced the <code class="markup--code markup--p-code">let</code> and <code class="markup--code markup--p-code">const</code> keywords that support the declaration of block scope local variables.</p><p name="6183" id="6183" class="graf graf--p graf-after--p">This means the variable will be confined to the scope of a block that it is defined in, such as an <code class="markup--code markup--p-code">if</code> statement or <code class="markup--code markup--p-code">for</code> loop and will not be accessible outside of the opening and closing curly braces of the block.</p><p name="06b4" id="06b4" class="graf graf--p graf-after--p">This is contrary to <code class="markup--code markup--p-code">var</code> declarations which are accessible outside blocks they are defined in.</p><p name="56e8" id="56e8" class="graf graf--p graf-after--p">The difference between <code class="markup--code markup--p-code">let</code> and <code class="markup--code markup--p-code">const</code> is that a <code class="markup--code markup--p-code">const</code> declaration is, as the name implies, constant - a read-only reference to a value.</p><h4 name="bdad" id="bdad" class="graf graf--h4 graf-after--p">This does not mean the value is immutable, just that the variable identifier cannot be reassigned.</h4><h3 name="158b" id="158b" class="graf graf--h3 graf-after--h4">Closure Spaced Repetition:</h3><h4 name="5296" id="5296" class="graf graf--h4 graf-after--h3">recall:</h4><p name="80fd" id="80fd" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--h4"><span class="graf-dropCap">L</span><a href="https://www.educative.io/edpresso/lexical-scope-in-javascript" data-href="https://www.educative.io/edpresso/lexical-scope-in-javascript" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">exical scope</strong></a> is the ability for a function scope to access variables from the parent scope. We call the child function to be lexically bound by that of the parent function.</p><figure name="d0bd" id="d0bd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*5RWAkuw8fkbTV6MRabyfhQ.png" data-width="653" data-height="268" src="https://cdn-images-1.medium.com/max/800/1*5RWAkuw8fkbTV6MRabyfhQ.png"></figure><h3 name="0e83" id="0e83" class="graf graf--h3 graf-after--figure">AND</h3><p name="4154" id="4154" class="graf graf--p graf-after--h3">A <em class="markup--em markup--p-em">lexical environment</em> is an abstraction that holds <strong class="markup--strong markup--p-strong">identifier-variable mapping</strong>. I<strong class="markup--strong markup--p-strong">dentifier</strong> refers to the name of variables/functions, and <strong class="markup--strong markup--p-strong">the variable </strong>is the reference to actual object [including function object] or primitive value.</p><p name="907d" id="907d" class="graf graf--p graf-after--p">This is similar to an object with a method on itâ€¦</p><p name="b759" id="b759" class="graf graf--p graf-after--p">In the picture belowâ€¦ sayHi (and name) are identifiers and the function and (string â€œbryanâ€) are variable values.</p><figure name="29fb" id="29fb" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ewwHx4vO170sT3tneB--2A.png" data-width="229" data-height="155" src="https://cdn-images-1.medium.com/max/800/1*ewwHx4vO170sT3tneB--2A.png"></figure><h4 name="874e" id="874e" class="graf graf--h4 graf-after--figure">Accessing variables outside of the immediate lexical scope creates aÂ closure.</h4><p name="f667" id="f667" class="graf graf--p graf-after--h4">A closure is to put it simply, when a nested function is defined inside of another function gains access to the outer functions variables.</p><p name="286a" id="286a" class="graf graf--p graf-after--p">Returning the nested function from the â€˜parent functionâ€™ that enclosed the nested function definition, allows you to maintain access to the local variables, (arguments, and potentially even more inner function declarations) of its outer functionâ€¦ without exposing the variables or arguments of outer functionâ€¦. to any of the other functions that were not declared inside of it.</p><h3 name="2047" id="2047" class="graf graf--h3 graf-after--p">What is â€œthisâ€Â Context</h3><p name="89d3" id="89d3" class="graf graf--p graf-after--h3">Context is most often determined by how a function is invoked.</p><p name="cf2b" id="cf2b" class="graf graf--p graf-after--p">When a function is called as a method of an object, <code class="markup--code markup--p-code">this</code> is set to the object the method is called on:</p><figure name="1a72" id="1a72" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/20b5c7aa88397095c1ebad1d94d127f2.js"></script></figure><p name="181b" id="181b" class="graf graf--p graf-after--figure">The same principle applies when invoking a function with the <code class="markup--code markup--p-code">new</code> operator to create an instance of an object.</p><p name="494c" id="494c" class="graf graf--p graf-after--p">When invoked in this manner, the value of <code class="markup--code markup--p-code">this</code> within the scope of the function will be set to the newly created instance:</p><figure name="33fd" id="33fd" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/06c252c587fb190cc24e18da328c7e56.js"></script></figure><p name="4f14" id="4f14" class="graf graf--p graf-after--figure">When called as an unbound function, <code class="markup--code markup--p-code">this</code> will default to the global context or window object in the browser. However, if the function is executed in <em class="markup--em markup--p-em">strict mode</em>, the context will default to undefined.</p><h3 name="23af" id="23af" class="graf graf--h3 graf-after--p">Execution Context Spaced Repetition:</h3><p name="6200" id="6200" class="graf graf--p graf-after--h3">JavaScript is a single threaded language, meaning only one task can be executed at a time. When the JavaScript interpreter initially executes code, it first enters into a global execution context by default. Each invocation of a function from this point on will result in the creation of a new execution context.</p><p name="cfa1" id="cfa1" class="graf graf--p graf-after--p">This is where confusion often sets in, the term<strong class="markup--strong markup--p-strong"> â€œexecution contextâ€ is actually for all intents and purposes referring more to scope and not context.</strong></p><p name="1710" id="1710" class="graf graf--p graf-after--p">It is an unfortunate naming convention, however it is the terminology as defined by the ECMAScript specification, so weâ€™re kind of stuck with it.</p><p name="014c" id="014c" class="graf graf--p graf-after--p">Each time a new execution context is created it is appended to the top of the <em class="markup--em markup--p-em">execution stack (call stack).</em></p><p name="d820" id="d820" class="graf graf--p graf-after--p">The browser will always execute the current execution context that is atop the execution stack. Once completed, it will be removed from the top of the stack and control will return to the execution context below.</p><p name="22de" id="22de" class="graf graf--p graf-after--p">An execution context can be divided into a creation and execution phase. In the creation phase, the interpreter will first create a <em class="markup--em markup--p-em">variable object</em> that is composed of all the variables, function declarations, and arguments defined inside the execution context.</p><p name="042e" id="042e" class="graf graf--p graf-after--p">From there the <em class="markup--em markup--p-em">scope chain</em> is initialized next, and the value of <code class="markup--code markup--p-code">this</code> is determined last. Then in the execution phase, code is interpreted and executed.</p><ul class="postList"><li name="af9a" id="af9a" class="graf graf--li graf-after--p"><a href="https://javascript.info/closure" data-href="https://javascript.info/closure" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">source</a></li></ul><div name="d025" id="d025" class="graf graf--mixtapeEmbed graf-after--li"><a href="https://replit.com/@bgoonz/scope-closure-context" data-href="https://replit.com/@bgoonz/scope-closure-context" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://replit.com/@bgoonz/scope-closure-context"><strong class="markup--strong markup--mixtapeEmbed-strong">scope-closure-context</strong><br><em class="markup--em markup--mixtapeEmbed-em">To accompany my medium article on the subject</em>replit.com</a><a href="https://replit.com/@bgoonz/scope-closure-context" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="3cbfb835e6aa7ff5e9e1db7a6ab6266c" data-thumbnail-img-id="0*AbnpnDtkD4v6Kziu" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*AbnpnDtkD4v6Kziu);"></a></div><h3 name="8c59" id="8c59" class="graf graf--h3 graf-after--mixtapeEmbed">Resources</h3><p name="68e0" id="68e0" class="graf graf--p graf-after--h3"><a href="https://github.com/getify/You-Dont-Know-JS/tree/master/scope%20%26%20closures" data-href="https://github.com/getify/You-Dont-Know-JS/tree/master/scope%20%26%20closures" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">YDKJS</a></p><p name="d889" id="d889" class="graf graf--p graf-after--p"><a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/#variable-object" data-href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/#variable-object" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Dmitry Soshnikov, Javascript:Core</a></p><p name="64ed" id="64ed" class="graf graf--p graf-after--p"><a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" data-href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ECMA 262.3</a></p><p name="c12e" id="c12e" class="graf graf--p graf-after--p"><a href="https://stackoverflow.com/questions/111102/how-do-javascript-closures-work" data-href="https://stackoverflow.com/questions/111102/how-do-javascript-closures-work" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">StackOverflow</a></p><p name="3555" id="3555" class="graf graf--p graf-after--p"><a href="https://www.amazon.com/Professional-JavaScript-Developers-Nicholas-Zakas/dp/1118026691" data-href="https://www.amazon.com/Professional-JavaScript-Developers-Nicholas-Zakas/dp/1118026691" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Nick Zakas</a></p><h3 name="0eb1" id="0eb1" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="310d" id="310d" class="graf graf--p graf-after--h3">Variables defined in global scope are available everywhere in the application.</p><p name="09a3" id="09a3" class="graf graf--p graf-after--p">In a module, a variable declared outside any function is hidden and not available to other modules unless it is explicitly exported.</p><p name="2b8a" id="2b8a" class="graf graf--p graf-after--p">Function scope means that parameters and variables defined in a function are visible everywhere within the function</p><p name="b550" id="b550" class="graf graf--p graf-after--p">Variables declared with <code class="markup--code markup--p-code">let</code> and <code class="markup--code markup--p-code">const</code> have block scope. <code class="markup--code markup--p-code">var</code> doesnâ€™t have block scope.</p><h3 name="2c62" id="2c62" class="graf graf--h3 graf-after--p">CITAIONS:</h3><h4 name="9fc5" id="9fc5" class="graf graf--h4 graf-after--h3">1.) JavaScript <a href="https://medium.com/@marjanrab/javascript-scope-context-and-this-under-the-hood-43c32033c9f9" data-href="https://medium.com/@marjanrab/javascript-scope-context-and-this-under-the-hood-43c32033c9f9" class="markup--anchor markup--h4-anchor" target="_blank">Scope Context and â€˜thisâ€™ under theÂ hood</a></h4><h4 name="9c35" id="9c35" class="graf graf--h4 graf-after--h4">2.) MDN <a href="https://github.com/mdn/content" data-href="https://github.com/mdn/content" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">ContentÂ Repo:</a></h4><h4 name="d49f" id="d49f" class="graf graf--h4 graf-after--h4">3.) The Ultimate <a href="https://ui.dev/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/" data-href="https://ui.dev/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">Guide to Hoisting, Scopes, and Closures in JavaScript</a></h4><h4 name="3373" id="3373" class="graf graf--h4 graf-after--h4">4.) Deep <a href="https://www.freecodecamp.org/news/deep-dive-into-scope-chains-and-closures-21ee18b71dd9/" data-href="https://www.freecodecamp.org/news/deep-dive-into-scope-chains-and-closures-21ee18b71dd9/" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">dive into Scope Chains andÂ Closures</a></h4><h4 name="679a" id="679a" class="graf graf--h4 graf-after--h4">5.) A <a href="https://dmitripavlutin.com/simple-explanation-of-javascript-closures/" data-href="https://dmitripavlutin.com/simple-explanation-of-javascript-closures/" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">Simple Explanation of JavaScript Closures</a></h4><h4 name="10c2" id="10c2" class="graf graf--h4 graf-after--h4">6.) <a href="https://blog.bitsrc.io/hoisting-in-modern-javascript-let-const-and-var-b290405adfda" data-href="https://blog.bitsrc.io/hoisting-in-modern-javascript-let-const-and-var-b290405adfda" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">JavaScript.info Hoisting</a></h4><h4 name="d7e1" id="d7e1" class="graf graf--h4 graf-after--h4">7.) <a href="https://www.freecodecamp.org/news/an-introduction-to-scope-in-javascript-cbd957022652/" data-href="https://www.freecodecamp.org/news/an-introduction-to-scope-in-javascript-cbd957022652/" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">An introduction to scope in JavaScript</a></h4><h4 name="f9cc" id="f9cc" class="graf graf--h4 graf-after--h4">8.) <a href="https://dev.to/johnwolfe820/should-you-never-truly-use-var-bdi" data-href="https://dev.to/johnwolfe820/should-you-never-truly-use-var-bdi" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">Should You Truly Never UseÂ Var?</a></h4><h4 name="7546" id="7546" class="graf graf--h4 graf-after--h4">9.) <a href="https://stackoverflow.com/questions/111102/how-do-javascript-closures-work" data-href="https://stackoverflow.com/questions/111102/how-do-javascript-closures-work" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">How do JavaScript closuresÂ work?</a></h4><h3 name="d08e" id="d08e" class="graf graf--h3 graf-after--h4">Check out myÂ blog!</h3><div name="a815" id="a815" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://best-celery-b2d7c.netlify.app/" data-href="https://best-celery-b2d7c.netlify.app/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://best-celery-b2d7c.netlify.app/"><strong class="markup--strong markup--mixtapeEmbed-strong">Web-Dev-Hub</strong><br><em class="markup--em markup--mixtapeEmbed-em"> preview of the Web-Dev-Hub</em>best-celery-b2d7c.netlify.app</a><a href="https://best-celery-b2d7c.netlify.app/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="bd673859c8b5712a866f715624951ade" data-thumbnail-img-id="0*uVKKJlY2PuLQQjcG" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*uVKKJlY2PuLQQjcG);"></a></div><h3 name="8baa" id="8baa" class="graf graf--h3 graf-after--mixtapeEmbed">Ask Me Anything:</h3><div name="ab69" id="ab69" class="graf graf--mixtapeEmbed graf-after--h3 graf--trailing"><a href="https://github.com/bgoonz/ask-me-anything" data-href="https://github.com/bgoonz/ask-me-anything" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/bgoonz/ask-me-anything"><strong class="markup--strong markup--mixtapeEmbed-strong">bgoonz/ask-me-anything</strong><br><em class="markup--em markup--mixtapeEmbed-em">I get questions by email, occasionally. This way anyone can read the answer! Anything means anything. Personalâ€¦</em>github.com</a><a href="https://github.com/bgoonz/ask-me-anything" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="3ecd74db0e42702bc81735b3a7e3b220" data-thumbnail-img-id="0*R4JDUaFH6b6B1bkB" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*R4JDUaFH6b6B1bkB);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bryanguner" class="p-author h-card">Bryan Guner</a> on <a href="https://medium.com/p/f126f1523104"><time class="dt-published" datetime="2021-05-30T10:00:41.695Z">May 30, 2021</time></a>.</p><p><a href="https://medium.com/@bryanguner/scope-closures-context-in-javascript-f126f1523104" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 10, 2021.</p></footer></article></body></html>