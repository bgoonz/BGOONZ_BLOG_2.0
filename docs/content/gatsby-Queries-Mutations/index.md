This app works best with JavaScript enabled.

[![webdevhub logo](https://d33wubrfki0l68.cloudfront.net/71199c39f8515c2ec6a7db98b837a0f39887ecc3/5558d/images/logo-circle.png)](/)

<span class="screen-reader-text">Open Menu</span><span class="icon-close" aria-hidden="true"></span>

- <a href="/docs/sitemap" class="button">Navigation</a>
  <span class="icon-angle-right" aria-hidden="true"></span><span class="screen-reader-text">Sub-menu</span>

  - <a href="/docs" class="button">Docs</a>
  - <a href="/showcase" class="button">Showcase</a>
  - <a href="/docs/faq/contact" class="button">Contact!</a>
  - <a href="/docs/python/python-ds" class="button">Python</a>

- <a href="/blog/" class="button">Blog</a>
  <span class="icon-angle-right" aria-hidden="true"></span><span class="screen-reader-text">Sub-menu</span>

  - <a href="https://bgoonz.blogspot.com/" class="button">Blog-Post-Archive</a>
  - <a href="https://blog-w-comments.vercel.app/" class="button">Top Blog Posts</a>
  - <a href="/docs/articles/ds-algo-overview/" class="button">ds-algo</a>
  - <a href="/blog/platform-docs/" class="button">platform docs</a>
  - <a href="/docs/articles/nodejs/" class="button">nodejs</a>
  - <a href="/blogWcomments/" class="button">Blog w Comments</a>

- <a href="https://github.com/bgoonz/UsefulResourceRepo2.0" class="button">Archive</a>
  <span class="icon-angle-right" aria-hidden="true"></span><span class="screen-reader-text">Sub-menu</span>

  - <a href="https://bryanguner.medium.com/" class="button">Medium Articles</a>
  - <a href="https://github.com/bgoonz/Learning-Assets" class="button">Resource-Archive-Server</a>
  - <a href="#" class="button">Bootcamp Resources</a>
  - <a href="https://web-dev-resource-hub.netlify.app/" class="button">OG-Blog</a>
  - <a href="/docs/gallery" class="button">Gallery</a>
  - <a href="/docs" class="button">Top Repos</a>

- <a href="/docs/audio/audio" class="button">Audio</a>
  <span class="icon-angle-right" aria-hidden="true"></span><span class="screen-reader-text">Sub-menu</span>

  - <a href="/docs/audio/audio" class="button">DTW-guitar-effects</a>
  - <a href="/docs/audio/dfft" class="button">Fast Fourier Transform</a>

- <a href="https://project-portfolio42.netlify.app/" class="button">Projects</a>
  <span class="icon-angle-right" aria-hidden="true"></span><span class="screen-reader-text">Sub-menu</span>

  - <a href="https://potluck-landing.netlify.app/" class="button">Potluck Planner</a>
  - <a href="https://meditate42app.netlify.app/" class="button">Meditation App</a>
  - <a href="https://panoramic-eggplant-452e4.netlify.app/" class="button">WebAudioLab</a>
  - <a href="https://bgoonz.github.io/searchAwesome/" class="button">SearchAwesome</a>
  - <a href="https://bg-portfolio.netlify.app/" class="button">Condensed -Portfolio</a>

- <a href="https://bgoonz-blog-v3-0.netlify.app/" class="button">External Nav</a>
  <span class="icon-angle-right" aria-hidden="true"></span><span class="screen-reader-text">Sub-menu</span>

  - <a href="https://friendly-panda-b61ab.netlify.app/" class="button">Embeds Blog</a>
  - <a href="https://bgoonz-blog-v3-0.netlify.app/" class="button">alt-blogs</a>
  - <a href="https://bgoonz-games.netlify.app/" class="button">Games</a>
  - <a href="https://bgoonz-blog-v3-0.netlify.app/" class="button">Blog Backup</a>
  - <a href="https://bgoonz-cv.netlify.app/" class="button">Cover Letter</a>
  - <a href="https://project-portfolio42.netlify.app/" class="button">Project Centric</a>
  - <a href="https://web-dev-hub.com/" class="button">Wordpress Blog</a>
  - <a href="https://project-portfolio42.netlify.app/" class="button">Project Portfolio Gallery</a>
  - <a href="https://bgoonz.github.io/github-stats-website/" class="button">github-stats-website</a>

- <a href="/docs/tools" class="button">Tools</a>
  <span class="icon-angle-right" aria-hidden="true"></span><span class="screen-reader-text">Sub-menu</span>
  - <a href="https://githtmlpreview.netlify.app/" class="button">Github HTML Previewer</a>
  - <a href="https://devtools42.netlify.app/" class="button">Text Tools</a>
  - <a href="https://ternary42.netlify.app/" class="button">Ternary 2 If Else</a>
  - <a href="https://determined-dijkstra-ee7390.netlify.app/" class="button">Job Search Resources</a>
  - <a href="https://github.com/bgoonz/web-dev-setup-checker" class="button">Setup Checker</a>
  - <a href="https://potluck-landing.netlify.app/" class="button">PotluckPlanner</a>
  - <a href="https://web-dev-interview-prep-quiz-website.netlify.app/" class="button">WebDev Quizzes</a>
  - <span class="screen-reader-text">Github-Advanced-Search</span>

<span class="screen-reader-text">Close Menu</span><span class="icon-menu" aria-hidden="true"></span>

Navigate Docs<span class="icon-angle-right" aria-hidden="true"></span>

- [Docs](/docs/)
- [About](/docs/about/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>

  - [Job Search](/docs/about/job-search/)
  - [Youtube](/docs/about/intrests/)
  - [Resume](/docs/about/resume/)
  - [Engineering Portfolio](/docs/about/eng-portfolio/)
  - [My Hobbies & Interests](/docs/about/hobbies-n-interests/)

- [Articles](/docs/articles/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>

  - [The HTTP Protocol](/docs/articles/http/)
  - [How The Web Works](/docs/articles/how-the-web-works/)
  - [Sorting Algorithms](/docs/articles/node-package-manager/)
  - [Introduction to npm](/docs/articles/npm/)
  - [Firebase](/docs/articles/understanding-firebase/)
  - [The Uniform Resource Locator (URL)](</docs/articles/the-uniform-resource-locator-(url)/>)
  - [lorem-ipsum](/docs/articles/semantic-html/)
  - [Web Standards Checklist](/docs/articles/web-standards-checklist/)
  - [Web Developer Tools](/docs/articles/webdev-tools/)
  - [where-is-npm-pack](/docs/articles/node-cli-args/)
  - [The-package-lock.json-file](/docs/articles/node-repl/)
  - [node-cli-args](/docs/articles/node-run-cli/)
  - [Node Export Module](/docs/articles/node-env-variables/)
  - [npm global or local packages](/docs/articles/v8/)
  - [packagejson](/docs/articles/node-js-language/)
  - [Common Modules](/docs/articles/node-common-modules/)
  - [Node Buffers](/docs/articles/buffers/)
  - [Dev Dependencies](/docs/articles/dev-dep/)
  - [The Node.js Event Loop](/docs/articles/event-loop/)
  - [Web Dev Review](/docs/articles/basic-web-dev/)
  - [Fs-Module](/docs/articles/fs-module/)
  - [Install](/docs/articles/install/)
  - [Intro To Node](/docs/articles/intro/)
  - [module-exports](/docs/articles/module-exports/)
  - [Javascript and Node](/docs/articles/nodejs/)
  - [The npx Node.js Package Runner](/docs/articles/npx/)
  - [Node vs Browser](/docs/articles/nodevsbrowser/)
  - [Reading Files](/docs/articles/reading-files/)
  - [OS-Module](/docs/articles/os-module/)
  - [Semantic Versioning](/docs/articles/semantic/)
  - [Writing Files](/docs/articles/writing-files/)
  - [Node APIs With Express](/docs/articles/node-api-express/)

- [Audio](/docs/audio/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>

  - [Audio Feature Extraction](/docs/audio/audio-feature-extraction/)
  - [Audio](/docs/audio/audio/)
  - [dynamic-time-warping](/docs/audio/dynamic-time-warping/)
  - [Dynamic Time Warping Algorithm Explained (Python)](/docs/audio/dtw-python-explained/)
  - [Discrete Fast Fourier Transform](/docs/audio/dfft/)
  - [Fast Fourier Transform](/docs/audio/discrete-fft/)

- [Community](/docs/community/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>

  - [Video Chat](/docs/community/video-chat/)

- [Content](/docs/content/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>

  - [RECENT PROJECTS](/docs/content/data-structures-algo/)
  - [History API](/docs/content/history-api/)
  - [Trouble Shooting](/docs/content/trouble-shooting/)
  - [Projects](/docs/content/projects/)
  - [Archive](/docs/content/archive/)
  - [Queries and Mutations (Gatsby)](/docs/content/gatsby-Queries-Mutations/)
  - [Embeded Websites & Projects](/docs/content/recent-projects/)
  - [Algorithms & Data Structures](/docs/content/algo/)

- [Documentation](/docs/docs/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>

  - [lorem-ipsum](/docs/docs/what-does-it-mean-2-render/)
  - [Bash Commands That Save Me Time and Frustration](/docs/docs/bash/)
  - [Apendix](/docs/docs/appendix/)
  - [Await](/docs/docs/await-keyword/)
  - [Git Reference](/docs/docs/git-reference/)
  - [Data Structures Docs](/docs/docs/data-structures-docs/)
  - [Git Repo List](/docs/docs/git-repos/)
  - [Markdown](/docs/docs/markdown/)
  - [Regular Expressions](/docs/docs/regex-in-js/)
  - [Sitemap](/docs/docs/sitemap/)
  - [Learn Css](/docs/docs/css/)
  - [Useful Snippets](/docs/docs/content/)
  - [lorem-ipsum](/docs/docs/no-whiteboarding/)

- [FAQ](/docs/faq/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>

  - [Plug-ins](/docs/faq/plug-ins/)
  - [Contact!](/docs/faq/contact/)

- [Javascript](/docs/javascript/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>

  - [lorem-ipsum](/docs/javascript/clean-code/)
  - [Javascript Concepts Review](/docs/javascript/review/)
  - [Constructor Functions](/docs/javascript/constructor-functions/)
  - [A Very Quick Guide To Calculating Big O Computational Complexity](/docs/javascript/bigo/)

- [Interactive Examples](/docs/interact/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>

  - [Callstack Visualizer](/docs/interact/callstack-visual/)
  - [Jupyter Notebooks](/docs/interact/jupyter-notebooks/)
  - [Zumzi Video Conferencing (Mesibo API Backend)](/docs/interact/video-chat/)
  - [Other Websites](/docs/interact/other-sites/)
  - [Clock](/docs/interact/clock/)

- [Medium](/docs/medium/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>

  - [My Sites](/docs/medium/my-websites/)
  - [Medium](/docs/medium/medium-links/)

- [Quick Reference](/docs/quick-reference/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>

  - [How To Reinstall NPM and Node.js On Your System](/docs/quick-reference/how-2-reinstall-npm/)
  - [Git Bash](/docs/quick-reference/git-bash/)
  - [Awesome Static Site Resources](/docs/quick-reference/awesome-static/)
  - [lorem-ipsum](/docs/quick-reference/markdown-dropdowns/)
  - [Heroku Error Codes](/docs/quick-reference/heroku-error-codes/)
  - [Quick Links](/docs/quick-reference/quick-links/)
  - [Postgresql Cheat Sheet](/docs/quick-reference/psql/)
  - [PostgreSQL Setup](/docs/quick-reference/psql-setup/)
  - [Pull Request Template](/docs/quick-reference/pull-request-rubric/)
  - [Understanding PATH](/docs/quick-reference/understanding-path/)
  - [Developer Resources](/docs/quick-reference/resources/)
  - [How To Minify Code For Better Web Performance](/docs/quick-reference/minifiction/)
  - [Top Repos](/docs/quick-reference/topRepos/)
  - [Firebase (Firebasics)](/docs/quick-reference/google-firebase/)
  - [Installation](/docs/quick-reference/installation/)
  - [Awesome Lists](/docs/quick-reference/awesome-lists/)
  - [Github Search](/docs/quick-reference/github-search/)
  - [new-repo-git](/docs/quick-reference/new-repo-instructions/)
  - [Notes Template](/docs/quick-reference/notes-template/)
  - [vscode](/docs/quick-reference/vscode/)
  - [Emmet Cheat Sheet](/docs/quick-reference/Emmet/)
  - [Getting Started W Create React App](/docs/quick-reference/create-react-app/)
  - [vscode-themes](/docs/quick-reference/vscode-themes/)

- [React](/docs/react/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>

  - [React Cheat Sheets:](/docs/react/cheatsheet/)
  - [React Class Components Demo](/docs/react/demo/)
  - [Introducing JSX](/docs/react/jsx/)
  - [Rendering Elements With React](/docs/react/render-elements/)
  - [React In Depth](/docs/react/react-in-depth/)
  - [Intro To React](/docs/react/react2/)
  - [npx-create-react-app](/docs/react/createReactApp/)
  - [React Docs](/docs/react/react-docs/)

- [Tools](/docs/tools/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>

  - [Data Structures](/docs/tools/data-structures/)
  - [General Utilities](/docs/tools/dev-utilities/)
  - [more tools](/docs/tools/more-tools/)
  - [The google cloud cheat sheet](/docs/tools/cloudstorage/)
  - [md and html](/docs/tools/markdown-html/)

- [My Python Docs](/docs/python/)
  <span class="screen-reader-text">Submenu</span><span class="icon-angle-right" aria-hidden="true"></span>
  - [lorem-ipsum](/docs/python/basics/)
  - [lorem-ipsum](/docs/python/flow-control/)
  - [google-sheets-api](/docs/python/google-sheets-api/)
  - [lorem-ipsum](/docs/python/functions/)
  - [lorem-ipsum](/docs/python/intro-for-js-devs/)
  - [Practice](/docs/python/examples/)
  - [Python General Notes](/docs/python/python-ds/)
  - [Python Cheat Sheet](/docs/python/cheat-sheet/)
  - [lorem-ipsum](/docs/python/comprehensive-guide/)
  - [Python Snippets](/docs/python/snippets/)
  - [Python at length](/docs/python/at-length/)

# Queries and Mutations (Gatsby)

# Querying Data in Components using StaticQuery

## TABLE OF CONTENTS

- [How to use StaticQuery in components](https://www.gatsbyjs.com/docs/how-to/querying-data/static-query/#how-to-use-staticquery-in-components)

  - [Basic example](https://www.gatsbyjs.com/docs/how-to/querying-data/static-query/#basic-example)
  - [useStaticQuery](https://www.gatsbyjs.com/docs/how-to/querying-data/static-query/#usestaticquery)
  - [Typechecking](https://www.gatsbyjs.com/docs/how-to/querying-data/static-query/#typechecking)

- [How StaticQuery differs from page query](https://www.gatsbyjs.com/docs/how-to/querying-data/static-query/#how-staticquery-differs-from-page-query)

Gatsby v2 introduces `StaticQuery`, a new API that allows components to retrieve data via a GraphQL query.

In this guide, you'll see an example using `StaticQuery`, and learn about [the difference between a StaticQuery and a page query](https://www.gatsbyjs.com/docs/how-to/querying-data/static-query/#how-staticquery-differs-from-page-query).

## [](https://www.gatsbyjs.com/docs/how-to/querying-data/static-query/#how-to-use-staticquery-in-components)How to use `StaticQuery` in components

_Video hosted on [egghead.io](https://egghead.io/lessons/gatsby-load-data-using-graphql-queries-directly-in-a-gatsby-v2-component-with-staticquery)_.

### [](https://www.gatsbyjs.com/docs/how-to/querying-data/static-query/#basic-example)Basic example

Here is an example of a `Header` component using `StaticQuery`:

src/components/header.js

Copysrc/components/header.js: copy code to clipboard\`

import React from "react"

import { StaticQuery, graphql } from "gatsby"

export default function Header() {

return (

&lt;StaticQuery

query={graphql\`

query HeadingQuery {

site {

siteMetadata {

title

}

}

}

\`}

render={data =&gt; (

# {data.site.siteMetadata.title}

)}

/&gt;

)

}

\`

By using `StaticQuery`, you can colocate a component with its data. It is no longer required to, say, pass data down from `Layout` to `Header`.

### [](https://www.gatsbyjs.com/docs/how-to/querying-data/static-query/#usestaticquery)useStaticQuery

There's also a React hooks version of StaticQuery: check out the documentation on [`useStaticQuery`](https://www.gatsbyjs.com/docs/how-to/querying-data/use-static-query/)

### [](https://www.gatsbyjs.com/docs/how-to/querying-data/static-query/#typechecking)Typechecking

With the above pattern, you lose the ability to typecheck with PropTypes. To regain typechecking while achieving the same result, you can change the component to:

src/components/header.js

Copysrc/components/header.js: copy code to clipboard\`

import React from "react"

import { StaticQuery, graphql } from "gatsby"

import PropTypes from "prop-types"

const Header = ({ data }) =&gt; (

# {data.site.siteMetadata.title}

)

export default function MyHeader(props) {

return (

&lt;StaticQuery

query={graphql\`

query {

site {

siteMetadata {

title

}

}

}

\`}

render={data =&gt; &lt;Header data={data} {...props} /&gt;}

/&gt;

)

}

Header.propTypes = {

data: PropTypes.shape({

site: PropTypes.shape({

siteMetadata: PropTypes.shape({

title: PropTypes.string.isRequired,

}).isRequired,

}).isRequired,

}).isRequired,

}

\`

## [](https://www.gatsbyjs.com/docs/how-to/querying-data/static-query/#how-staticquery-differs-from-page-query)How StaticQuery differs from page query

StaticQuery can do most of the things that page query can, including fragments. The main differences are:

- page queries can accept variables (via `pageContext`) but can only be added to *page* components
- StaticQuery does not accept variables (hence the name "static"), but can be used in *any* component, including pages
- StaticQuery does not work with raw React.createElement calls; please use JSX, e.g. `<StaticQuery />`

# GraphQL

# Queries and Mutations

On this page, you'll learn in detail about how to query a GraphQL server.

## Fields[](https://graphql.org/learn/queries/#fields)

At its simplest, GraphQL is about asking for specific fields on objects. Let's start by looking at a very simple query and the result we get when we run it:

{

hero {

name

}

}

{

"data": {

"hero": {

"name": "R2-D2"

}

}

}

You can see immediately that the query has exactly the same shape as the result. This is essential to GraphQL, because you always get back what you expect, and the server knows exactly what fields the client is asking for.

The field `name` returns a `String` type, in this case the name of the main hero of Star Wars, `"R2-D2"`.

> Oh, one more thing - the query above is *interactive*. That means you can change it as you like and see the new result. Try adding an `appearsIn` field to the `hero` object in the query, and see the new result.

In the previous example, we just asked for the name of our hero which returned a String, but fields can also refer to Objects. In that case, you can make a *sub-selection* of fields for that object. GraphQL queries can traverse related objects and their fields, letting clients fetch lots of related data in one request, instead of making several roundtrips as one would need in a classic REST architecture.

{

hero {

name

# Queries can have comments!

friends {

name

}

}

}

{

"data": {

"hero": {

"name": "R2-D2",

"friends": \[

{

"name": "Luke Skywalker"

},

{

"name": "Han Solo"

},

{

"name": "Leia Organa"

}

\]

}

}

}

Note that in this example, the `friends` field returns an array of items. GraphQL queries look the same for both single items or lists of items, however we know which one to expect based on what is indicated in the schema.

## Arguments[](https://graphql.org/learn/queries/#arguments)

If the only thing we could do was traverse objects and their fields, GraphQL would already be a very useful language for data fetching. But when you add the ability to pass arguments to fields, things get much more interesting.

{

human(id: "1000") {

name

height

}

}

{

"data": {

"human": {

"name": "Luke Skywalker",

"height": 1.72

}

}

}

In a system like REST, you can only pass a single set of arguments - the query parameters and URL segments in your request. But in GraphQL, every field and nested object can get its own set of arguments, making GraphQL a complete replacement for making multiple API fetches. You can even pass arguments into scalar fields, to implement data transformations once on the server, instead of on every client separately.

{

human(id: "1000") {

name

height(unit: FOOT)

}

}

{

"data": {

"human": {

"name": "Luke Skywalker",

"height": 5.6430448

}

}

}

Arguments can be of many different types. In the above example, we have used an Enumeration type, which represents one of a finite set of options (in this case, units of length, either `METER` or `FOOT`). GraphQL comes with a default set of types, but a GraphQL server can also declare its own custom types, as long as they can be serialized into your transport format.

[Read more about the GraphQL type system here.](https://graphql.org/learn/schema)

## Aliases[](https://graphql.org/learn/queries/#aliases)

If you have a sharp eye, you may have noticed that, since the result object fields match the name of the field in the query but don't include arguments, you can't directly query for the same field with different arguments. That's why you need *aliases* - they let you rename the result of a field to anything you want.

{

empireHero: hero(episode: EMPIRE) {

name

}

jediHero: hero(episode: JEDI) {

name

}

}

{

"data": {

"empireHero": {

"name": "Luke Skywalker"

},

"jediHero": {

"name": "R2-D2"

}

}

}

In the above example, the two `hero` fields would have conflicted, but since we can alias them to different names, we can get both results in one request.

## Fragments[](https://graphql.org/learn/queries/#fragments)

Let's say we had a relatively complicated page in our app, which lets us look at two heroes side by side, along with their friends. You can imagine that such a query could quickly get complicated, because we would need to repeat the fields at least once - one for each side of the comparison.

That's why GraphQL includes reusable units called *fragments*. Fragments let you construct sets of fields, and then include them in queries where you need to. Here's an example of how you could solve the above situation using fragments:

{

leftComparison: hero(episode: EMPIRE) {

...comparisonFields

}

rightComparison: hero(episode: JEDI) {

...comparisonFields

}

}

​

fragment comparisonFields on Character {

name

appearsIn

friends {

name

}

}

{

"data": {

"leftComparison": {

"name": "Luke Skywalker",

"appearsIn": \[

"NEWHOPE",

"EMPIRE",

"JEDI"

\],

"friends": \[

{

"name": "Han Solo"

},

{

"name": "Leia Organa"

},

{

"name": "C-3PO"

},

{

"name": "R2-D2"

}

\]

},

"rightComparison": {

"name": "R2-D2",

"appearsIn": \[

"NEWHOPE",

"EMPIRE",

"JEDI"

\],

"friends": \[

{

"name": "Luke Skywalker"

},

{

"name": "Han Solo"

},

{

"name": "Leia Organa"

}

\]

}

}

}

You can see how the above query would be pretty repetitive if the fields were repeated. The concept of fragments is frequently used to split complicated application data requirements into smaller chunks, especially when you need to combine lots of UI components with different fragments into one initial data fetch.

### Using variables inside fragments[](https://graphql.org/learn/queries/#using-variables-inside-fragments)

It is possible for fragments to access variables declared in the query or mutation. See [variables](https://graphql.org/learn/queries/#variables).

query HeroComparison($first: Int = 3) {

leftComparison: hero(episode: EMPIRE) {

...comparisonFields

}

rightComparison: hero(episode: JEDI) {

...comparisonFields

}

}

​

fragment comparisonFields on Character {

name

friendsConnection(first: $first) {

totalCount

edges {

node {

name

}

}

}

}

​

{

"errors": \[

{

"message": "Buffer is not defined",

"locations": \[

{

"line": 12,

"column": 3

}

\],

"path": \[

"leftComparison",

"friendsConnection"

\]

},

{

"message": "Buffer is not defined",

"locations": \[

{

"line": 12,

"column": 3

}

\],

"path": \[

"rightComparison",

"friendsConnection"

\]

}

\],

"data": {

"leftComparison": null,

"rightComparison": null

}

}

## Operation name[](https://graphql.org/learn/queries/#operation-name)

Up until now, we have been using a shorthand syntax where we omit both the `query` keyword and the query name, but in production apps it's useful to use these to make our code less ambiguous.

Here's an example that includes the keyword `query` as *operation type* and `HeroNameAndFriends` as *operation name* :

query HeroNameAndFriends {

hero {

name

friends {

name

}

}

}

{

"data": {

"hero": {

"name": "R2-D2",

"friends": \[

{

"name": "Luke Skywalker"

},

{

"name": "Han Solo"

},

{

"name": "Leia Organa"

}

\]

}

}

}

The *operation type* is either *query*, *mutation*, or *subscription* and describes what type of operation you're intending to do. The operation type is required unless you're using the query shorthand syntax, in which case you can't supply a name or variable definitions for your operation.

The *operation name* is a meaningful and explicit name for your operation. It is only required in multi-operation documents, but its use is encouraged because it is very helpful for debugging and server-side logging. When something goes wrong (you see errors either in your network logs, or in the logs of your GraphQL server) it is easier to identify a query in your codebase by name instead of trying to decipher the contents. Think of this just like a function name in your favorite programming language. For example, in JavaScript we can easily work only with anonymous functions, but when we give a function a name, it's easier to track it down, debug our code, and log when it's called. In the same way, GraphQL query and mutation names, along with fragment names, can be a useful debugging tool on the server side to identify different GraphQL requests.

## Variables[](https://graphql.org/learn/queries/#variables)

So far, we have been writing all of our arguments inside the query string. But in most applications, the arguments to fields will be dynamic: For example, there might be a dropdown that lets you select which Star Wars episode you are interested in, or a search field, or a set of filters.

It wouldn't be a good idea to pass these dynamic arguments directly in the query string, because then our client-side code would need to dynamically manipulate the query string at runtime, and serialize it into a GraphQL-specific format. Instead, GraphQL has a first-class way to factor dynamic values out of the query, and pass them as a separate dictionary. These values are called *variables*.

When we start working with variables, we need to do three things:

1.  Replace the static value in the query with `$variableName`
2.  Declare `$variableName` as one of the variables accepted by the query
3.  Pass `variableName: value` in the separate, transport-specific (usually JSON) variables dictionary

Here's what it looks like all together:

query HeroNameAndFriends($episode: Episode) {

hero(episode: $episode) {

name

friends {

name

}

}

}

{

"episode": "JEDI"

}

{

"data": {

"hero": {

"name": "R2-D2",

"friends": \[

{

"name": "Luke Skywalker"

},

{

"name": "Han Solo"

},

{

"name": "Leia Organa"

}

\]

}

}

}

Now, in our client code, we can simply pass a different variable rather than needing to construct an entirely new query. This is also in general a good practice for denoting which arguments in our query are expected to be dynamic - we should never be doing string interpolation to construct queries from user-supplied values.

### Variable definitions[](https://graphql.org/learn/queries/#variable-definitions)

The variable definitions are the part that looks like `($episode: Episode)` in the query above. It works just like the argument definitions for a function in a typed language. It lists all of the variables, prefixed by `$`, followed by their type, in this case `Episode`.

All declared variables must be either scalars, enums, or input object types. So if you want to pass a complex object into a field, you need to know what input type that matches on the server. Learn more about input object types on the Schema page.

Variable definitions can be optional or required. In the case above, since there isn't an `!` next to the `Episode` type, it's optional. But if the field you are passing the variable into requires a non-null argument, then the variable has to be required as well.

To learn more about the syntax for these variable definitions, it's useful to learn the GraphQL schema language. The schema language is explained in detail on the Schema page.

### Default variables[](https://graphql.org/learn/queries/#default-variables)

Default values can also be assigned to the variables in the query by adding the default value after the type declaration.

query HeroNameAndFriends($episode: Episode = JEDI) {

hero(episode: $episode) {

name

friends {

name

}

}

}

When default values are provided for all variables, you can call the query without passing any variables. If any variables are passed as part of the variables dictionary, they will override the defaults.

## Directives[](https://graphql.org/learn/queries/#directives)

We discussed above how variables enable us to avoid doing manual string interpolation to construct dynamic queries. Passing variables in arguments solves a pretty big class of these problems, but we might also need a way to dynamically change the structure and shape of our queries using variables. For example, we can imagine a UI component that has a summarized and detailed view, where one includes more fields than the other.

Let's construct a query for such a component:

query Hero($episode: Episode, $withFriends: Boolean!) {

hero(episode: $episode) {

name

friends @include(if: $withFriends) {

name

}

}

}

{

"episode": "JEDI",

"withFriends": false

}

{

"data": {

"hero": {

"name": "R2-D2"

}

}

}

Try editing the variables above to instead pass `true` for `withFriends`, and see how the result changes.

We needed to use a new feature in GraphQL called a *directive*. A directive can be attached to a field or fragment inclusion, and can affect execution of the query in any way the server desires. The core GraphQL specification includes exactly two directives, which must be supported by any spec-compliant GraphQL server implementation:

- `@include(if: Boolean)` Only include this field in the result if the argument is `true`.
- `@skip(if: Boolean)` Skip this field if the argument is `true`.

Directives can be useful to get out of situations where you otherwise would need to do string manipulation to add and remove fields in your query. Server implementations may also add experimental features by defining completely new directives.

## Mutations[](https://graphql.org/learn/queries/#mutations)

Most discussions of GraphQL focus on data fetching, but any complete data platform needs a way to modify server-side data as well.

In REST, any request might end up causing some side-effects on the server, but by convention it's suggested that one doesn't use `GET` requests to modify data. GraphQL is similar - technically any query could be implemented to cause a data write. However, it's useful to establish a convention that any operations that cause writes should be sent explicitly via a mutation.

Just like in queries, if the mutation field returns an object type, you can ask for nested fields. This can be useful for fetching the new state of an object after an update. Let's look at a simple example mutation:

mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {

createReview(episode: $ep, review: $review) {

stars

commentary

}

}

{

"ep": "JEDI",

"review": {

"stars": 5,

"commentary": "This is a great movie!"

}

}

{

"data": {

"createReview": {

"stars": 5,

"commentary": "This is a great movie!"

}

}

}

Note how `createReview` field returns the `stars` and `commentary` fields of the newly created review. This is especially useful when mutating existing data, for example, when incrementing a field, since we can mutate and query the new value of the field with one request.

You might also notice that, in this example, the `review` variable we passed in is not a scalar. It's an *input object type*, a special kind of object type that can be passed in as an argument. Learn more about input types on the Schema page.

### Multiple fields in mutations[](https://graphql.org/learn/queries/#multiple-fields-in-mutations)

A mutation can contain multiple fields, just like a query. There's one important distinction between queries and mutations, other than the name:

**While query fields are executed in parallel, mutation fields run in series, one after the other.**

This means that if we send two `incrementCredits` mutations in one request, the first is guaranteed to finish before the second begins, ensuring that we don't end up with a race condition with ourselves.

## Inline Fragments[](https://graphql.org/learn/queries/#inline-fragments)

Like many other type systems, GraphQL schemas include the ability to define interfaces and union types. [Learn about them in the schema guide.](https://graphql.org/learn/schema/#interfaces)

If you are querying a field that returns an interface or a union type, you will need to use *inline fragments* to access data on the underlying concrete type. It's easiest to see with an example:

query HeroForEpisode($ep: Episode!) {

hero(episode: $ep) {

name

... on Droid {

primaryFunction

}

... on Human {

height

}

}

}

{

"ep": "JEDI"

}

{

"data": {

"hero": {

"name": "R2-D2",

"primaryFunction": "Astromech"

}

}

}

In this query, the `hero` field returns the type `Character`, which might be either a `Human` or a `Droid` depending on the `episode` argument. In the direct selection, you can only ask for fields that exist on the `Character` interface, such as `name`.

To ask for a field on the concrete type, you need to use an *inline fragment* with a type condition. Because the first fragment is labeled as `... on Droid`, the `primaryFunction` field will only be executed if the `Character` returned from `hero` is of the `Droid` type. Similarly for the `height` field for the `Human` type.

Named fragments can also be used in the same way, since a named fragment always has a type attached.

### Meta fields[](https://graphql.org/learn/queries/#meta-fields)

Given that there are some situations where you don't know what type you'll get back from the GraphQL service, you need some way to determine how to handle that data on the client. GraphQL allows you to request `__typename`, a meta field, at any point in a query to get the name of the object type at that point.

{

search(text: "an") {

\_\_typename

... on Human {

name

}

... on Droid {

name

}

... on Starship {

name

}

}

}

{

"data": {

"search": \[

{

"\_\_typename": "Human",

"name": "Han Solo"

},

{

"\_\_typename": "Human",

"name": "Leia Organa"

},

{

"\_\_typename": "Starship",

"name": "TIE Advanced x1"

}

\]

}

}

In the above query, `search` returns a union type that can be one of three options. It would be impossible to tell apart the different types from the client without the `__typename` field.

GraphQL services provide a few meta fields, the rest of which are used to expose the [Introspection](https://graphql.org/learn/introspection/) system.\*\*\*\*

## Jump to Section

<table><colgroup><col style="width: 100%" /></colgroup><tbody><tr class="odd"><td><table><tbody><tr class="odd"><td style="text-align: left;"><a href="https://search.freefind.com/siteindex.html?si=14588965">index</a></td><td style="text-align: center;"><a href="https://search.freefind.com/find.html?si=14588965&amp;m=0&amp;p=0">sitemap</a></td><td style="text-align: right;"><a href="https://search.freefind.com/find.html?si=14588965&amp;pid=a">advanced</a></td></tr></tbody></table></td></tr><tr class="even"><td><a href="https://www.freefind.com">search engine</a><a href="https://www.freefind.com">by<span style="color:transparent">freefind</span></a></td></tr></tbody></table>

<span class="copyright">@bgoonz on almost every platform</span><a href="https://bryanguner.medium.com/" class="button">Medium</a><a href="https://optimistic-lewin-8586ae.netlify.app/blm.zip" class="button">BLM</a>

<span class="screen-reader-text">Twitter</span>

<span class="screen-reader-text">LinkedIn</span>

<span class="screen-reader-text">GitHub</span>

<span class="screen-reader-text">Youtube</span>

<span class="screen-reader-text">Instagram</span>

<span class="screen-reader-text">dev.to</span>

Save to PDF

<span class="screen-reader-text">Back to top</span>

![](https://queue.simpleanalyticscdn.com/noscript.gif)

#### [<span style="color:gray;">Current local time in</span> New York City, United States](https://www.zeitverschiebung.net/en/city/5128581)
