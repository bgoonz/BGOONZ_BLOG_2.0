<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Object Oriented Programming in JavaScript</title><style>
</head><body><article class="h-entry">
<header>
<h1 class="p-name">Object Oriented Programming in JavaScript</h1>
</header>
<section data-field="subtitle" class="p-summary">
Object-Oriented Programming
</section>
<section data-field="body" class="e-content">
<section name="9131" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1e0a" id="1e0a" class="graf graf--h3 graf--leading graf--title">Object Oriented Programming in JavaScript</h3><h3 name="27c8" id="27c8" class="graf graf--h3 graf-after--h3">Object-Oriented Programming</h3><figure name="7c6a" id="7c6a" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*56wmllZ_9pRe28TK.jpg" data-width="1000" data-height="540" src="https://cdn-images-1.medium.com/max/800/0*56wmllZ_9pRe28TK.jpg"></figure><h3 name="fa9e" id="fa9e" class="graf graf--h3 graf-after--figure">Overview:</h3><h4 name="3c81" id="3c81" class="graf graf--h4 graf-after--h3"><code class="markup--code markup--h4-code">Encapsulation</code></h4><ul class="postList"><li name="b36d" id="b36d" class="graf graf--li graf-after--h4">The mechanism that puts behavior and data together behind methods that hide the specific implementation of a class.</li></ul><h4 name="0ee2" id="0ee2" class="graf graf--h4 graf-after--li">How can a <code class="markup--code markup--h4-code">CommonJS Module import functionality</code> from another module?</h4><ul class="postList"><li name="37ed" id="37ed" class="graf graf--li graf-after--h4">Through the use of the require function.</li></ul><h4 name="355d" id="355d" class="graf graf--h4 graf-after--li">How can an ES6 module import functionality from another module?</h4><ul class="postList"><li name="1e02" id="1e02" class="graf graf--li graf-after--h4">Through the use of the import-from syntax that looks like this:</li><li name="7d93" id="7d93" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">import SymbolName from &#39;./relative-path.js&#39;;</code></li></ul><h4 name="fa45" id="fa45" class="graf graf--h4 graf-after--li">How do <code class="markup--code markup--h4-code">CommonJS Modules</code> allow other modules to access exported symbols?</h4><ul class="postList"><li name="31b0" id="31b0" class="graf graf--li graf-after--h4">Through the use of the module.exports property.</li></ul><h4 name="b496" id="b496" class="graf graf--h4 graf-after--li">How do <code class="markup--code markup--h4-code">ES6 Modules export</code> functionality so other modules can use them?</h4><ul class="postList"><li name="3aa7" id="3aa7" class="graf graf--li graf-after--h4">Through the use of the export keyword.</li></ul><h4 name="be8d" id="be8d" class="graf graf--h4 graf-after--li"><code class="markup--code markup--h4-code">Implementation inheritance</code></h4><ul class="postList"><li name="ed04" id="ed04" class="graf graf--li graf-after--h4">The data and methods defined on a parent class are available on objects created from classes that inherit from those parent classes</li></ul><h4 name="84c2" id="84c2" class="graf graf--h4 graf-after--li"><code class="markup--code markup--h4-code">Inheritance</code></h4><ul class="postList"><li name="ed6e" id="ed6e" class="graf graf--li graf-after--h4">The mechanism that passes traits of a parent class to its descendants.</li></ul><h4 name="ace5" id="ace5" class="graf graf--h4 graf-after--li"><code class="markup--code markup--h4-code">Prototypal inheritance</code></h4><ul class="postList"><li name="598e" id="598e" class="graf graf--li graf-after--h4">A method of realizing implementation inheritance through process of finding missing properties on an object by delegating the resolution to a prototype object.</li></ul><h4 name="1616" id="1616" class="graf graf--h4 graf-after--li"><code class="markup--code markup--h4-code">The constructor method</code></h4><ul class="postList"><li name="e46e" id="e46e" class="graf graf--li graf-after--h4">The special method of a class that is called to initialize an object when code uses the new keyword to instantiate an object from that class.</li></ul><h4 name="59a0" id="59a0" class="graf graf--h4 graf-after--li"><code class="markup--code markup--h4-code">The Dependency Inversion Principle</code></h4><ul class="postList"><li name="d024" id="d024" class="graf graf--li graf-after--h4">Functionality that your class depends on should be provided as parameters to methods rather than using new in the class to create a new instance of a dependency.</li></ul><h4 name="3680" id="3680" class="graf graf--h4 graf-after--li">The <code class="markup--code markup--h4-code">extends</code> keyword</h4><ul class="postList"><li name="f74f" id="f74f" class="graf graf--li graf-after--h4">The keyword in JavaScript that allows one class to inherit from another.</li></ul><h4 name="e42d" id="e42d" class="graf graf--h4 graf-after--li"><code class="markup--code markup--h4-code">The Interface Segregation Principle</code></h4><ul class="postList"><li name="6af3" id="6af3" class="graf graf--li graf-after--h4">Method names should be grouped together into granular collections called “interfaces”</li></ul><h4 name="fd47" id="fd47" class="graf graf--h4 graf-after--li"><code class="markup--code markup--h4-code">The Law Of Demeter</code></h4><ul class="postList"><li name="e90d" id="e90d" class="graf graf--li graf-after--h4">Don’t use more than one dot (not counting the one after “this”).</li><li name="6cbd" id="6cbd" class="graf graf--li graf-after--li">A method of an object can only invoke the methods (or use the properties) of the following kinds of objects: Methods on the object itself Any of the objects passed in as parameters to the method And object created in the method Any values stored in the instance variables of the object Any values stored in global variables</li></ul><h4 name="941e" id="941e" class="graf graf--h4 graf-after--li"><code class="markup--code markup--h4-code">The Liskov Substitution Principle</code></h4><ul class="postList"><li name="4589" id="4589" class="graf graf--li graf-after--h4">You can substitute child class objects for parent class objects and not cause errors.</li></ul><h4 name="47c5" id="47c5" class="graf graf--h4 graf-after--li"><code class="markup--code markup--h4-code">The Open-Close Principle</code></h4><ul class="postList"><li name="7246" id="7246" class="graf graf--li graf-after--h4">A class is open for extension and closed for modification.</li></ul><h4 name="5ff9" id="5ff9" class="graf graf--h4 graf-after--li"><code class="markup--code markup--h4-code">The Single-Responsibility Principle</code></h4><ul class="postList"><li name="48dc" id="48dc" class="graf graf--li graf-after--h4">Any one of the following:</li><li name="3313" id="3313" class="graf graf--li graf-after--li">A class should do one thing and do it well.</li><li name="2d3f" id="2d3f" class="graf graf--li graf-after--li">A class should have only one reason to change.</li><li name="e277" id="e277" class="graf graf--li graf-after--li graf--trailing">Gather together the things that change for the same reasons. Separate those things that change for different reasons.</li></ul></div></div></section><section name="af8d" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0c1c" id="0c1c" class="graf graf--h3 graf--leading">Background:</h3><h3 name="b0a4" id="b0a4" class="graf graf--h3 graf-after--h3">Constructor Functions</h3><p name="1d86" id="1d86" class="graf graf--p graf-after--h3">Defining a constructor function <em class="markup--em markup--p-em">Example of an object using object initialization</em></p><pre name="be55" id="be55" class="graf graf--pre graf-after--p">const fellowshipOfTheRing = {<br>  title: &quot;The Fellowship of the Ring&quot;,<br>  series: &quot;The Lord of the Rings&quot;,<br>  author: &quot;J.R.R. Tolkien&quot;,<br>};</pre><ul class="postList"><li name="9071" id="9071" class="graf graf--li graf-after--pre">The above literal is a “Book” object type.</li><li name="a5d6" id="a5d6" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Object Type</code> is defined by it&#39;s attributes and behaviors.</li></ul><blockquote name="9b5a" id="9b5a" class="graf graf--blockquote graf-after--li"><code class="markup--code markup--blockquote-code"><strong class="markup--strong markup--blockquote-strong">Behaviors</strong></code><strong class="markup--strong markup--blockquote-strong"> are represented by methods.</strong></blockquote><ul class="postList"><li name="ccb5" id="ccb5" class="graf graf--li graf-after--blockquote"><code class="markup--code markup--li-code">Constructor Functions</code> : Handle the creation of an object - it&#39;s a factory for creating objects of a specific type.</li><li name="bdc9" id="bdc9" class="graf graf--li graf-after--li">There are a few specific things to constructors worth noting:</li><li name="6549" id="6549" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">The name of the constructor function is capitalized</em></strong></li><li name="8e61" id="8e61" class="graf graf--li graf-after--li">The Function <em class="markup--em markup--li-em">does not explicitly return a value</em></li><li name="8d48" id="8d48" class="graf graf--li graf-after--li">Within the body, the <em class="markup--em markup--li-em">this</em> keyword references the newly created object</li></ul><pre name="e73f" id="e73f" class="graf graf--pre graf-after--li">function Book(title, series, author) {<br>  this.title = title;<br>  this.series = series;<br>  this.author = author;<br>}</pre><h3 name="6a13" id="6a13" class="graf graf--h3 graf-after--pre">Invoking a constructor function</h3><ul class="postList"><li name="dc26" id="dc26" class="graf graf--li graf-after--h3">We can invoke a constructor function using the <code class="markup--code markup--li-code">new</code> keyword.</li></ul><pre name="0272" id="0272" class="graf graf--pre graf-after--li">function Book(title, series, author) {<br>  this.title = title;<br>  this.series = series;<br>  this.author = author;<br>}</pre><pre name="c5c9" id="c5c9" class="graf graf--pre graf-after--pre">const fellowshipOfTheRing = new Book(<br>  &quot;The Fellowship of the Ring&quot;,<br>  &quot;The Lord of the Rings&quot;,<br>  &quot;J.R.R. Tolkien&quot;<br>);</pre><pre name="74b3" id="74b3" class="graf graf--pre graf-after--pre">console.log(fellowshipOfTheRing); // Book { title: &#39;The Fellowship of the Ring&#39;, ... }</pre><h3 name="f7ef" id="f7ef" class="graf graf--h3 graf-after--pre"><em class="markup--em markup--h3-em">Four Things will happen when invoking a constructor function</em></h3><ol class="postList"><li name="b127" id="b127" class="graf graf--li graf-after--h3">A new empty object is created {};</li><li name="3c79" id="3c79" class="graf graf--li graf-after--li">The new obj’s <code class="markup--code markup--li-code">prototype</code> is set to the object referenced by the constructors prototype property.</li><li name="6b2e" id="6b2e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">This</code> is bound to the new object.</li><li name="a360" id="a360" class="graf graf--li graf-after--li">The new object is returned after the constructor function has completed.</li></ol><h3 name="eaf8" id="eaf8" class="graf graf--h3 graf-after--li">Understanding New Object Instances</h3><ul class="postList"><li name="1263" id="1263" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">Instance</code> : term to describe an objected created from a constructor function.</li><li name="6916" id="6916" class="graf graf--li graf-after--li">Every instance created is a unique object and therefore not equal to each other.</li></ul><h3 name="5a34" id="5a34" class="graf graf--h3 graf-after--li">Using the instanceof operator to check an object’s type</h3><pre name="6093" id="6093" class="graf graf--pre graf-after--h3">console.log(fellowshipOfTheRing instanceof Book); // true</pre><ul class="postList"><li name="f5e2" id="f5e2" class="graf graf--li graf-after--pre">By using the <code class="markup--code markup--li-code">instanceof</code> operator we can verify that an object was created from a certain object type.</li><li name="9d20" id="9d20" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">The instanceOf operator works by checking to see if the prototype object of the left side of the operator is the same as the prototype object of the right side of the operator.</em></li></ul><h3 name="1fa6" id="1fa6" class="graf graf--h3 graf-after--li">Invoking a constructor function without the new keyword</h3><ul class="postList"><li name="e812" id="e812" class="graf graf--li graf-after--h3">If we invoke a constructor function without the <code class="markup--code markup--li-code">new</code> keyword, we may result in one of two unexpected outcomes:</li></ul><ol class="postList"><li name="c067" id="c067" class="graf graf--li graf-after--li">In non-strict mode, this will be bound to the global object instead.</li><li name="8654" id="8654" class="graf graf--li graf-after--li">In <code class="markup--code markup--li-code">strict</code> mode, this will become undefined.</li></ol><ul class="postList"><li name="4f03" id="4f03" class="graf graf--li graf-after--li">You can enable strict mode by typing <code class="markup--code markup--li-code">&quot;use strict&quot;</code> at the top of your file.</li></ul><h3 name="a387" id="a387" class="graf graf--h3 graf-after--li">Defining Sharable Methods</h3><ul class="postList"><li name="0f4e" id="0f4e" class="graf graf--li graf-after--h3"><em class="markup--em markup--li-em">Avoid the temptation to store an object method inside a constructor function, it is inefficient with computer memory usage b/c each object instance would have it’s own method definition.</em></li><li name="a9e8" id="a9e8" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Prototype</code> : An object that is delegated to when a reference to an object property or method can&#39;t be resolved.</li><li name="ddc6" id="ddc6" class="graf graf--li graf-after--li">Every instance created by a constructor function shares the same prototype.</li><li name="ddba" id="ddba" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Object.setPrototypeOf()</code> and <code class="markup--code markup--li-code">Object.getPrototypeOf()</code> are just used to set a prototype of one object to another object; and also the verify a prototype.</li><li name="144c" id="144c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">proto</code> : aka &quot;dunder proto&quot; is a property used to gain easy access to an object&#39;s prototype - it is widely supported by browsers but is considered deprecated.</li></ul><pre name="7b2b" id="7b2b" class="graf graf--pre graf-after--li">function Book(title, series, author) {<br>  this.title = title;<br>  this.series = series;<br>  this.author = author;<br>}</pre><pre name="b2aa" id="b2aa" class="graf graf--pre graf-after--pre">// Any method defined on the `Book.prototype` property<br>// will be shared across all `Book` instances.<br>Book.prototype.getInformation = function () {<br>  return `${this.title} by ${this.author}`;<br>};</pre><pre name="9906" id="9906" class="graf graf--pre graf-after--pre">const fellowshipOfTheRing = new Book(<br>  &quot;The Fellowship of the Ring&quot;,<br>  &quot;The Lord of the Rings&quot;,<br>  &quot;J.R.R. Tolkien&quot;<br>);</pre><pre name="a9d2" id="a9d2" class="graf graf--pre graf-after--pre">console.log(fellowshipOfTheRing.getInformation());</pre><ul class="postList"><li name="455e" id="455e" class="graf graf--li graf-after--pre">Every method we define on a constructor function’s prototype property will be shared across all instances of that object type.</li></ul><p name="d6c3" id="d6c3" class="graf graf--p graf-after--li">The Problem with Arrow Functions</p><ul class="postList"><li name="6cb0" id="6cb0" class="graf graf--li graf-after--p">We cannot use arrow functions when defining methods on a constructor function’s prototype property.</li><li name="4f33" id="4f33" class="graf graf--li graf-after--li graf--trailing">Arrow functions don’t include their own this binding; therefore it will not reference the current instance — always stick with the function () keyword.</li></ul></div></div></section><section name="a812" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="644f" id="644f" class="graf graf--h3 graf--leading">Putting the Class in JavaScript Classes</h3><p name="b79f" id="b79f" class="graf graf--p graf-after--h3">In ES2015, JS gained the <code class="markup--code markup--p-code">class</code> keyword - replacing the need to use only constructor functions &amp; prototypes to mimic classes!</p><ul class="postList"><li name="df3e" id="df3e" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">class</code> : keyword that gives developers a formal way to create a class definition to specify an object type&#39;s attributes and behavior; also used to create objects of that specific type.</li></ul><p name="8ab6" id="8ab6" class="graf graf--p graf-after--li">Defining a ES2015 class</p><pre name="e4c1" id="e4c1" class="graf graf--pre graf-after--p">class Book {<br>  constructor(title, series, author) {<br>    this.title = title;<br>    this.series = series;<br>    this.author = author;<br>  }<br>}</pre><ul class="postList"><li name="951e" id="951e" class="graf graf--li graf-after--pre">Class names also begin only with capital letters.</li><li name="28ed" id="28ed" class="graf graf--li graf-after--li">Although not required, class definitions can include a <code class="markup--code markup--li-code">class constructor function</code> - these are similar to regular constructors in that:</li><li name="a4b1" id="a4b1" class="graf graf--li graf-after--li">They don’t explicitly return a value.</li><li name="e85e" id="e85e" class="graf graf--li graf-after--li">The this keyword references the newly created object instance.</li></ul><h3 name="6240" id="6240" class="graf graf--h3 graf-after--li">Instantiating an instance of a class</h3><blockquote name="dc49" id="dc49" class="graf graf--blockquote graf-after--h3">We can also use the <code class="markup--code markup--blockquote-code">new</code>.</blockquote><h3 name="e67f" id="e67f" class="graf graf--h3 graf-after--blockquote">Four things occur when instantiating an instance of a class:</h3><ol class="postList"><li name="8842" id="8842" class="graf graf--li graf-after--h3">New empty object is created {};</li><li name="1cd6" id="1cd6" class="graf graf--li graf-after--li">The new obj’s prototype is set to the class prototype’s property value.</li><li name="eddc" id="eddc" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">This</code> is bound to the new object.</li><li name="0814" id="0814" class="graf graf--li graf-after--li">After the constructor method has completed, the new obj is returned.</li></ol><ul class="postList"><li name="e722" id="e722" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Don’t try to instatiate a class object without the new keyword.</strong></li></ul><h4 name="a134" id="a134" class="graf graf--h4 graf-after--li">Class Definitions are NOT hoisted</h4><pre name="98de" id="98de" class="graf graf--pre graf-after--h4">test();</pre><pre name="47dd" id="47dd" class="graf graf--pre graf-after--pre">function test() {<br>  console.log(&quot;This works!&quot;);<br>}</pre><ul class="postList"><li name="bf4e" id="bf4e" class="graf graf--li graf-after--pre">In JS you can call a function before it’s declared — this is known as <code class="markup--code markup--li-code">hoisting</code>.</li><li name="8dd6" id="8dd6" class="graf graf--li graf-after--li">Class definitions are <strong class="markup--strong markup--li-strong">NOT hoisted, </strong>so just get in the habit of declaring them before you use them.</li></ul><p name="4b50" id="4b50" class="graf graf--p graf-after--li">Defining Methods</p><ul class="postList"><li name="afc2" id="afc2" class="graf graf--li graf-after--p">A class can contain two types of methods:</li><li name="6099" id="6099" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Instance Method</code> : Methods that are invoked on an instance of the class - useful for performing an action on a specific instance.</li><li name="ed85" id="ed85" class="graf graf--li graf-after--li">Instance methods are also sometimes referred to as <code class="markup--code markup--li-code">prototype</code> methods because they are defined on a shared prototype object.</li><li name="ca19" id="ca19" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Static Method</code> : Methods that invoked directly on a class, not on an instance.</li><li name="3c58" id="3c58" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Important</code>: Invoking a static method on an instance will result in a runtime error.</li><li name="a067" id="a067" class="graf graf--li graf-after--li">Prepending the <code class="markup--code markup--li-code">static</code> keyword at the beginning on the method name will make it static.</li></ul><pre name="289d" id="289d" class="graf graf--pre graf-after--li">class Book {<br>  constructor(title, series, author) {<br>    this.title = title;<br>    this.series = series;<br>    this.author = author;<br>  }</pre><pre name="73d6" id="73d6" class="graf graf--pre graf-after--pre">  // Notice the use of a rest parameter (...books)<br>  // to capture the passed parameters as an array of values.<br>  static getTitles(...books) {<br>    return books.map((book) =&gt; book.title);<br>  }</pre><pre name="49c0" id="49c0" class="graf graf--pre graf-after--pre">  getInformation() {<br>    return `${this.title} by ${this.author}`;<br>  }<br>}</pre><pre name="cf66" id="cf66" class="graf graf--pre graf-after--pre">const fellowshipOfTheRing = new Book(<br>  &quot;The Fellowship of the Ring&quot;,<br>  &quot;The Lord of the Rings&quot;,<br>  &quot;J.R.R. Tolkien&quot;<br>);</pre><pre name="df82" id="df82" class="graf graf--pre graf-after--pre">const theTwoTowers = new Book(<br>  &quot;The Two Towers&quot;,<br>  &quot;The Lord of the Rings&quot;,<br>  &quot;J.R.R. Tolkien&quot;<br>);</pre><pre name="2d78" id="2d78" class="graf graf--pre graf-after--pre">const bookTitles = Book.getTitles(fellowshipOfTheRing, theTwoTowers);</pre><pre name="0d84" id="0d84" class="graf graf--pre graf-after--pre">console.log(bookTitles.join(&quot;, &quot;)); // The Fellowship of the Ring, The Two Towers</pre><ul class="postList"><li name="133d" id="133d" class="graf graf--li graf-after--pre">If we go back to an example of how constructor functions also use static methods — we see that static methods are <em class="markup--em markup--li-em">defined directly on the constructor function</em> — whereas instance methods need to be defined on the <em class="markup--em markup--li-em">prototype</em> object.</li></ul><pre name="84d9" id="84d9" class="graf graf--pre graf-after--li">function Book(title, series, author) {<br>  this.title = title;<br>  this.series = series;<br>  this.author = author;<br>}</pre><pre name="95fe" id="95fe" class="graf graf--pre graf-after--pre">// Static methods are defined<br>// directly on the constructor function.<br>Book.getTitles = function (...books) {<br>  return books.map((book) =&gt; book.title);<br>};</pre><pre name="b78f" id="b78f" class="graf graf--pre graf-after--pre">// Instance methods are defined<br>// on the constructor function&#39;s `prototype` property.<br>Book.prototype.getInformation = function () {<br>  return `${this.title} by ${this.author}`;<br>};</pre><pre name="8a51" id="8a51" class="graf graf--pre graf-after--pre">const fellowshipOfTheRing = new Book(<br>  &quot;The Fellowship of the Ring&quot;,<br>  &quot;The Lord of the Rings&quot;,<br>  &quot;J.R.R. Tolkien&quot;<br>);</pre><pre name="15e1" id="15e1" class="graf graf--pre graf-after--pre">const theTwoTowers = new Book(<br>  &quot;The Two Towers&quot;,<br>  &quot;The Lord of the Rings&quot;,<br>  &quot;J.R.R. Tolkien&quot;<br>);</pre><pre name="accf" id="accf" class="graf graf--pre graf-after--pre">console.log(fellowshipOfTheRing.getInformation()); // The Fellowship of the Ring by J.R.R. Tolkien</pre><pre name="0edb" id="0edb" class="graf graf--pre graf-after--pre">console.log(theTwoTowers.getInformation()); // The Two Towers by J.R.R. Tolkien</pre><pre name="a71c" id="a71c" class="graf graf--pre graf-after--pre">// Call the static `Book.getTitles()` method<br>// to get an array of the book titles.<br>const bookTitles = Book.getTitles(fellowshipOfTheRing, theTwoTowers);</pre><pre name="69bf" id="69bf" class="graf graf--pre graf-after--pre">console.log(bookTitles.join(&quot;, &quot;)); // The Fellowship of the Ring, The Two Towers</pre><h3 name="14ed" id="14ed" class="graf graf--h3 graf-after--pre">Comparing Classes to Constructor Functions</h3><blockquote name="8e9e" id="8e9e" class="graf graf--blockquote graf-after--h3 graf--trailing"><em class="markup--em markup--blockquote-em">ES2015 Classes are essentially </em><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">syntactic sugar </em></strong><em class="markup--em markup--blockquote-em">over traditional constructor functions and prototypes.</em></blockquote></div></div></section><section name="fe7a" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="59cc" id="59cc" class="graf graf--h3 graf--leading">Javascript Inheritance</h3><ul class="postList"><li name="76a3" id="76a3" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">Child Class</code> : Class that is based upon another class and inherits properties and methods from that other class.</li><li name="9c4b" id="9c4b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Parent Class</code> : Class that is being inherited downwards.</li><li name="673c" id="673c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Inheritance</code> : The process of basing a class upon another class.</li></ul><pre name="ce1a" id="ce1a" class="graf graf--pre graf-after--li">class CatalogItem {<br>  constructor(title, series) {<br>    this.title = title;<br>    this.series = series;<br>  }</pre><pre name="18c8" id="18c8" class="graf graf--pre graf-after--pre">  getInformation() {<br>    if (this.series) {<br>      return `${this.title} (${this.series})`;<br>    } else {<br>      return this.title;<br>    }<br>  }<br>}</pre><pre name="ae51" id="ae51" class="graf graf--pre graf-after--pre">class Book extends CatalogItem {<br>  constructor(title, series, author) {<br>    super(title, series);<br>    this.author = author;<br>  }<br>}</pre><pre name="5dcf" id="5dcf" class="graf graf--pre graf-after--pre">class Movie extends CatalogItem {<br>  constructor(title, series, director) {<br>    super(title, series);<br>    this.director = director;<br>  }<br>}</pre><pre name="4029" id="4029" class="graf graf--pre graf-after--pre">const theGrapesOfWrath = new Book(<br>  &quot;The Grapes of Wrath&quot;,<br>  null,<br>  &quot;John Steinbeck&quot;<br>);<br>const aNewHope = new Movie(<br>  &quot;Episode 4: A New Hope&quot;,<br>  &quot;Star Wars&quot;,<br>  &quot;George Lucas&quot;<br>);</pre><pre name="c148" id="c148" class="graf graf--pre graf-after--pre">console.log(theGrapesOfWrath.getInformation()); // The Grapes of Wrath<br>console.log(aNewHope.getInformation()); // Episode 4: A New Hope (Star Wars)<br>console.log(Catalogitem instanceof Function); // true<br>console.log(Book instanceof Function); // true</pre><ul class="postList"><li name="8dcd" id="8dcd" class="graf graf--li graf-after--pre">A <code class="markup--code markup--li-code">prototype chain</code> defines a series of prototype objects that are delegated to one by one, when a property or method can&#39;t be found on an instance object.</li></ul><pre name="26ad" id="26ad" class="graf graf--pre graf-after--li">console.log(theGrapesOfWrath.getInformation()); // The Grapes of Wrath</pre><ul class="postList"><li name="cdf9" id="cdf9" class="graf graf--li graf-after--pre">When the <code class="markup--code markup--li-code">getInformation()</code> method is invoked:</li><li name="7d03" id="7d03" class="graf graf--li graf-after--li">JS looks for get() on the current object.</li><li name="c65f" id="c65f" class="graf graf--li graf-after--li">If it isn’t found, the method call is delegated to the object’s prototype.</li><li name="7ff3" id="7ff3" class="graf graf--li graf-after--li">It continues up the prototype chain until the method is found.</li></ul><p name="421a" id="421a" class="graf graf--p graf-after--li">Overriding a method in a parent class</p><ul class="postList"><li name="71f7" id="71f7" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">Method Overriding</code> : when a child class provides an implementation of a method that&#39;s already defined in a parent class.</li></ul><pre name="d388" id="d388" class="graf graf--pre graf-after--li">class Movie extends CatalogItem {<br>  constructor(title, series, director) {<br>    super(title, series);<br>    this.director = director;<br>  }</pre><pre name="af11" id="af11" class="graf graf--pre graf-after--pre">  getInformation() {<br>    let result = super.getInformation();</pre><pre name="73db" id="73db" class="graf graf--pre graf-after--pre">    if (this.director) {<br>      result += ` [directed by ${this.director}]`;<br>    }</pre><pre name="8cdb" id="8cdb" class="graf graf--pre graf-after--pre">    return result;<br>  }<br>}</pre><ul class="postList"><li name="68fd" id="68fd" class="graf graf--li graf-after--pre graf--trailing">We can simply declare our own method of the same name in our child class to override our parent’s version of <code class="markup--code markup--li-code">getInformation()</code></li></ul></div></div></section><section name="39f3" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="254e" id="254e" class="graf graf--h3 graf--leading">JavaScript Modules</h3><p name="ed13" id="ed13" class="graf graf--p graf-after--h3">Introducing Node.js modules</p><ul class="postList"><li name="7869" id="7869" class="graf graf--li graf-after--p">In Node.js, each JS file in a project defines a <code class="markup--code markup--li-code">module</code>.</li><li name="fdaa" id="fdaa" class="graf graf--li graf-after--li">Module’s contents are private by default.</li><li name="1ee7" id="1ee7" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Local Modules</code> : Modules defined within your project.</li><li name="47f2" id="47f2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Core Modules</code> : Native modules contained within Node.js that you can use to perform tasks or to add functionality to your application.</li><li name="dc6e" id="dc6e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">CommonJS</code> : A legacy module system.</li><li name="20cd" id="20cd" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ES Modules</code> : Newer module sysem that will eventually replace CommonJS.</li><li name="5889" id="5889" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Entry Point</code> : JS File that is passed to Node for access to the entire application.</li></ul><h3 name="f864" id="f864" class="graf graf--h3 graf-after--li">Syntax for exporting modules:</h3><pre name="c8d3" id="c8d3" class="graf graf--pre graf-after--h3"><strong class="markup--strong markup--pre-strong">module.exports.Book = Book; module.exports.Movie = Movie;</strong></pre><pre name="1b9d" id="1b9d" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">module.exports = { Book, Movie, };</strong></pre><h4 name="5b6d" id="5b6d" class="graf graf--h4 graf-after--pre">Syntax for importing modules:</h4><pre name="4b43" id="4b43" class="graf graf--pre graf-after--h4"><strong class="markup--strong markup--pre-strong">const classes = require(“./classes”);</strong></pre><pre name="f2ab" id="f2ab" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">const { Book, Movie } = require(“./classes”);</strong></pre><h4 name="832e" id="832e" class="graf graf--h4 graf-after--pre">Using Single Item Modules</h4><ul class="postList"><li name="0b43" id="0b43" class="graf graf--li graf-after--h4">Following the convention of a single exported item per module helps to keep modules focused and less likely to become bloted with too much code.</li></ul><h4 name="eefe" id="eefe" class="graf graf--h4 graf-after--li">Understanding Module Loading</h4><ul class="postList"><li name="a924" id="a924" class="graf graf--li graf-after--h4">When loading a module, Node will examine the identifier passed to the require() function to determine if our module is local, core, or third-party:</li><li name="42b7" id="42b7" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Local Module</code>: identifier starts with ./ ../ or /</li><li name="7f81" id="7f81" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Node.js Core</code>: identifier matches name</li><li name="ecfe" id="ecfe" class="graf graf--li graf-after--li graf--trailing"><code class="markup--code markup--li-code">Third-Party</code>: identifier matches a module in the node modules folder (installed package)</li></ul></div></div></section><section name="13e2" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="eb20" id="eb20" class="graf graf--h3 graf--leading"><code class="markup--code markup--h3-code">Encapsulation</code></h3><ul class="postList"><li name="74af" id="74af" class="graf graf--li graf-after--h3">Puts the behavior and data together behind methods that hide the specific implementation so that code that uses it doesn’t need to worry about the details of it.</li></ul><h3 name="176b" id="176b" class="graf graf--h3 graf-after--li"><code class="markup--code markup--h3-code">Inheritance</code></h3><ul class="postList"><li name="5328" id="5328" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">Implementation Inheritance</strong></code><strong class="markup--strong markup--li-strong"> :</strong> Means that data and methods defined on a parent class are available on objects created from classes that inherit from those parent classes.</li><li name="743c" id="743c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">Prototypal Inheritance</strong></code> : Means that JS uses prototype objects to make its <code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">implementation inheritance</strong></code> actually work.</li><li name="39b5" id="39b5" class="graf graf--li graf-after--li">Parent Class === Prototype === Super Class === Base Class</li><li name="8a35" id="8a35" class="graf graf--li graf-after--li">Inheritance === Subtyping</li></ul><pre name="4f54" id="4f54" class="graf graf--pre graf-after--li">class MyClass {}</pre><pre name="6ca1" id="6ca1" class="graf graf--pre graf-after--pre">// is the same as<br>class MyClass extends Object {}</pre><ul class="postList"><li name="e595" id="e595" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">When you declare a class with no explicit parent class, JS will make it a child of Object.</strong></li></ul><pre name="37d8" id="37d8" class="graf graf--pre graf-after--li">class Charity {}</pre><pre name="23fd" id="23fd" class="graf graf--pre graf-after--pre">class Business {<br>  toString() {<br>    return &quot;Give us your money.&quot;;<br>  }<br>}</pre><pre name="cb16" id="cb16" class="graf graf--pre graf-after--pre">class Restaurant extends Business {<br>  toString() {<br>    return &quot;Eat at Joe&#39;s!&quot;;<br>  }<br>}</pre><pre name="e9b5" id="e9b5" class="graf graf--pre graf-after--pre">class AutoRepairShop extends Business {}</pre><pre name="8471" id="8471" class="graf graf--pre graf-after--pre">class Retail extends Business {<br>  toString() {<br>    return &quot;Buy some stuff!&quot;;<br>  }<br>}</pre><pre name="5cd4" id="5cd4" class="graf graf--pre graf-after--pre">class ClothingStore extends Retail {}</pre><pre name="6ade" id="6ade" class="graf graf--pre graf-after--pre">class PhoneStore extends Retail {<br>  toString() {<br>    return &quot;Upgrade your perfectly good phone, now!&quot;;<br>  }<br>}</pre><pre name="bc5e" id="bc5e" class="graf graf--pre graf-after--pre">console.log(new PhoneStore().toString()); // &#39;Upgrade your perfectly good phone, now!&#39;<br>console.log(new ClothingStore().toString()); // &#39;Buy some stuff!&#39;;<br>console.log(new Restaurant().toString()); // &#39;Eat at Joe\&#39;s!&#39;<br>console.log(new AutoRepairShop().toString()); // &#39;Give us your money.&#39;<br>console.log(new Charity().toString()); // [object object]</pre><h4 name="f529" id="f529" class="graf graf--h4 graf-after--pre">The nuts and bolts of prototypal inheritance</h4><figure name="dd24" id="dd24" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*FCIE6k4O9X8f9CbR" data-width="1280" data-height="278" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*FCIE6k4O9X8f9CbR"></figure><ul class="postList"><li name="8fac" id="8fac" class="graf graf--li graf-after--figure">When JavaScript uses a property (or method) from a prototype that it found through prototypal inheritance, then the this property points to the original object on which the first call was made.</li></ul><pre name="621b" id="621b" class="graf graf--pre graf-after--li">class Parent {<br>  constructor() {<br>    this.name = &quot;PARENT&quot;;<br>  }<br>  toString() {<br>    return `My name is ${this.name}`;<br>  }<br>}</pre><pre name="fb59" id="fb59" class="graf graf--pre graf-after--pre">class Child extends Parent {<br>  constructor() {<br>    super();<br>    this.name = &quot;CHILD&quot;;<br>  }<br>}</pre><pre name="9678" id="9678" class="graf graf--pre graf-after--pre">const parent = new Parent();<br>console.log(parent.toString()); // my name is Parent</pre><pre name="3a87" id="3a87" class="graf graf--pre graf-after--pre">const child = new Child();<br>console.log(child.toString()); // my name is Child</pre><h3 name="ac78" id="ac78" class="graf graf--h3 graf-after--pre">Polymorphism</h3><ul class="postList"><li name="4da7" id="4da7" class="graf graf--li graf-after--h3 graf--trailing">The ability to treat an object as if it were an instance of one of its parent classes.</li></ul></div></div></section><section name="e597" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7871" id="7871" class="graf graf--h3 graf--leading">The SOLID Principles Explained</h3><p name="c460" id="c460" class="graf graf--p graf-after--h3">SOLID is an anagram for:</p><ul class="postList"><li name="cdba" id="cdba" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">The Single-Responsibility Principle</code></li><li name="be3a" id="be3a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">The Open-Close Principle</code></li><li name="0822" id="0822" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">The Liskov Substitution Principle</code></li><li name="f90a" id="f90a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">The Interface Segregation Principle</code></li><li name="05aa" id="05aa" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">The Dependency Inversion Principle</code></li></ul><h3 name="e3b0" id="e3b0" class="graf graf--h3 graf-after--li"><code class="markup--code markup--h3-code">Single-Responsibility Principle</code></h3><blockquote name="830c" id="830c" class="graf graf--blockquote graf-after--h3"><em class="markup--em markup--blockquote-em">A class should do one thing and do it well</em></blockquote><ul class="postList"><li name="46f7" id="46f7" class="graf graf--li graf-after--blockquote">This principle is about limiting the impact of change.</li></ul><h3 name="5571" id="5571" class="graf graf--h3 graf-after--li"><code class="markup--code markup--h3-code">The Liskov Substitution Principle:</code></h3><p name="f5c1" id="f5c1" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">Subtype Requirement: Let ϕ(x) be a property provable about objects x of type T. Then ϕ(y) should be true for objects y of type S where S is a subtype of T.</em></p><blockquote name="3add" id="3add" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">You can substitute child class objects for parent class objects and not cause errors.</em></blockquote><p name="5e0d" id="5e0d" class="graf graf--p graf-after--blockquote"><code class="markup--code markup--p-code">The Other Three</code></p><ul class="postList"><li name="11ae" id="11ae" class="graf graf--li graf-after--p">The remaining three principles are important for languages that have <code class="markup--code markup--li-code">static typing</code> - which means a variable can have only one kind of thing in it.</li><li name="c644" id="c644" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Open-Close Principle</code></li><li name="450f" id="450f" class="graf graf--li graf-after--li">A class is open for extension and closed for modification.</li><li name="d4c9" id="d4c9" class="graf graf--li graf-after--li">Creating new functionality can happen in child classes, and not the original class.</li><li name="9cb7" id="9cb7" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Interface Segregation Principle</code></li><li name="37db" id="37db" class="graf graf--li graf-after--li">Method names should be grouped together into granular collections called “interfaces”.</li><li name="7861" id="7861" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Dependency Inversion Principle</code></li><li name="40a9" id="40a9" class="graf graf--li graf-after--li">Functionality that your class depends on should be provided as parameters to methods rather than using new in the class to create a new instance.</li></ul><h3 name="b269" id="b269" class="graf graf--h3 graf-after--li">Controlling Coupling with The Law of Demeter</h3><ul class="postList"><li name="2e83" id="2e83" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">Coupling</code> : The degree of interdependence between two or more classes.</li><li name="d484" id="d484" class="graf graf--li graf-after--li">The fewer the connections between classes, the less chance there is for the <em class="markup--em markup--li-em">ripple effect</em>.</li><li name="dc31" id="dc31" class="graf graf--li graf-after--li">Here is the formal definition:</li><li name="61b4" id="61b4" class="graf graf--li graf-after--li">A method of an object can only invoke the methods (or use the properties) of the following kind of objects:</li><li name="5733" id="5733" class="graf graf--li graf-after--li">Methods on the object itself.</li><li name="163d" id="163d" class="graf graf--li graf-after--li">Any of the objects passed in as parameters to the method.</li><li name="c766" id="c766" class="graf graf--li graf-after--li">Any object created in the method.</li><li name="d8ce" id="d8ce" class="graf graf--li graf-after--li">Any values stores in the instance variables of the object.</li><li name="ce51" id="ce51" class="graf graf--li graf-after--li">Any values stored in global variables.</li><li name="0aba" id="0aba" class="graf graf--li graf-after--li">Law of Demeter is more so of a guideline than a law.</li><li name="0d36" id="0d36" class="graf graf--li graf-after--li">Easiest way to implement it is to <em class="markup--em markup--li-em">not us more than one dot</em></li><li name="76ea" id="76ea" class="graf graf--li graf-after--li">You cannot cheat by separating extra calls onto different lines.</li></ul><h3 name="3b3c" id="3b3c" class="graf graf--h3 graf-after--li">When to ignore the Law of Demeter</h3><ul class="postList"><li name="770a" id="770a" class="graf graf--li graf-after--h3">When you work with objects that come from code that you didn’t create — you will often have to break the LoD.</li></ul><pre name="a044" id="a044" class="graf graf--pre graf-after--li">document<br>  .getElementById(&quot;that-link&quot;)<br>  .addEventListener(&quot;click&quot;, (e) =&gt; e.preventDefault());</pre><ul class="postList"><li name="d850" id="d850" class="graf graf--li graf-after--pre">This breaks the law but there is way about it because your code needs to know about both elements and you have to use the API provided by the DOM.</li><li name="9dc9" id="9dc9" class="graf graf--li graf-after--li">UI’s will break LoD because they are not object-oriented programs.</li></ul><h3 name="071c" id="071c" class="graf graf--h3 graf-after--li">If you found this guide helpful feel free to checkout my GitHub/gists where I host similar content:</h3><div name="1c2f" id="1c2f" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://gist.github.com/bgoonz" data-href="https://gist.github.com/bgoonz" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://gist.github.com/bgoonz"><strong class="markup--strong markup--mixtapeEmbed-strong">bgoonz’s gists</strong><br><em class="markup--em markup--mixtapeEmbed-em">Instantly share code, notes, and snippets. Web Developer, Electrical Engineer JavaScript | CSS | Bootstrap | Python |…</em>gist.github.com</a><a href="https://gist.github.com/bgoonz" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="ab25adbb500306703daab23d08a7739a" data-thumbnail-img-id="0*3O67jrqm3EHjTK2H" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*3O67jrqm3EHjTK2H);"></a></div><div name="3585" id="3585" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://github.com/bgoonz" data-href="https://github.com/bgoonz" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/bgoonz"><strong class="markup--strong markup--mixtapeEmbed-strong">bgoonz — Overview</strong><br><em class="markup--em markup--mixtapeEmbed-em">Web Developer, Electrical Engineer JavaScript | CSS | Bootstrap | Python | React | Node.js | Express | Sequelize…</em>github.com</a><a href="https://github.com/bgoonz" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="6ee74d5200d495ddc7ddad0c92bd6dce" data-thumbnail-img-id="0*Udg3rbeFyslZ9dyl" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Udg3rbeFyslZ9dyl);"></a></div><h3 name="cb1a" id="cb1a" class="graf graf--h3 graf-after--mixtapeEmbed">Or Checkout my personal Resource Site:</h3><div name="4bce" id="4bce" class="graf graf--mixtapeEmbed graf-after--h3 graf--trailing"><a href="https://web-dev-resource-hub.netlify.app/" data-href="https://web-dev-resource-hub.netlify.app/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://web-dev-resource-hub.netlify.app/"><strong class="markup--strong markup--mixtapeEmbed-strong">Web-Dev-Resource-Hub</strong><br><em class="markup--em markup--mixtapeEmbed-em">Edit description</em>web-dev-resource-hub.netlify.app</a><a href="https://web-dev-resource-hub.netlify.app/" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="142b348a1c3b7cab095decda3afd6236"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bryanguner" class="p-author h-card">Bryan Guner</a> on <a href="https://medium.com/p/d45007d06333"><time class="dt-published" datetime="2021-03-14T03:00:16.806Z">March 14, 2021</time></a>.</p><p><a href="https://medium.com/@bryanguner/object-oriented-programming-in-javascript-d45007d06333" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 10, 2021.</p></footer></article></body></html>