<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Graph Data Structure Interview Questions At A Glance</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Graph Data Structure Interview Questions At A Glance</h1>
</header>
<section data-field="subtitle" class="p-summary">
Because they’re just about the most important data structure there is.
</section>
<section data-field="body" class="e-content">
<section name="2fae" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9a47" id="9a47" class="graf graf--h3 graf--leading graf--title">Graph Data Structure Interview Questions At A Glance</h3><p name="b0b8" id="b0b8" class="graf graf--p graf-after--h3">Because they’re just about the most important data structure there is.</p><figure name="4388" id="4388" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*D_VTiLB2q1sax7Dd.png" data-width="866" data-height="590" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*D_VTiLB2q1sax7Dd.png"></figure><h3 name="3310" id="3310" class="graf graf--h3 graf-after--figure">Graphs</h3><p name="4b50" id="4b50" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">graph</strong>: collections of data represented by nodes and connections between nodes<br><strong class="markup--strong markup--p-strong">graphs</strong>: way to formally represent network; ordered pairs<br><strong class="markup--strong markup--p-strong">graphs</strong>: modeling relations between many items; Facebook friends (you = node; friendship = edge; bidirectional); twitter = unidirectional<br><strong class="markup--strong markup--p-strong">graph theory</strong>: study of graphs<br><strong class="markup--strong markup--p-strong">big O of graphs</strong>: G = V(E)</p><p name="de98" id="de98" class="graf graf--p graf-after--p">trees are a type of graph</p><p name="0366" id="0366" class="graf graf--p graf-after--p">Components required to make a graph:</p><ul class="postList"><li name="ca43" id="ca43" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">nodes or vertices</strong>: represent objects in a dataset (cities, animals, web pages)</li><li name="a2ee" id="a2ee" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">edges</strong>: connections between vertices; can be bidirectional</li><li name="fc4a" id="fc4a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">weight</strong>: cost to travel across an edge; optional (aka cost)</li></ul><p name="c250" id="c250" class="graf graf--p graf-after--li">Useful for:</p><ul class="postList"><li name="769d" id="769d" class="graf graf--li graf-after--p">maps</li><li name="19f3" id="19f3" class="graf graf--li graf-after--li">networks of activity</li><li name="93d9" id="93d9" class="graf graf--li graf-after--li">anything you can represent as a network</li><li name="45a1" id="45a1" class="graf graf--li graf-after--li">multi-way relational data</li></ul><p name="0bef" id="0bef" class="graf graf--p graf-after--li">Types of Graphs:</p><ul class="postList"><li name="f259" id="f259" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">directed</strong>: can only move in one direction along edges; which direction indicated by arrows</li><li name="1bfb" id="1bfb" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">undirected</strong>: allows movement in both directions along edges; bidirectional</li><li name="e813" id="e813" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">cyclic</strong>: weighted; edges allow you to revisit at least 1 vertex; example weather</li><li name="52d4" id="52d4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">acyclical</strong>: vertices can only be visited once; example recipe</li></ul><p name="e254" id="e254" class="graf graf--p graf-after--li">Two common ways to represent graphs in code:</p><ul class="postList"><li name="4380" id="4380" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">adjacency lists</strong>: graph stores list of vertices; for each vertex, it stores list of connected vertices</li><li name="dedc" id="dedc" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">adjacency matrices</strong>: two-dimensional array of lists with built-in edge weights; denotes no relationship</li></ul><p name="37c6" id="37c6" class="graf graf--p graf-after--li">Both have strengths and weaknesses.</p><figure name="c495" id="c495" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*PunyRdBT24D0NkD5AdhL9Q.png" data-width="755" data-height="165" src="https://cdn-images-1.medium.com/max/800/1*PunyRdBT24D0NkD5AdhL9Q.png"></figure><h3 name="6693" id="6693" class="graf graf--h3 graf-after--figure">Questions</h3><h4 name="2081" id="2081" class="graf graf--h4 graf-after--h3">What is a Graph?</h4><p name="e684" id="e684" class="graf graf--p graf-after--h4">A Graph is a data structure that models objects and pairwise relationships between them with nodes and edges. For example: Users and friendships, locations and paths between them, parents and children, etc.</p><h4 name="261a" id="261a" class="graf graf--h4 graf-after--p">Why is it important to learn Graphs?</h4><p name="a861" id="a861" class="graf graf--p graf-after--h4">Graphs represent relationships between data. Anytime you can identify a relationship pattern, you can build a graph and often gain insights through a traversal. These insights can be very powerful, allowing you to find new relationships, like users who have a similar taste in music or purchasing.</p><h4 name="abfe" id="abfe" class="graf graf--h4 graf-after--p">How many types of graphs are there?</h4><p name="943d" id="943d" class="graf graf--p graf-after--h4">Graphs can be directed or undirected, cyclic or acyclic, weighted or unweighted. They can also be represented with different underlying structures including, but not limited to, adjacency lists, adjacency matrices, object and pointers, or a custom solution.</p><h4 name="1a2a" id="1a2a" class="graf graf--h4 graf-after--p">What is the time complexity (big-O) to add/remove/get a vertex/edge for a graph?</h4><p name="3711" id="3711" class="graf graf--p graf-after--h4">It depends on the implementation. (<a href="https://github.com/LambdaSchool/Graphs/tree/master/objectives/graph-representations" data-href="https://github.com/LambdaSchool/Graphs/tree/master/objectives/graph-representations" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Graph Representations</a>). Before choosing an implementation, it is wise to consider the tradeoffs and complexities of the most commonly used operations.</p><h3 name="8332" id="8332" class="graf graf--h3 graf-after--p">Graph Representations</h3><p name="47fe" id="47fe" class="graf graf--p graf-after--h3">The two most common ways to represent graphs in code are adjacency lists and adjacency matrices, each with its own strengths and weaknesses. When deciding on a graph implementation, it’s important to understand the type of data and operations you will be using.</p><figure name="c44f" id="c44f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*J7ZaHRxtBYCkaiQZ.png" data-width="1350" data-height="368" src="https://cdn-images-1.medium.com/max/800/0*J7ZaHRxtBYCkaiQZ.png"></figure><h3 name="9a57" id="9a57" class="graf graf--h3 graf-after--figure">Adjacency List</h3><p name="ccc9" id="ccc9" class="graf graf--p graf-after--h3">In an adjacency list, the graph stores a list of vertices and for each vertex, a list of each vertex to which it’s connected. So, for the following graph…</p><p name="e60a" id="e60a" class="graf graf--p graf-after--p">…an adjacency list in Python could look something like this:</p><pre name="4d61" id="4d61" class="graf graf--pre graf-after--p">class Graph:<br>    def __init__(self):<br>        self.vertices = {<br>                          &quot;A&quot;: {&quot;B&quot;},<br>                          &quot;B&quot;: {&quot;C&quot;, &quot;D&quot;},<br>                          &quot;C&quot;: {&quot;E&quot;},<br>                          &quot;D&quot;: {&quot;F&quot;, &quot;G&quot;},<br>                          &quot;E&quot;: {&quot;C&quot;},<br>                          &quot;F&quot;: {&quot;C&quot;},<br>                          &quot;G&quot;: {&quot;A&quot;, &quot;F&quot;}<br>                        }</pre><p name="f633" id="f633" class="graf graf--p graf-after--pre">Note that this adjacency list doesn’t actually use any lists. The <code class="markup--code markup--p-code">vertices</code> collection is a <code class="markup--code markup--p-code">dictionary</code> which lets us access each collection of edges in O(1) constant time while the edges are contained in a <code class="markup--code markup--p-code">set</code> which lets us check for the existence of edges in O(1) constant time.</p><h3 name="0ecf" id="0ecf" class="graf graf--h3 graf-after--p">Adjacency Matrix</h3><p name="e16f" id="e16f" class="graf graf--p graf-after--h3">Now, let’s see what this graph might look like as an adjacency matrix:</p><pre name="aeac" id="aeac" class="graf graf--pre graf-after--p">class Graph:<br>    def __init__(self):<br>        self.edges = [[0,1,0,0,0,0,0],<br>                      [0,0,1,1,0,0,0],<br>                      [0,0,0,0,1,0,0],<br>                      [0,0,0,0,0,1,1],<br>                      [0,0,1,0,0,0,0],<br>                      [0,0,1,0,0,0,0],<br>                      [1,0,0,0,0,1,0]]</pre><p name="639a" id="639a" class="graf graf--p graf-after--pre">We represent this matrix as a two-dimensional array, or a list of lists. With this implementation, we get the benefit of built-in edge weights but do not have an association between the values of our vertices and their index.</p><p name="cd86" id="cd86" class="graf graf--p graf-after--p">In practice, both of these would probably contain more information by including Vertex or Edge classes.</p><h3 name="84a2" id="84a2" class="graf graf--h3 graf-after--p">Tradeoffs</h3><p name="200c" id="200c" class="graf graf--p graf-after--h3">Both adjacency matrices and adjacency lists have their own strengths and weaknesses. Let’s explore their tradeoffs.</p><p name="9689" id="9689" class="graf graf--p graf-after--p">For the following:</p><pre name="b7ca" id="b7ca" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">V: Total number of vertices in the graph<br>E: Total number of edges in the graph<br>e: Average number of edges per vertex</code></pre><h4 name="8cb3" id="8cb3" class="graf graf--h4 graf-after--pre">Space Complexity</h4><ul class="postList"><li name="f8f8" id="f8f8" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Adjacency Matrix</strong>: O(V ^ 2)</li><li name="1946" id="1946" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Adjacency List</strong>: O(V + E)</li></ul><p name="63ee" id="63ee" class="graf graf--p graf-after--li">Consider a sparse graph with 100 vertices and only one edge. An adjacency list would have to store all 100 vertices but only needs to keep track of that single edge. The adjacency matrix would need to store 100x100=10,000 possible connections, even though all but one would be 0.</p><p name="fe4b" id="fe4b" class="graf graf--p graf-after--p">Now consider a dense graph where each vertex points to each other vertex. In this case, the total number of edges will approach V² so the space complexities of each are comparable. However, dictionaries and sets are less space efficient than lists so for dense graphs, the adjacency matrix is more efficient.</p><p name="d983" id="d983" class="graf graf--p graf-after--p">Takeaway: Adjacency lists are more space efficient for <strong class="markup--strong markup--p-strong">sparse</strong> graphs while adjacency matrices become efficient for <strong class="markup--strong markup--p-strong">dense</strong> graphs.</p><h4 name="bc5b" id="bc5b" class="graf graf--h4 graf-after--p">Add Vertex</h4><ul class="postList"><li name="6257" id="6257" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Adjacency Matrix</strong>: O(V)</li><li name="6a8f" id="6a8f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Adjacency List</strong>: O(1)</li></ul><p name="dc41" id="dc41" class="graf graf--p graf-after--li">Adding a vertex is extremely simple in an adjacency list:</p><pre name="8821" id="8821" class="graf graf--pre graf-after--p">self.vertices[&quot;H&quot;] = set()</pre><p name="a1ab" id="a1ab" class="graf graf--p graf-after--pre">Adding a new key to a dictionary is a constant-time operation.</p><p name="8ae1" id="8ae1" class="graf graf--p graf-after--p">For an adjacency matrix, we would need to add a new value to the end of each existing row, then add a new row at the end.</p><pre name="d87d" id="d87d" class="graf graf--pre graf-after--p">for v in self.edges:<br>  self.edges[v].append(0)<br>v.append([0] * len(self.edges + 1))</pre><p name="df52" id="df52" class="graf graf--p graf-after--pre">Remember that with Python lists, appending to the end of a list is usually O(1) due to over-allocation of memory but can be O(n) when the over-allocated memory fills up. When this occurs, adding the vertex can be O(V²).</p><p name="1322" id="1322" class="graf graf--p graf-after--p">Takeaway: Adding vertices is very efficient in adjacency lists but very inefficient for adjacency matrices.</p><h4 name="8ad9" id="8ad9" class="graf graf--h4 graf-after--p">Remove Vertex</h4><ul class="postList"><li name="8226" id="8226" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Adjacency Matrix</strong>: O(V ^ 2)</li><li name="85fd" id="85fd" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Adjacency List</strong>: O(V)</li></ul><p name="eff2" id="eff2" class="graf graf--p graf-after--li">Removing vertices is pretty inefficient in both representations. In an adjacency matrix, we need to remove the removed vertex’s row, then remove that column from each other row. Removing an element from a list requires moving everything after that element over by one slot which takes an average of V/2 operations. Since we need to do that for every single row in our matrix, that results in a V² time complexity. On top of that, we need to reduce the index of each vertex after our removed index by 1 as well which doesn’t add to our quadratic time complexity, but does add extra operations.</p><p name="c463" id="c463" class="graf graf--p graf-after--p">For an adjacency list, we need to visit each vertex and remove all edges pointing to our removed vertex. Removing elements from sets and dictionaries is a O(1) operation, so this results in an overall O(V) time complexity.</p><p name="6cb3" id="6cb3" class="graf graf--p graf-after--p">Takeaway: Removing vertices is inefficient in both adjacency matrices and lists but more inefficient in matrices.</p><h4 name="0883" id="0883" class="graf graf--h4 graf-after--p">Add Edge</h4><ul class="postList"><li name="dbbe" id="dbbe" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Adjacency Matrix</strong>: O(1)</li><li name="3968" id="3968" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Adjacency List</strong>: O(1)</li></ul><p name="2f96" id="2f96" class="graf graf--p graf-after--li">Adding an edge in an adjacency matrix is quite simple:</p><pre name="7907" id="7907" class="graf graf--pre graf-after--p">self.edges[v1][v2] = 1</pre><p name="3346" id="3346" class="graf graf--p graf-after--pre">Adding an edge in an adjacency list is similarly simple:</p><pre name="f46e" id="f46e" class="graf graf--pre graf-after--p">self.vertices[v1].add(v2)</pre><p name="aed9" id="aed9" class="graf graf--p graf-after--pre">Both are constant-time operations.</p><p name="af5b" id="af5b" class="graf graf--p graf-after--p">Takeaway: Adding edges to both adjacency lists and matrices is very efficient.</p><h4 name="62e9" id="62e9" class="graf graf--h4 graf-after--p">Remove Edge</h4><ul class="postList"><li name="b417" id="b417" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Adjacency Matrix</strong>: O(1)</li><li name="d794" id="d794" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Adjacency List</strong>: O(1)</li></ul><p name="1948" id="1948" class="graf graf--p graf-after--li">Removing an edge from an adjacency matrix is quite simple:</p><pre name="b081" id="b081" class="graf graf--pre graf-after--p">self.edges[v1][v2] = 0</pre><p name="44ad" id="44ad" class="graf graf--p graf-after--pre">Removing an edge from an adjacency list is similarly simple:</p><pre name="0ccf" id="0ccf" class="graf graf--pre graf-after--p">self.vertices[v1].remove(v2)</pre><p name="23b3" id="23b3" class="graf graf--p graf-after--pre">Both are constant-time operations.</p><p name="f085" id="f085" class="graf graf--p graf-after--p">Takeaway: Removing edges from both adjacency lists and matrices is very efficient.</p><h4 name="37de" id="37de" class="graf graf--h4 graf-after--p">Find Edge</h4><ul class="postList"><li name="dc68" id="dc68" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Adjacency Matrix</strong>: O(1)</li><li name="2b87" id="2b87" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Adjacency List</strong>: O(1)</li></ul><p name="17dd" id="17dd" class="graf graf--p graf-after--li">Finding an edge in an adjacency matrix is quite simple:</p><pre name="8377" id="8377" class="graf graf--pre graf-after--p">return self.edges[v1][v2] &gt; 0</pre><p name="8d56" id="8d56" class="graf graf--p graf-after--pre">Finding an edge in an adjacency list is similarly simple:</p><pre name="ab72" id="ab72" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">return v2 in self.vertices[v1]</code></pre><p name="fae3" id="fae3" class="graf graf--p graf-after--pre">Both are constant-time operations.</p><p name="4def" id="4def" class="graf graf--p graf-after--p">Takeaway: Finding edges from both adjacency lists and matrices is very efficient.</p><h4 name="a5a0" id="a5a0" class="graf graf--h4 graf-after--p">Get All Edges from Vertex</h4><ul class="postList"><li name="798e" id="798e" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Adjacency Matrix</strong>: O(V)</li><li name="fa79" id="fa79" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Adjacency List</strong>: O(1)</li></ul><p name="5feb" id="5feb" class="graf graf--p graf-after--li">Say you want to know all the edges originating from a particular vertex. With an adjacency list, this is as simple as returning the value from the vertex dictionary:</p><pre name="ab0e" id="ab0e" class="graf graf--pre graf-after--p">return self.vertex[v]</pre><p name="a5e1" id="a5e1" class="graf graf--p graf-after--pre">In an adjacency matrix, however, it’s a bit more complicated. You would need to iterate through the entire row and populate a list based on the results:</p><pre name="6b51" id="6b51" class="graf graf--pre graf-after--p">v_edges = []<br>for v2 in self.edges[v]:<br>    if self.edges[v][v2] &gt; 0:<br>        v_edges.append(v2)<br>return v_edges</pre><p name="2440" id="2440" class="graf graf--p graf-after--pre">Takeaway: Fetching all edges is more efficient in an adjacency list than an adjacency matrix.</p><h3 name="13c6" id="13c6" class="graf graf--h3 graf-after--p">Breadth-First Search</h3><p name="3d1d" id="3d1d" class="graf graf--p graf-after--h3">Can use breadth-first search when searching a graph; explores graph outward in rings of increasing distance from starting vertex; never attempts to explore vertex it is or has already explored</p><h4 name="1611" id="1611" class="graf graf--h4 graf-after--p">BFS</h4><figure name="9d1a" id="9d1a" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*WOvrysI4fX6ePqN-.gif" data-width="350" data-height="350" src="https://cdn-images-1.medium.com/max/800/0*WOvrysI4fX6ePqN-.gif"></figure><h3 name="b22b" id="b22b" class="graf graf--h3 graf-after--figure">Applications of BFS</h3><ul class="postList"><li name="149a" id="149a" class="graf graf--li graf-after--h3">pathfinding, routing</li><li name="9ab5" id="9ab5" class="graf graf--li graf-after--li">web crawlers</li><li name="31af" id="31af" class="graf graf--li graf-after--li">find neighbor nodes in P2P network</li><li name="13aa" id="13aa" class="graf graf--li graf-after--li">finding people/connections away on social network</li><li name="4f5f" id="4f5f" class="graf graf--li graf-after--li">find neighboring locations on graph</li><li name="d1b5" id="d1b5" class="graf graf--li graf-after--li">broadcasting on a network</li><li name="4061" id="4061" class="graf graf--li graf-after--li">cycle detection in a graph</li><li name="0f7f" id="0f7f" class="graf graf--li graf-after--li">finding connected components</li><li name="a86f" id="a86f" class="graf graf--li graf-after--li">solving several theoretical graph problems</li></ul><h3 name="1639" id="1639" class="graf graf--h3 graf-after--li">Coloring BFS</h3><p name="8f9e" id="8f9e" class="graf graf--p graf-after--h3">It’s useful to color vertexes as you arrive at them and as you leave them behind as already searched.</p><p name="0129" id="0129" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">unlisted</strong>: white<br><strong class="markup--strong markup--p-strong">vertices whose neighbors are being explored</strong>: gray<br><strong class="markup--strong markup--p-strong">vertices with no unexplored neighbors</strong>: black</p><h3 name="886e" id="886e" class="graf graf--h3 graf-after--p">BFS Pseudocode</h3><pre name="8fc3" id="8fc3" class="graf graf--pre graf-after--h3">def BFS(graph, start_vert):<br>    for v of graph.vertices:<br>        v.color = white<br>    start_vert.color = gray<br>    queue.enqueue(start_vert)<br>    while !queue isEmpty():<br>    # peek at head but don&#39;t dequeue<br>    u = queue[0]<br>    for v of u.neighbors:<br>        if v.color == white:<br>            v.color == gray<br>            queue.enqueue(v)<br>    queue.dequeue()<br>    u.color = black</pre><h3 name="c5f0" id="c5f0" class="graf graf--h3 graf-after--pre">BFS Steps</h3><ol class="postList"><li name="ccee" id="ccee" class="graf graf--li graf-after--h3">Mark graph vertices white.</li><li name="26e7" id="26e7" class="graf graf--li graf-after--li">Mark starting vertex gray.</li><li name="863c" id="863c" class="graf graf--li graf-after--li">Enqueue starting vertex.</li><li name="b8d8" id="b8d8" class="graf graf--li graf-after--li">Check if queue is not empty.</li><li name="2dc5" id="2dc5" class="graf graf--li graf-after--li">If not empty, peek at first item in queue.</li><li name="0e5c" id="0e5c" class="graf graf--li graf-after--li">Loop through that vertex’s neighbors.</li><li name="1a9e" id="1a9e" class="graf graf--li graf-after--li">Check if unvisited.</li><li name="7165" id="7165" class="graf graf--li graf-after--li">If unvisited, mark as gray and enqueue vertex.</li><li name="338b" id="338b" class="graf graf--li graf-after--li">Dequeue current vertex and mark as black.</li><li name="8460" id="8460" class="graf graf--li graf-after--li">Repeat until all vertices are explored.</li></ol><h3 name="f784" id="f784" class="graf graf--h3 graf-after--li">Depth-First Search</h3><p name="9d93" id="9d93" class="graf graf--p graf-after--h3">dives down the graph as far as it can before backtracking and exploring another branch; never attempts to explore a vertex it has already explored or is in the process of exploring; exact order will vary depending on which branches get taken first and which is starting vertex</p><h4 name="29a5" id="29a5" class="graf graf--h4 graf-after--p">DFS:</h4><figure name="2fd3" id="2fd3" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*DZVdn1kWaiJXQ_zc.gif" data-width="500" data-height="500" src="https://cdn-images-1.medium.com/max/800/0*DZVdn1kWaiJXQ_zc.gif"></figure><h3 name="637b" id="637b" class="graf graf--h3 graf-after--figure">Applications of DFS</h3><ul class="postList"><li name="044e" id="044e" class="graf graf--li graf-after--h3">preferred method for exploring a graph if we want to ensure we visit every node in graph</li><li name="b086" id="b086" class="graf graf--li graf-after--li">finding minimum spanning trees of weighted graphs</li><li name="c419" id="c419" class="graf graf--li graf-after--li">pathfinding</li><li name="281e" id="281e" class="graf graf--li graf-after--li">detecting cycles in graphs</li><li name="6739" id="6739" class="graf graf--li graf-after--li">solving and generating mazes</li><li name="20b5" id="20b5" class="graf graf--li graf-after--li">topological sorting, useful for scheduling sequences of dependent jobs</li></ul><h3 name="76b9" id="76b9" class="graf graf--h3 graf-after--li">DFS Pseudocode</h3><pre name="a140" id="a140" class="graf graf--pre graf-after--h3"># recursion<br>def explore(graph):<br>    visit(this_vert)<br>    explore(remaining_graph)</pre><pre name="9d4d" id="9d4d" class="graf graf--pre graf-after--pre"># iterative<br>def DFS(graph):<br>    for v of graph.verts:<br>        v.color = white<br>        v.parent = null<br>    for v of graph.verts:<br>        if v.color == white:<br>            DFS_visit(v)</pre><pre name="ad6e" id="ad6e" class="graf graf--pre graf-after--pre">def DFS_visit(v):<br>    v.color = gray<br>    for neighbor of v.adjacent_nodes:<br>        if neighbor.color == white:<br>            neighbor.parent = v<br>            DFS_visit(neighbor)<br>    v.color = black</pre><h3 name="c928" id="c928" class="graf graf--h3 graf-after--pre">DFS Steps</h3><ol class="postList"><li name="b45a" id="b45a" class="graf graf--li graf-after--h3">Take graph as parameter.</li><li name="a012" id="a012" class="graf graf--li graf-after--li">Marks all vertices as unvisited.</li><li name="1bd5" id="1bd5" class="graf graf--li graf-after--li">Sets vertex parent as null.</li><li name="0f24" id="0f24" class="graf graf--li graf-after--li">Passes each unvisited vertex into DFS_visit().</li><li name="9011" id="9011" class="graf graf--li graf-after--li">Mark current vertex as gray.</li><li name="8df7" id="8df7" class="graf graf--li graf-after--li">Loops through its unvisited neighbors.</li><li name="927d" id="927d" class="graf graf--li graf-after--li">Sets parent and makes recursive call to DFS_visit().</li><li name="6d4c" id="6d4c" class="graf graf--li graf-after--li">Marks vertex as black.</li><li name="e753" id="e753" class="graf graf--li graf-after--li">Repeat until done.</li></ol><h3 name="bd8f" id="bd8f" class="graf graf--h3 graf-after--li">Connected Components</h3><p name="3289" id="3289" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">connected components</strong>: in a disjoint graph, groups of nodes on a graph that are connected with each other</p><h3 name="d7e5" id="d7e5" class="graf graf--h3 graf-after--p">Uses</h3><ul class="postList"><li name="0c54" id="0c54" class="graf graf--li graf-after--h3">typically very large graphs, networks</li><li name="1bdc" id="1bdc" class="graf graf--li graf-after--li">social networks</li><li name="66be" id="66be" class="graf graf--li graf-after--li">networks (which devices can reach one another)</li><li name="210c" id="210c" class="graf graf--li graf-after--li">epidemics (how spread, who started, where next)</li></ul><p name="1556" id="1556" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">key to finding connected components</strong>: searching algorithms, breadth-first search</p><h3 name="2f14" id="2f14" class="graf graf--h3 graf-after--p">How to find connected componnents</h3><ul class="postList"><li name="4bd0" id="4bd0" class="graf graf--li graf-after--h3">for each node in graph:</li><li name="6e20" id="6e20" class="graf graf--li graf-after--li">has it been explored</li><li name="40be" id="40be" class="graf graf--li graf-after--li">if no, do BFS</li><li name="96f4" id="96f4" class="graf graf--li graf-after--li">all nodes reached are connected</li><li name="e152" id="e152" class="graf graf--li graf-after--li">if yes, already in connected component</li><li name="3f15" id="3f15" class="graf graf--li graf-after--li">go to next node</li></ul><p name="01ba" id="01ba" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">strongly connected components</strong>: any node in this group can get to any other node</p><figure name="079c" id="079c" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/5f6cfb85d684629aa2e0d5eea35edacb.js"></script></figure><h3 name="d4d3" id="d4d3" class="graf graf--h3 graf-after--figure">Bonus Python Question:</h3><pre name="5507" id="5507" class="graf graf--pre graf-after--h3">&#39;&#39;&#39;</pre><pre name="7a51" id="7a51" class="graf graf--pre graf-after--pre">This Bellman-Ford Code is for determination whether we can get</pre><pre name="70f9" id="70f9" class="graf graf--pre graf-after--pre">shortest path from given graph or not for single-source shortest-paths problem.</pre><pre name="be11" id="be11" class="graf graf--pre graf-after--pre">In other words, if given graph has any negative-weight cycle that is reachable</pre><pre name="8f28" id="8f28" class="graf graf--pre graf-after--pre">from the source, then it will give answer False for &quot;no solution exits&quot;.</pre><pre name="a068" id="a068" class="graf graf--pre graf-after--pre">For argument graph, it should be a dictionary type</pre><pre name="a3a9" id="a3a9" class="graf graf--pre graf-after--pre">such as</pre><pre name="2d1a" id="2d1a" class="graf graf--pre graf-after--pre">graph = {</pre><pre name="95b8" id="95b8" class="graf graf--pre graf-after--pre">&#39;a&#39;: {&#39;b&#39;: 6, &#39;e&#39;: 7},</pre><pre name="e1da" id="e1da" class="graf graf--pre graf-after--pre">&#39;b&#39;: {&#39;c&#39;: 5, &#39;d&#39;: -4, &#39;e&#39;: 8},</pre><pre name="763d" id="763d" class="graf graf--pre graf-after--pre">&#39;c&#39;: {&#39;b&#39;: -2},</pre><pre name="f768" id="f768" class="graf graf--pre graf-after--pre">&#39;d&#39;: {&#39;a&#39;: 2, &#39;c&#39;: 7},</pre><pre name="3ed2" id="3ed2" class="graf graf--pre graf-after--pre">&#39;e&#39;: {&#39;b&#39;: -3}</pre><pre name="a6d5" id="a6d5" class="graf graf--pre graf-after--pre">}</pre><figure name="d6ff" id="d6ff" class="graf graf--figure graf--iframe graf-after--pre"><script src="https://gist.github.com/bgoonz/00eedbab69557037d0e768a5ecb92d2c.js"></script></figure><h3 name="dd1c" id="dd1c" class="graf graf--h3 graf-after--figure">Review of Concepts:</h3></div><div class="section-inner sectionLayout--outsetColumn"><figure name="0d25" id="0d25" class="graf graf--figure graf--layoutOutsetCenter graf-after--h3"><img class="graf-image" data-image-id="0*oOYEgDBV2yhim9SC" data-width="1700" data-height="956" src="https://cdn-images-1.medium.com/max/1200/0*oOYEgDBV2yhim9SC"></figure></div><div class="section-inner sectionLayout--insetColumn"><ul class="postList"><li name="9d7a" id="9d7a" class="graf graf--li graf-after--figure">A graph is any collection of nodes and edges.</li><li name="7a3a" id="7a3a" class="graf graf--li graf-after--li">A graph is a less restrictive class of collections of nodes than structures like a tree.</li><li name="8d05" id="8d05" class="graf graf--li graf-after--li">It doesn’t need to have a root node (not every node needs to be accessible from a single node)</li><li name="6fac" id="6fac" class="graf graf--li graf-after--li">It can have cycles (a group of nodes whose paths begin and end at the same node)</li></ul><figure name="adfd" id="adfd" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*nN2X6TCy0JSh4mfL.gif" data-width="354" data-height="335" src="https://cdn-images-1.medium.com/max/800/0*nN2X6TCy0JSh4mfL.gif"><figcaption class="imageCaption">Cycles in a graph</figcaption></figure><ul class="postList"><li name="783b" id="783b" class="graf graf--li graf-after--figure">Cycles are not always “isolated”, they can be one part of a larger graph. You can detect them by starting your search on a specific node and finding a path that takes you back to that same node.</li></ul><figure name="cfaa" id="cfaa" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*0EdGqDUlj_HEnyEc.png" data-width="639" data-height="669" src="https://cdn-images-1.medium.com/max/800/0*0EdGqDUlj_HEnyEc.png"></figure><ul class="postList"><li name="fe92" id="fe92" class="graf graf--li graf-after--figure">Any number of edges may leave a given node</li><li name="915b" id="915b" class="graf graf--li graf-after--li">A Path is a sequence of nodes on a graph</li></ul><h3 name="465e" id="465e" class="graf graf--h3 graf-after--li">Undirected Graph</h3><p name="484f" id="484f" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Undirected Graph: </strong>An undirected graph is one where the edges do not specify a particular direction. The edges are bi-directional.</p><h3 name="c390" id="c390" class="graf graf--h3 graf-after--p">Types:</h3><figure name="891f" id="891f" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*u8Nu829gPtxU6J0siwljJA.png" data-width="926" data-height="821" src="https://cdn-images-1.medium.com/max/800/1*u8Nu829gPtxU6J0siwljJA.png"></figure><h3 name="b62e" id="b62e" class="graf graf--h3 graf-after--figure">Dense Graph</h3><ul class="postList"><li name="7b24" id="7b24" class="graf graf--li graf-after--h3">Dense Graph — A graph with lots of edges.</li><li name="5682" id="5682" class="graf graf--li graf--startsWithDoubleQuote graf-after--li">“Dense graphs have many edges. But, wait! ⚠️ I know what you must be thinking, how can you determine what qualifies as “many edges”? This is a little bit too subjective, right? ? I agree with you, so let’s quantify it a little bit:</li><li name="0e05" id="0e05" class="graf graf--li graf-after--li">Let’s find the maximum number of edges in a directed graph. If there are |V| nodes in a directed graph (in the example below, six nodes), that means that each node can have up to |v| connections (in the example below, six connections).</li><li name="59d8" id="59d8" class="graf graf--li graf-after--li">Why? Because each node could potentially connect with all other nodes and with itself (see “loop” below). Therefore, the maximum number of edges that the graph can have is |V|\*|V| , which is the total number of nodes multiplied by the maximum number of connections that each node can have.”</li><li name="146f" id="146f" class="graf graf--li graf-after--li">When the number of edges in the graph is close to the maximum number of edges, the graph is dense.</li></ul><h3 name="1834" id="1834" class="graf graf--h3 graf-after--li">Sparse Graph</h3><ul class="postList"><li name="5e53" id="5e53" class="graf graf--li graf-after--h3">Sparse Graph — Few edges</li><li name="37f5" id="37f5" class="graf graf--li graf-after--li">When the number of edges in the graph is significantly fewer than the maximum number of edges, the graph is sparse.</li></ul><h3 name="46d9" id="46d9" class="graf graf--h3 graf-after--li">Weighted Graph</h3><ul class="postList"><li name="755c" id="755c" class="graf graf--li graf-after--h3">Weighted Graph — Edges have a cost or a weight to traversal</li></ul><h3 name="7b88" id="7b88" class="graf graf--h3 graf-after--li">Directed Graph</h3><ul class="postList"><li name="416f" id="416f" class="graf graf--li graf-after--h3">Directed Graph — Edges only go one direction</li></ul><h3 name="cd78" id="cd78" class="graf graf--h3 graf-after--li"><em class="markup--em markup--h3-em">Undirected </em>Graph</h3><ul class="postList"><li name="6030" id="6030" class="graf graf--li graf-after--h3">Undirected Graph — Edges don’t have a direction. All graphs are assumed to be undirected unless otherwise stated</li></ul><h3 name="dda9" id="dda9" class="graf graf--h3 graf-after--li">Node Class</h3><p name="cdd4" id="cdd4" class="graf graf--p graf-after--h3">Uses a class to define the neighbors as properties of each node.</p><figure name="239d" id="239d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/RelativeTech/95fd9b2285bdbd271708460e13188c91.js"></script></figure><h3 name="09dd" id="09dd" class="graf graf--h3 graf-after--figure">Adjacency Matrix</h3><p name="d543" id="d543" class="graf graf--p graf-after--h3">The row index will correspond to the source of an edge and the column index will correspond to the edges destination.</p><ul class="postList"><li name="ab18" id="ab18" class="graf graf--li graf-after--p">When the edges have a direction, <code class="markup--code markup--li-code">matrix[i][j]</code> may not be the same as <code class="markup--code markup--li-code">matrix[j][i]</code></li><li name="3499" id="3499" class="graf graf--li graf-after--li">It is common to say that a node is adjacent to itself so <code class="markup--code markup--li-code">matrix[x][x]</code> is true for any node</li><li name="9883" id="9883" class="graf graf--li graf-after--li">Will be O(n²) space complexity</li></ul><figure name="c00e" id="c00e" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*2bAUSiq_ej3XTSUMryjJUA.png" data-width="677" data-height="571" src="https://cdn-images-1.medium.com/max/800/1*2bAUSiq_ej3XTSUMryjJUA.png"></figure><h3 name="bce0" id="bce0" class="graf graf--h3 graf-after--figure">Adjacency List</h3><p name="9306" id="9306" class="graf graf--p graf-after--h3">Seeks to solve the shortcomings of the matrix implementation. It uses an object where keys represent node labels and values associated with that key are the adjacent node keys held in an array.</p><figure name="ae3b" id="ae3b" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/RelativeTech/8879520cebc99fdb25c0afe7cf87cfdf.js"></script></figure></div><div class="section-inner sectionLayout--outsetColumn"><figure name="df36" id="df36" class="graf graf--figure graf--iframe graf--layoutOutsetCenter graf-after--figure graf--trailing"><iframe src="https://replit.com/@RelativeTech/GraphADS?lite=true&amp;amp%3Breferrer=https%3A%2F%2Fbryanguner.medium.com" width="1192" height="894" frameborder="0" scrolling="no"></iframe></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bryanguner" class="p-author h-card">Bryan Guner</a> on <a href="https://medium.com/p/fc6b1afbd8be"><time class="dt-published" datetime="2021-06-03T21:34:39.951Z">June 3, 2021</time></a>.</p><p><a href="https://medium.com/@bryanguner/verbal-technical-interview-questions-about-graph-data-structures-fc6b1afbd8be" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 10, 2021.</p></footer></article></body></html>