<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>The ExpressJS Way To Write APIs</title><body><article class="h-entry">
<header>
<h1 class="p-name">The ExpressJS Way To Write APIs</h1>
</header>
<section data-field="subtitle" class="p-summary">
This article will cover the basics of express from the perspective of a beginner without concerning its self with the underlying mechanisms…
</section>
<section data-field="body" class="e-content">
<section name="683a" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="230f" id="230f" class="graf graf--h3 graf--leading graf--title">The ExpressJS Way To Write APIs</h3><h4 name="6e52" id="6e52" class="graf graf--h4 graf-after--h3 graf--subtitle">This article will cover the basics of express from the perspective of a beginner without concerning its self with the underlying mechanisms and theory that underlies the application of the framework.</h4><figure name="4db5" id="4db5" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*yUozFGA0FQpjcXFf.gif" data-width="714" data-height="426" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*yUozFGA0FQpjcXFf.gif"></figure><h3 name="4100" id="4100" class="graf graf--h3 graf-after--figure">For starters, what is express JS¿</h3><p name="5b74" id="5b74" class="graf graf--p graf-after--h3">When introduced, node.js gave developers the chance to use JavaScript to write software that, up to that point, could only be written using lower level languages like C, C++, Java, Python…</p><p name="777a" id="777a" class="graf graf--p graf-after--p">This tutorial will cover how to write <strong class="markup--strong markup--p-strong">web services</strong> that can communicate with clients (the front end application) using <strong class="markup--strong markup--p-strong">J</strong>ava<strong class="markup--strong markup--p-strong">S</strong>cript <strong class="markup--strong markup--p-strong">O</strong>bject <strong class="markup--strong markup--p-strong">N</strong>otation (JSON).</p><ul class="postList"><li name="5334" id="5334" class="graf graf--li graf-after--p">JavaScript is asynchronous, which allows us to take full advantage of the processor it’s running on. Taking full advantage of the processor is crucial because the node process will be running on a single CPU.</li><li name="0b8b" id="0b8b" class="graf graf--li graf-after--li">Using JavaScript gives us access to the npm repository. This repository is the largest ecosystem of useful libraries (most of them free to use) in <strong class="markup--strong markup--li-strong">npm modules</strong>.</li></ul><figure name="3796" id="3796" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*PTKhCN2p9S8EDZ4r.gif" data-width="800" data-height="600" src="https://cdn-images-1.medium.com/max/800/0*PTKhCN2p9S8EDZ4r.gif"></figure></div><div class="section-inner sectionLayout--outsetColumn"><figure name="3b72" id="3b72" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure"><img class="graf-image" data-image-id="1*nGyJHK1Q_sSB6fjbBbF3xA.png" data-width="1200" data-height="25" src="https://cdn-images-1.medium.com/max/1200/1*nGyJHK1Q_sSB6fjbBbF3xA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="3e6e" id="3e6e" class="graf graf--h3 graf-after--figure">Explain what Node.js is and its core features</h3><p name="291d" id="291d" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--h3"><span class="graf-dropCap">T</span>raditionally, developers only used the JavaScript language in web browsers. But, in 2009, <strong class="markup--strong markup--p-strong">Node.js</strong> was unveiled, and with it, the developer tool kit expanded greatly. Node.js gave developers the chance to use JavaScript to write software that, up to that point, could only be written using C, C++, Java, Python, Ruby, C#, and the like.</p><p name="c033" id="c033" class="graf graf--p graf-after--p">We will use Node to write server code. Specifically, <strong class="markup--strong markup--p-strong">web services</strong> that can communicate with clients using the <strong class="markup--strong markup--p-strong">J</strong>ava<strong class="markup--strong markup--p-strong">S</strong>cript <strong class="markup--strong markup--p-strong">O</strong>bject <strong class="markup--strong markup--p-strong">N</strong>otation (JSON) format for data interchange.</p><p name="7e38" id="7e38" class="graf graf--p graf-after--p">Some of the advantages of using Node.js for writing server-side code are:</p><ul class="postList"><li name="51f9" id="51f9" class="graf graf--li graf-after--p">Uses the same programming language (JavaScript) and paradigm for both client and server. Using the same language, we minimize context switching and make it easy to share code between the client and the server.</li><li name="ad6f" id="ad6f" class="graf graf--li graf-after--li">JavaScript is single-threaded, which removes the complexity involved in handling multiple threads.</li><li name="c797" id="c797" class="graf graf--li graf-after--li">JavaScript is asynchronous, which allows us to take full advantage of the processor it’s running on. Taking full advantage of the processor is crucial because the node process will be running on a single CPU.</li><li name="7654" id="7654" class="graf graf--li graf-after--li">Using JavaScript gives us access to the npm repository. This repository is the largest ecosystem of useful libraries (most of them free to use) in <strong class="markup--strong markup--li-strong">npm modules</strong>.</li></ul><p name="8d36" id="8d36" class="graf graf--p graf-after--li">Some of the disadvantages of using Node.js for writing server-side code are:</p><ul class="postList"><li name="0f56" id="0f56" class="graf graf--li graf-after--p">By strictly using JavaScript on the server, we lose the ability to use the right tool (a particular language) for the job.</li><li name="cd1e" id="cd1e" class="graf graf--li graf-after--li">Because JavaScript is single-threaded, we can’t take advantage of servers with multiple cores/processors.</li><li name="12c7" id="12c7" class="graf graf--li graf-after--li">Because JavaScript is asynchronous, it is harder to learn for developers that have only worked with languages that default to synchronous operations that block the execution thread.</li><li name="07dc" id="07dc" class="graf graf--li graf-after--li">In the npm repository, there are often too many packages that do the same thing. This excess of packages makes it harder to choose one and, in some cases, may introduce vulnerabilities into our code.</li></ul><p name="39cb" id="39cb" class="graf graf--p graf-after--li">To write a simple web server with <code class="markup--code markup--p-code">Node.js</code>:</p><ol class="postList"><li name="b4ff" id="b4ff" class="graf graf--li graf-after--p">Use Node’s <code class="markup--code markup--li-code">HTTP</code> module to abstract away complex network-related operations.</li><li name="9e58" id="9e58" class="graf graf--li graf-after--li">Write the single <strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">request handler</em></strong> function to handle all requests to the server.</li></ol><p name="c5e2" id="c5e2" class="graf graf--p graf-after--li">The request handler is a function that takes the <code class="markup--code markup--p-code">request</code> coming from the client and produces the <code class="markup--code markup--p-code">response</code>. The function takes two arguments: 1) an object representing the <code class="markup--code markup--p-code">request</code> and 2) an object representing the <code class="markup--code markup--p-code">response</code>.</p><p name="9d9d" id="9d9d" class="graf graf--p graf-after--p">This process works, but the resulting code is verbose, even for the simplest of servers. Also, note that when using only Node.js to build a server, we use a single request handler function for all requests.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="53b3" id="53b3" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*nGyJHK1Q_sSB6fjbBbF3xA.png" data-width="1200" data-height="25" src="https://cdn-images-1.medium.com/max/1200/1*nGyJHK1Q_sSB6fjbBbF3xA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="970f" id="970f" class="graf graf--h3 graf-after--figure">Try It Out:</h3><p name="5054" id="5054" class="graf graf--p graf-after--h3">Using only Node.js, let’s write a simple web server that returns a message. Create a folder for the server and add an <code class="markup--code markup--p-code">index.js</code> file inside.</p><p name="161d" id="161d" class="graf graf--p graf-after--p">Next, add the following code to the <code class="markup--code markup--p-code">index.js</code> file:</p><pre name="2268" id="2268" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const http = require(&quot;http&quot;); // built in node.js module to handle http traffic</code></pre><pre name="7d96" id="7d96" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const hostname = &quot;127.0.0.1&quot;; // the local computer where the server is running<br>const port = 3000; // a port we&#39;ll use to watch for traffic</code></pre><pre name="4c3f" id="4c3f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const server = http.createServer((req, res) =&gt; {<br>    // creates our server<br>    res.statusCode = 200; // http status code returned to the client<br>    res.setHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;); // inform the client that we&#39;ll be returning text<br>    res.end(&quot;Hello World from Node\\n&quot;); // end the request and send a response with the specified message<br>});</code></pre><pre name="2fa3" id="2fa3" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">server.listen(port, hostname, () =&gt; {<br>    // start watching for connections on the port specified<br>    console.log(`Server running at &lt;http://$&gt;{hostname}:${port}/`);<br>});</code></pre><p name="6ee3" id="6ee3" class="graf graf--p graf-after--pre">Now navigate to the folder in a terminal/console window and type: <code class="markup--code markup--p-code">node index.js</code> to execute your file. A message that reads &quot;<em class="markup--em markup--p-em">Server running at </em><a href="http://127.0.0.1:3000" data-href="http://127.0.0.1:3000" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">http://127.0.0.1:3000</em></a>&quot; should be displayed, and the server is now waiting for connections.</p><p name="8c3f" id="8c3f" class="graf graf--p graf-after--p">Open a browser and visit: <code class="markup--code markup--p-code">http://localhost:3000</code>. <code class="markup--code markup--p-code">localhost</code> and the IP address <code class="markup--code markup--p-code">127.0.0.1</code> point to the same thing: your local computer. The browser should show the message: &quot;<em class="markup--em markup--p-em">Hello World from Node</em>&quot;. There you have it, your first web server, built from scratch using nothing but <code class="markup--code markup--p-code">Node.js</code>.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="9191" id="9191" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*nGyJHK1Q_sSB6fjbBbF3xA.png" data-width="1200" data-height="25" src="https://cdn-images-1.medium.com/max/1200/1*nGyJHK1Q_sSB6fjbBbF3xA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="bb8e" id="bb8e" class="graf graf--h3 graf-after--figure">Explain what Express is and its core features:</h3><p name="5251" id="5251" class="graf graf--p graf-after--h3">Node’s built-in <code class="markup--code markup--p-code">HTTP</code> module provides a powerful way to build web applications and services. However, it requires a lot of code for everyday tasks like sending an HTML page to the browser.</p><p name="b670" id="b670" class="graf graf--p graf-after--p">Introducing Express, a light and unopinionated framework that <strong class="markup--strong markup--p-strong">sits on top of Node.js</strong>, making it easier to create web applications and services. Sending an HTML file or image is now a one-line task with the <code class="markup--code markup--p-code">sendFile</code> helper method in <code class="markup--code markup--p-code">Express</code>.</p><p name="1b85" id="1b85" class="graf graf--p graf-after--p">Ultimately, Express is <strong class="markup--strong markup--p-strong">just a Node.js module</strong> like any other module.</p><p name="7948" id="7948" class="graf graf--p graf-after--p">What can we do with Express? So many things! For example:</p><ul class="postList"><li name="0317" id="0317" class="graf graf--li graf-after--p">Build web applications.</li><li name="6ae8" id="6ae8" class="graf graf--li graf-after--li">Serve <em class="markup--em markup--li-em">Single Page Applications</em> (SPAs).</li><li name="308c" id="308c" class="graf graf--li graf-after--li">Build RESTful web services that work with JSON.</li><li name="7a9e" id="7a9e" class="graf graf--li graf-after--li">Serve static content, like HTML files, images, audio files, PDFs, and more.</li><li name="823e" id="823e" class="graf graf--li graf-after--li">Power real-time applications using technologies like <strong class="markup--strong markup--li-strong">Web Sockets</strong> or <strong class="markup--strong markup--li-strong">WebRTC</strong>.</li></ul><p name="575e" id="575e" class="graf graf--p graf-after--li">Some of the benefits of using Express are that it is:</p><ul class="postList"><li name="fdf7" id="fdf7" class="graf graf--li graf-after--p">Simple</li><li name="7f62" id="7f62" class="graf graf--li graf-after--li">Unopinionated</li><li name="63a7" id="63a7" class="graf graf--li graf-after--li">Extensible</li><li name="09a9" id="09a9" class="graf graf--li graf-after--li">Light-weight</li><li name="d44f" id="d44f" class="graf graf--li graf-after--li">Compatible with <a href="https://www.npmjs.com/package/connect" data-href="https://www.npmjs.com/package/connect" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">connect middleware (Links to an external site.)</a>. This compatibility means we can tap into an extensive collection of modules written for <code class="markup--code markup--li-code">connect</code>.</li><li name="6dbf" id="6dbf" class="graf graf--li graf-after--li">All packaged into a clean, intuitive, and easy-to-use API.</li><li name="cc47" id="cc47" class="graf graf--li graf-after--li">Abstracts away common tasks (writing web applications can be verbose, hence the need for a library like this).</li></ul><p name="85d3" id="85d3" class="graf graf--p graf-after--li">Some of the drawbacks of Express are:</p><ul class="postList"><li name="e9d2" id="e9d2" class="graf graf--li graf-after--p">It’s not a one-stop solution. Because of its simplicity, it does very little out of the box. Especially when compared to frameworks like <strong class="markup--strong markup--li-strong">Ruby on Rails</strong> and <strong class="markup--strong markup--li-strong">Django</strong>.</li><li name="9bb7" id="9bb7" class="graf graf--li graf-after--li">We are forced to make more decisions due to the flexibility and control it provides.</li></ul><h3 name="1abb" id="1abb" class="graf graf--h3 graf-after--li">Main Features of Express</h3><div name="415e" id="415e" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://expressjs.com/en/guide/writing-middleware.html" data-href="https://expressjs.com/en/guide/writing-middleware.html" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://expressjs.com/en/guide/writing-middleware.html"><strong class="markup--strong markup--mixtapeEmbed-strong">Writing middleware for use in Express apps</strong><br><em class="markup--em markup--mixtapeEmbed-em">Middleware functions are functions that have access to the request object ( req), the response object ( res), and the…</em>expressjs.com</a><a href="https://expressjs.com/en/guide/writing-middleware.html" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="9273508283e319a7f84046f8a6647696" data-thumbnail-img-id="0*hnXqAKdkVqTquj5v" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*hnXqAKdkVqTquj5v);"></a></div><figure name="f644" id="f644" class="graf graf--figure graf-after--mixtapeEmbed"><img class="graf-image" data-image-id="0*rdSEy1R5exC2Rpul.png" data-width="410" data-height="308" src="https://cdn-images-1.medium.com/max/800/0*rdSEy1R5exC2Rpul.png"></figure><h3 name="bb8d" id="bb8d" class="graf graf--h3 graf-after--figure">Middleware</h3><p name="01f5" id="01f5" class="graf graf--p graf-after--h3">Middleware functions can get the request and response objects, operate on them, and (when specified) trigger some action. Examples are logging or security.</p><p name="2d3e" id="2d3e" class="graf graf--p graf-after--p">Express’s middleware stack is an array of functions.</p><p name="e63f" id="e63f" class="graf graf--p graf-after--p">Middleware <em class="markup--em markup--p-em">can</em> change the request or response, but it doesn’t have to.</p><h3 name="b633" id="b633" class="graf graf--h3 graf-after--p">Routing</h3><p name="b13a" id="b13a" class="graf graf--p graf-after--h3">Routing is a way to select which request handler function is executed. It does so based on the URL visited and the HTTP method used. Routing provides a way to break an application into smaller parts.</p><h3 name="6d73" id="6d73" class="graf graf--h3 graf-after--p">Routers for Application Modularity</h3><p name="5b3b" id="5b3b" class="graf graf--p graf-after--h3">We can break up applications into <strong class="markup--strong markup--p-strong">routers</strong>. We could have a router to serve our SPA and another router for our API. Each router can have its own middleware and routing. This combination provides improved functionality.</p><h3 name="1e2e" id="1e2e" class="graf graf--h3 graf-after--p">Convenience Helpers</h3><p name="dd75" id="dd75" class="graf graf--p graf-after--h3">Express has many helpers that provide out of the box functionality to make writing web applications and API servers easier.</p><p name="691e" id="691e" class="graf graf--p graf-after--p">A lot of those helpers are extension methods added to the request and response objects.</p><p name="fe19" id="fe19" class="graf graf--p graf-after--p">Examples <a href="https://expressjs.com/en/4x/api.html" data-href="https://expressjs.com/en/4x/api.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">from the Api Reference (Links to an external site.)</a> include: <code class="markup--code markup--p-code">response.redirect()</code>, <code class="markup--code markup--p-code">response.status()</code>, <code class="markup--code markup--p-code">response.send()</code>, and <code class="markup--code markup--p-code">request.ip</code>.</p><h3 name="0643" id="0643" class="graf graf--h3 graf-after--p">Views</h3><p name="b01b" id="b01b" class="graf graf--p graf-after--h3">Views provide a way to dynamically render HTML on the server and even generate it using other languages.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="52cc" id="52cc" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*nGyJHK1Q_sSB6fjbBbF3xA.png" data-width="1200" data-height="25" src="https://cdn-images-1.medium.com/max/1200/1*nGyJHK1Q_sSB6fjbBbF3xA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="f17f" id="f17f" class="graf graf--h3 graf-after--figure">Try It:</h3><p name="c68a" id="c68a" class="graf graf--p graf-after--h3">Let’s write our first server using Express:</p><ul class="postList"><li name="1a5f" id="1a5f" class="graf graf--li graf-after--p">Create a new file called <code class="markup--code markup--li-code">server.js</code> to host our server code.</li><li name="2d2f" id="2d2f" class="graf graf--li graf-after--li">Type <code class="markup--code markup--li-code">npm init -y</code> to generate a <code class="markup--code markup--li-code">package.json</code>.</li><li name="8b3a" id="8b3a" class="graf graf--li graf-after--li">Install the <code class="markup--code markup--li-code">express</code> npm module using: <code class="markup--code markup--li-code">npm install express</code>.</li></ul><p name="dca2" id="dca2" class="graf graf--p graf-after--li">Inside <code class="markup--code markup--p-code">server.js</code> add the following code:</p><pre name="749f" id="749f" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const express = require(&#39;express&#39;); // import the express package</code></pre><pre name="5ee1" id="5ee1" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const server = express(); // creates the server</code></pre><pre name="64c4" id="64c4" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// handle requests to the root of the api, the / route<br>server.get(&#39;/&#39;, (req, res) =&gt; {<br>  res.send(&#39;Hello from Express&#39;);<br>});</code></pre><pre name="af4b" id="af4b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// watch for connections on port 5000<br>server.listen(5000, () =&gt;<br>  console.log(&#39;Server running on &lt;http://localhost:5000&gt;&#39;)<br>);</code></pre><p name="6a07" id="6a07" class="graf graf--p graf-after--pre">Run the server by typing: <code class="markup--code markup--p-code">node server.js</code> and visit <code class="markup--code markup--p-code">http://localhost:5000</code> in the browser.</p><p name="d424" id="d424" class="graf graf--p graf-after--p">To stop the server, type <code class="markup--code markup--p-code">Ctrl + c</code> at the terminal window.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="ec15" id="ec15" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*nGyJHK1Q_sSB6fjbBbF3xA.png" data-width="1200" data-height="25" src="https://cdn-images-1.medium.com/max/1200/1*nGyJHK1Q_sSB6fjbBbF3xA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="4046" id="4046" class="graf graf--h3 graf-after--figure">Create an API that can respond to GET requests</h3><p name="24a4" id="24a4" class="graf graf--p graf-after--h3">The steps necessary to build a simple Web API that returns the string “Hello World” on every incoming <code class="markup--code markup--p-code">GET</code> request. The program should return the string every time a request comes into the root route (&quot;/&quot;). For now, you don&#39;t need to code along, just read through the steps.</p><p name="b43f" id="b43f" class="graf graf--p graf-after--p">To make things easier, we’ll use an existing repository as the base for our API. Later in the week, as we learn more about Node.js and Express, we’ll create an API from scratch.</p><p name="70c8" id="70c8" class="graf graf--p graf-after--p">To build our first API, we will:</p><ol class="postList"><li name="ff64" id="ff64" class="graf graf--li graf-after--p">clone the <a href="https://github.com/LambdaSchool/node-express-mini" data-href="https://github.com/LambdaSchool/node-express-mini" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">node-express-mini repository (Links to an external site.)</a> to a folder on our computer.</li><li name="288f" id="288f" class="graf graf--li graf-after--li">Navigate into the folder using <code class="markup--code markup--li-code">cd</code>.</li><li name="2043" id="2043" class="graf graf--li graf-after--li">Use <code class="markup--code markup--li-code">npm install</code> to download all dependencies.</li><li name="be2a" id="be2a" class="graf graf--li graf-after--li">Add a file called <code class="markup--code markup--li-code">index.js</code> at the folder&#39;s root, next to the <code class="markup--code markup--li-code">package.json</code> file.</li><li name="d92a" id="d92a" class="graf graf--li graf-after--li">Open the <code class="markup--code markup--li-code">index.js</code> file using our favorite code editor.</li><li name="d337" id="d337" class="graf graf--li graf-after--li">Add the following code:</li></ol><pre name="c9d5" id="c9d5" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">// require the express npm module, needs to be added to the project using &quot;npm install express&quot;<br>const express = require(&#39;express&#39;);</code></pre><pre name="d945" id="d945" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// creates an express application using the express module<br>const server = express();</code></pre><pre name="2956" id="2956" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// configures our server to execute a function for every GET request to &quot;/&quot;<br>// the second argument passed to the .get() method is the &quot;Route Handler Function&quot;<br>// the route handler function will run on every GET request to &quot;/&quot;<br>server.get(&#39;/&#39;, (req, res) =&gt; {<br>  // express will pass the request and response objects to this function<br>  // the .send() on the response object can be used to send a response to the client<br>  res.send(&#39;Hello World&#39;);<br>});</code></pre><pre name="de14" id="de14" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// once the server is fully configured we can have it &quot;listen&quot; for connections on a particular &quot;port&quot;<br>// the callback function passed as the second argument will run once when the server starts<br>server.listen(8000, () =&gt; console.log(&#39;API running on port 8000&#39;));</code></pre><p name="6d67" id="6d67" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">make sure to save your changes to </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">index.js</strong></code><strong class="markup--strong markup--p-strong">.</strong></p><p name="64c9" id="64c9" class="graf graf--p graf-after--p">We are using the <code class="markup--code markup--p-code">express</code> npm module in our code, so we need to add it as a dependency to our project. To do this:</p><ul class="postList"><li name="e9eb" id="e9eb" class="graf graf--li graf-after--p">Open a terminal/console/command prompt window and navigate to the root of our project.</li><li name="b744" id="b744" class="graf graf--li graf-after--li">Add express to our <code class="markup--code markup--li-code">package.json</code> file by typing <code class="markup--code markup--li-code">npm install express</code>.</li></ul><p name="d8a1" id="d8a1" class="graf graf--p graf-after--li">Now we’re ready to test our API!</p><p name="65d5" id="65d5" class="graf graf--p graf-after--p">In the terminal, still at the root of our project:</p><ul class="postList"><li name="04b6" id="04b6" class="graf graf--li graf-after--p">Type: <code class="markup--code markup--li-code">npm run server</code> to run our API. The message <em class="markup--em markup--li-em">&quot;Api running on port 8000&quot;</em> should appear on the terminal.</li><li name="440e" id="440e" class="graf graf--li graf-after--li">Open a web browser and navigate to “<a href="http://localhost:8000" data-href="http://localhost:8000" class="markup--anchor markup--li-anchor" target="_blank">http://localhost:8000</a>&quot;.</li></ul><p name="26ff" id="26ff" class="graf graf--p graf-after--li">There we have it, our first API!</p><p name="f009" id="f009" class="graf graf--p graf-after--p">A lot is going on in those few lines of code (only six lines if we remove the comments and white space). We will cover every piece of it in detail over the following modules, but here is a quick rundown of the most important concepts.</p><p name="a171" id="a171" class="graf graf--p graf-after--p">First, we used <code class="markup--code markup--p-code">require()</code> to <strong class="markup--strong markup--p-strong">import</strong> the <code class="markup--code markup--p-code">express module</code> and make it available to our application. <code class="markup--code markup--p-code">require()</code> is similar to the <code class="markup--code markup--p-code">import</code> keyword we have used before. The line <code class="markup--code markup--p-code">const express = require(&#39;express&#39;);</code> is equivalent to <code class="markup--code markup--p-code">import express from &#39;express&#39;;</code> if we were using ES2015 syntax.</p><p name="fc38" id="fc38" class="graf graf--p graf-after--p">The following line creates our Express application. The return of calling <code class="markup--code markup--p-code">express()</code> is an instance of an Express application that we can use to configure our <strong class="markup--strong markup--p-strong">server</strong> and, eventually, start listening for and responding to requests. Notice we use the word server, not API. An Express application is generic, which means we can use it to serve static content (HTML, CSS, audio, video, PDFs, and more). We can also use an Express application to serve dynamically generated web pages, build real-time communications servers, and more. We will use it statically to accept requests from clients and respond with data in JSON format.</p><p name="b397" id="b397" class="graf graf--p graf-after--p">An Express application publishes a set of methods we can use to configure functions. We are using the <code class="markup--code markup--p-code">.get()</code> method to set up a <strong class="markup--strong markup--p-strong">route handler</strong> function that will run on every <code class="markup--code markup--p-code">GET</code> request. As a part of this handler function, we specify the URL which will trigger the request. In this case, the URL is the site&#39;s root (represented by a <code class="markup--code markup--p-code">/</code>). There are also methods to handle the <code class="markup--code markup--p-code">POST</code>, <code class="markup--code markup--p-code">PUT</code>, and <code class="markup--code markup--p-code">DELETE</code> HTTP verbs.</p><p name="bbf5" id="bbf5" class="graf graf--p graf-after--p">The first two arguments passed by <code class="markup--code markup--p-code">express</code> to a route handler function are 1) an object representing the <code class="markup--code markup--p-code">request</code> and 2) an object representing the <code class="markup--code markup--p-code">response</code>. Express expands those objects with a set of useful properties and methods. Our example uses the <code class="markup--code markup--p-code">.send()</code> method of the response object to specify the data we will send to the client as the response body. You can call the first two arguments anything you want, but it is prevalent to see them dubbed <code class="markup--code markup--p-code">req</code> and <code class="markup--code markup--p-code">res</code>.</p><p name="2331" id="2331" class="graf graf--p graf-after--p">That’s all the configuring we need to do for this first example We’ll see other ways of configuring our server as we go forward.</p><p name="185a" id="185a" class="graf graf--p graf-after--p">After configuring the server, it’s time to turn it on. We use the <code class="markup--code markup--p-code">.listen()</code> method to monitor a port on the computer for any incoming connections and respond to those we have configured. Our server will only respond to <code class="markup--code markup--p-code">GET</code> requests made to the <code class="markup--code markup--p-code">/</code> route on port <code class="markup--code markup--p-code">8000</code>.</p><p name="897c" id="897c" class="graf graf--p graf-after--p">That’s it for our first Web API, and now it’s time for you to follow along as we add a new <strong class="markup--strong markup--p-strong">endpoint</strong> to our server that returns JSON data!</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="42f1" id="42f1" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*nGyJHK1Q_sSB6fjbBbF3xA.png" data-width="1200" data-height="25" src="https://cdn-images-1.medium.com/max/1200/1*nGyJHK1Q_sSB6fjbBbF3xA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="ca9e" id="ca9e" class="graf graf--h3 graf-after--figure">Try It Out:</h3><p name="c537" id="c537" class="graf graf--p graf-after--h3">Let’s try returning JSON instead of just a simple string.</p><p name="d105" id="d105" class="graf graf--p graf-after--p">Please follow the steps outlined on the overview, but, to save time, copy and paste the content of <code class="markup--code markup--p-code">index.js</code> instead of typing it. Then run your API through a browser to make sure it works.</p><p name="dc90" id="dc90" class="graf graf--p graf-after--p">Now follow along as we code a new <em class="markup--em markup--p-em">endpoint</em> that returns an array of movie characters in JSON format.</p><p name="11e8" id="11e8" class="graf graf--p graf-after--p">The first step is to define a new <em class="markup--em markup--p-em">route handler</em> to respond to <code class="markup--code markup--p-code">GET</code> requests at the <code class="markup--code markup--p-code">/hobbits</code> endpoint.</p><pre name="3f37" id="3f37" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">server.get(&#39;/hobbits&#39;, (req, res) =&gt; {<br>  // route handler code here<br>});</code></pre><p name="52d3" id="52d3" class="graf graf--p graf-after--pre">Next, we define the return data that our endpoint will send back to the client. We do this inside the newly defined route handler function.</p><pre name="e0c6" id="e0c6" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const hobbits = [<br>  {<br>    id: 1,<br>    name: &#39;Samwise Gamgee&#39;,<br>  },<br>  {<br>    id: 2,<br>    name: &#39;Frodo Baggins&#39;,<br>  },<br>];</code></pre><p name="2c0d" id="2c0d" class="graf graf--p graf-after--pre">Now we can return the <code class="markup--code markup--p-code">hobbits</code> array. We could use <code class="markup--code markup--p-code">.send(hobbits)</code> as we did for the string on the <code class="markup--code markup--p-code">/</code> endpoint, but this time we&#39;ll learn about two other useful methods we find in the response object.</p><pre name="7e13" id="7e13" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">res.status(200).json(hobbits);</code></pre><p name="7dc2" id="7dc2" class="graf graf--p graf-after--pre">We should provide as much useful information as possible to the clients using our API. One such piece of data is the <code class="markup--code markup--p-code">HTTP status code</code> that reflects the client&#39;s operation outcome. In this case, the client is trying to get a list of a particular <code class="markup--code markup--p-code">resource</code>, a <code class="markup--code markup--p-code">hobbits</code> list. Sending back a <code class="markup--code markup--p-code">200 OK</code> status code communicates to the client that the operation was successful.</p><p name="85b4" id="85b4" class="graf graf--p graf-after--p">We will see other status codes as we continue to build new endpoints during this week. You can see a list by following <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" data-href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this link to the documentation about HTTP Response Codes on the Mozilla Developer Network site (Links to an external site.)</a>.</p><p name="20ba" id="20ba" class="graf graf--p graf-after--p">We can use the <code class="markup--code markup--p-code">.status()</code> method of the response object to send any valid <code class="markup--code markup--p-code">HTTP status code</code>.</p><p name="beb1" id="beb1" class="graf graf--p graf-after--p">We are also chaining the <code class="markup--code markup--p-code">.json()</code> method of the response object. We do this to communicate to both the client making the request and the next developer working with this code that we intend to send the data in <code class="markup--code markup--p-code">JSON format</code>.</p><p name="eb6e" id="eb6e" class="graf graf--p graf-after--p">The complete code for <code class="markup--code markup--p-code">index.js</code> should now look like so:</p><pre name="2559" id="2559" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const express = require(&#39;express&#39;);</code></pre><pre name="624a" id="624a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const server = express();</code></pre><pre name="acdf" id="acdf" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">server.get(&#39;/&#39;, (req, res) =&gt; {<br>  res.send(&#39;Hello World&#39;);<br>});</code></pre><pre name="30f9" id="30f9" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">server.get(&#39;/hobbits&#39;, (req, res) =&gt; {<br>  const hobbits = [<br>    {<br>      id: 1,<br>      name: &#39;Samwise Gamgee&#39;,<br>    },<br>    {<br>      id: 2,<br>      name: &#39;Frodo Baggins&#39;,<br>    },<br>  ];</code></pre><pre name="f903" id="f903" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  res.status(200).json(hobbits);<br>});</code></pre><pre name="5b3f" id="5b3f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">server.listen(8000, () =&gt; console.log(&#39;API running on port 8000&#39;));</code></pre><p name="6e30" id="6e30" class="graf graf--p graf-after--pre">Now we can visit <code class="markup--code markup--p-code">http://localhost:8000/hobbits</code> in our browser, and we should get back our JSON array.</p><p name="dbda" id="dbda" class="graf graf--p graf-after--p">If you are using the Google Chrome browser, <a href="https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc" data-href="https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this extension (Links to an external site.)</a> can format the JSON data in a more readable fashion.</p><p name="f5ff" id="f5ff" class="graf graf--p graf-after--p">Congratulations! You just built an API that can return data in JSON format.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="78ed" id="78ed" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*nGyJHK1Q_sSB6fjbBbF3xA.png" data-width="1200" data-height="25" src="https://cdn-images-1.medium.com/max/1200/1*nGyJHK1Q_sSB6fjbBbF3xA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="e37f" id="e37f" class="graf graf--h3 graf-after--figure">Let’s look at a basic example of routing in action.</h3><p name="07b6" id="07b6" class="graf graf--p graf-after--h3">First, to make our Express application respond to <code class="markup--code markup--p-code">GET</code> requests on different URLs, add the following endpoints:</p><pre name="46ae" id="46ae" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// this request handler executes when making a GET request to /about<br>server.get(&#39;/about&#39;, (req, res) =&gt; {<br>  res.status(200).send(&#39;&lt;h1&gt;About Us&lt;/h1&gt;&#39;);<br>});</code></pre><pre name="8564" id="8564" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// this request handler executes when making a GET request to /contact<br>server.get(&#39;/contact&#39;, (req, res) =&gt; {<br>  res.status(200).send(&#39;&lt;h1&gt;Contact Form&lt;/h1&gt;&#39;);<br>});</code></pre><p name="948c" id="948c" class="graf graf--p graf-after--pre">Two things to note:</p><blockquote name="2a49" id="2a49" class="graf graf--pullquote graf-after--p">1.) We are using the same HTTP Method on both endpoints, but express looks at the URL and executes the corresponding request handler.</blockquote><blockquote name="d0fa" id="d0fa" class="graf graf--pullquote graf-after--pullquote">2.) We can return a string with valid HTML!</blockquote><p name="59a3" id="59a3" class="graf graf--p graf-after--pullquote">Open a browser and navigate to the <code class="markup--code markup--p-code">/about</code> and <code class="markup--code markup--p-code">/contact</code> routes. The appropriate route handler will execute.</p><p name="0db8" id="0db8" class="graf graf--p graf-after--p">Please follow along as we write endpoints that execute different request handlers on the same URL by changing the HTTP method.</p><p name="c091" id="c091" class="graf graf--p graf-after--p">Let’s start by adding the following code after the <code class="markup--code markup--p-code">GET</code> endpoint to <code class="markup--code markup--p-code">/hobbits</code>:</p><pre name="60e7" id="60e7" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// this request handler executes when making a POST request to /hobbits<br>server.post(&#39;/hobbits&#39;, (req, res) =&gt; {<br>  res.status(201).json({ url: &#39;/hobbits&#39;, operation: &#39;POST&#39; });<br>});</code></pre><p name="eefa" id="eefa" class="graf graf--p graf-after--pre">Note that we return HTTP status code 201 (created) for successful <code class="markup--code markup--p-code">POST</code> operations.</p><p name="1d45" id="1d45" class="graf graf--p graf-after--p">Next, we need to add an endpoint for <code class="markup--code markup--p-code">PUT</code> requests to the same URL.</p><pre name="898a" id="898a" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// this request handler executes when making a PUT request to /hobbits<br>server.put(&#39;/hobbits&#39;, (req, res) =&gt; {<br>  res.status(200).json({ url: &#39;/hobbits&#39;, operation: &#39;PUT&#39; });<br>});</code></pre><p name="bd6f" id="bd6f" class="graf graf--p graf-after--pre">For successful <code class="markup--code markup--p-code">PUT</code> operations, we use HTTP Status Code 200 (OK).</p><p name="70eb" id="70eb" class="graf graf--p graf-after--p">Finally, let’s write an endpoint to handle <code class="markup--code markup--p-code">DELETE</code> requests.</p><pre name="b098" id="b098" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// this request handler executes when making a DELETE request to /hobbits<br>server.delete(&#39;/hobbits&#39;, (req, res) =&gt; {<br>  res.status(204);<br>});</code></pre><p name="d71e" id="d71e" class="graf graf--p graf-after--pre">We are returning HTTP Status Code 204 (No Content). Suppose you are returning any data to the client, perhaps the removed resource, on successful deletes. In that case, you’d change that to be 200 instead.</p><p name="37b3" id="37b3" class="graf graf--p graf-after--p">You may have noticed that we are not reading any data from the request, as that is something we’ll learn later in the module. We are about to learn how to use a tool called <code class="markup--code markup--p-code">Postman</code> to test our <code class="markup--code markup--p-code">POST</code>, <code class="markup--code markup--p-code">PUT</code>, and <code class="markup--code markup--p-code">DELETE</code> endpoints.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="ae58" id="ae58" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*nGyJHK1Q_sSB6fjbBbF3xA.png" data-width="1200" data-height="25" src="https://cdn-images-1.medium.com/max/1200/1*nGyJHK1Q_sSB6fjbBbF3xA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="a9ee" id="a9ee" class="graf graf--h3 graf-after--figure">Reading and Using Route Parameters</h3><p name="d533" id="d533" class="graf graf--p graf-after--h3">Let’s revisit our <code class="markup--code markup--p-code">DELETE</code> endpoint.</p><pre name="9fc2" id="9fc2" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">server.delete(&#39;/hobbits&#39;, (req, res) =&gt; {<br>  res.status(204);<br>});</code></pre><p name="0f2f" id="0f2f" class="graf graf--p graf-after--pre">How does the client let the API know which hobbit should be deleted or updated? One way, the one we’ll use, is through <code class="markup--code markup--p-code">route parameters</code>. Let&#39;s add support for route parameters to our <code class="markup--code markup--p-code">DELETE</code> endpoint.</p><p name="5357" id="5357" class="graf graf--p graf-after--p">We define route parameters by adding it to the URL with a colon (<code class="markup--code markup--p-code">:</code>) in front of it. Express adds it to the <code class="markup--code markup--p-code">.params</code> property part of the request object. Let&#39;s see it in action:</p><pre name="4bdc" id="4bdc" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">server.delete(&#39;/hobbits/:id&#39;, (req, res) =&gt; {<br>  const id = req.params.id;<br>  // or we could destructure it like so: const { id } = req.params;<br>  res.status(200).json({<br>    url: `/hobbits/${id}`,<br>    operation: `DELETE for hobbit with id ${id}`,<br>  });<br>});</code></pre><p name="7714" id="7714" class="graf graf--p graf-after--pre">This route handler will execute every <code class="markup--code markup--p-code">DELETE</code> for a URL that begins with <code class="markup--code markup--p-code">/hobbits/</code> followed by any value. So, <code class="markup--code markup--p-code">DELETE</code> requests to <code class="markup--code markup--p-code">/hobbits/123</code> and <code class="markup--code markup--p-code">/hobbits/frodo</code> will both trigger this request handler. The value passed after <code class="markup--code markup--p-code">/hobbits/</code> will end up as the <code class="markup--code markup--p-code">id</code> property on <code class="markup--code markup--p-code">req.params</code>.</p><p name="fbfc" id="fbfc" class="graf graf--p graf-after--p">The value for a route parameter will always be <code class="markup--code markup--p-code">string</code>, even if the value passed is numeric. When hitting <code class="markup--code markup--p-code">/hobbits/123</code> in our example, the type of <code class="markup--code markup--p-code">req.params.id</code> will be <code class="markup--code markup--p-code">string</code>.</p><p name="38aa" id="38aa" class="graf graf--p graf-after--p">Express routing has support for multiple route parameters. For example, defining a route URL that reads <code class="markup--code markup--p-code">/hobbits/:id/friends/:friendId</code>, will add properties for <code class="markup--code markup--p-code">id</code> and <code class="markup--code markup--p-code">friendId</code> to <code class="markup--code markup--p-code">req.params</code>.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="042f" id="042f" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*nGyJHK1Q_sSB6fjbBbF3xA.png" data-width="1200" data-height="25" src="https://cdn-images-1.medium.com/max/1200/1*nGyJHK1Q_sSB6fjbBbF3xA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="7e1a" id="7e1a" class="graf graf--h3 graf-after--figure">Using the Query String</h3><p name="2f00" id="2f00" class="graf graf--p graf-after--h3">The query string is another strategy using the URL to pass information from clients to the server. The query string is structured as a set of key/value pairs. Each pair takes the form of <code class="markup--code markup--p-code">key=value</code>, and pairs are separated by an <code class="markup--code markup--p-code">&amp;</code>. To mark the beginning of the query string, we add <code class="markup--code markup--p-code">?</code> and the end of the URL, followed by the set of key/value pairs.</p><p name="b8fe" id="b8fe" class="graf graf--p graf-after--p">An example of a query string would be: <code class="markup--code markup--p-code">https://www.google.com/search?q=lambda&amp;tbo=1</code>. The query string portion is <code class="markup--code markup--p-code">?q=lambda&amp;tbo=1</code> and the key/value pairs are <code class="markup--code markup--p-code">q=lambda</code> and <code class="markup--code markup--p-code">tbo=1</code>.</p><p name="6c05" id="6c05" class="graf graf--p graf-after--p">Let’s add sorting capabilities to our API. We’ll provide a way for clients to hit our <code class="markup--code markup--p-code">/hobbits</code> and pass the field they want to use to sort the responses, and our API will sort the data by that field in ascending order.</p><p name="30a1" id="30a1" class="graf graf--p graf-after--p">Here’s the new code for the <code class="markup--code markup--p-code">GET /hobbits</code> endpoint:</p><pre name="bcc4" id="bcc4" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">server.get(&#39;/hobbits&#39;, (req, res) =&gt; {<br>  // query string parameters get added to req.query<br>  const sortField = req.query.sortby || &#39;id&#39;;<br>  const hobbits = [<br>    {<br>      id: 1,<br>      name: &#39;Samwise Gamgee&#39;,<br>    },<br>    {<br>      id: 2,<br>      name: &#39;Frodo Baggins&#39;,<br>    },<br>  ];</code></pre><pre name="2236" id="2236" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  // apply the sorting<br>  const response = hobbits.sort(<br>    (a, b) =&gt; (a[sortField] &lt; b[sortField] ? -1 : 1)<br>  );</code></pre><pre name="5b1b" id="5b1b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  res.status(200).json(response);<br>});</code></pre><p name="a6ae" id="a6ae" class="graf graf--p graf-after--pre">Visit <code class="markup--code markup--p-code">localhost:8000/hobbits?sortby=name</code>, and the list should be sorted by <code class="markup--code markup--p-code">name</code>. Visit <code class="markup--code markup--p-code">localhost:8000/hobbits?sortby=id</code>, and the list should now be sorted by <code class="markup--code markup--p-code">id</code>. If no <code class="markup--code markup--p-code">sortby</code> parameter is provided, it should default to sorting by <code class="markup--code markup--p-code">id</code>.</p><p name="356f" id="356f" class="graf graf--p graf-after--p">To read values from the query string, we use the <code class="markup--code markup--p-code">req.query</code> object added by Express. There will be a key and a value in the <code class="markup--code markup--p-code">req.query</code> object for each key/value pair found in the query string.</p><p name="35cb" id="35cb" class="graf graf--p graf-after--p">The parameter’s value will be of type <code class="markup--code markup--p-code">array</code> if more than one value is passed for the same key and <code class="markup--code markup--p-code">string</code> when only one value is passed. For example, in the query string <code class="markup--code markup--p-code">?id=123</code>, <code class="markup--code markup--p-code">req.query.id</code> will be a string, but for <code class="markup--code markup--p-code">?id=123&amp;id=234</code>, it will be an array.</p><p name="3649" id="3649" class="graf graf--p graf-after--p">Another gotcha is that the names of query string parameters are case sensitive, <code class="markup--code markup--p-code">sortby</code> and <code class="markup--code markup--p-code">sortBy</code> are two different parameters.</p><p name="7f61" id="7f61" class="graf graf--p graf-after--p">The rest of the code sorts the array before sending it back to the client.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="e7f2" id="e7f2" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*nGyJHK1Q_sSB6fjbBbF3xA.png" data-width="1200" data-height="25" src="https://cdn-images-1.medium.com/max/1200/1*nGyJHK1Q_sSB6fjbBbF3xA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="a964" id="a964" class="graf graf--h3 graf-after--figure">Reading Data from the Request Body</h3><p name="9172" id="9172" class="graf graf--p graf-after--h3">We begin by taking another look at the <code class="markup--code markup--p-code">POST /hobbits</code> endpoint. We need to read the hobbit&#39;s information to add it to the <code class="markup--code markup--p-code">hobbits</code> array. Let&#39;s do that next:</p><pre name="2350" id="2350" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// add this code right after const server = express();<br>server.use(express.json());</code></pre><pre name="960e" id="960e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">let hobbits = [<br>  {<br>    id: 1,<br>    name: &#39;Bilbo Baggins&#39;,<br>    age: 111,<br>  },<br>  {<br>    id: 2,<br>    name: &#39;Frodo Baggins&#39;,<br>    age: 33,<br>  },<br>];<br>let nextId = 3;</code></pre><pre name="9751" id="9751" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// and modify the post endpoint like so:<br>server.post(&#39;/hobbits&#39;, (req, res) =&gt; {<br>  const hobbit = req.body;<br>  hobbit.id = nextId++;</code></pre><pre name="2e87" id="2e87" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  hobbits.push(hobbit);</code></pre><pre name="0b21" id="0b21" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  res.status(201).json(hobbits);<br>});</code></pre><p name="103f" id="103f" class="graf graf--p graf-after--pre">To make this work with the hobbits array, we first move it out of the get endpoint into the outer scope. Now we have access to it from all route handlers.</p><p name="4b5b" id="4b5b" class="graf graf--p graf-after--p">Then we define a variable for manual id generation. When using a database, this is not necessary as the database management system generates ids automatically.</p><p name="7b37" id="7b37" class="graf graf--p graf-after--p">To read data from the request body, we need to do two things:</p><ul class="postList"><li name="02f1" id="02f1" class="graf graf--li graf-after--p">Add the line: <code class="markup--code markup--li-code">server.use(express.json());</code> after the express application has been created.</li><li name="5111" id="5111" class="graf graf--li graf-after--li">Read the data from the body property that Express adds to the request object. Express takes all the client’s information from the body and makes it available as a nice JavaScript object.</li></ul><p name="7795" id="7795" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Note that we are skipping data validation to keep this demo simple, but in a production application, you would validate before attempting to save to the database.</strong></p><p name="a4fe" id="a4fe" class="graf graf--p graf-after--p">Let’s test it using Postman:</p><ul class="postList"><li name="2351" id="2351" class="graf graf--li graf-after--p">Change the method to POST.</li><li name="ca2a" id="ca2a" class="graf graf--li graf-after--li">Select the <code class="markup--code markup--li-code">Body</code> tab underneath the address bar.</li><li name="ce2e" id="ce2e" class="graf graf--li graf-after--li">Click on the <code class="markup--code markup--li-code">raw</code> radio button.</li><li name="fbac" id="fbac" class="graf graf--li graf-after--li">From the dropdown menu to the right of the <code class="markup--code markup--li-code">binary</code> radio button, select `JSON (application/json).</li><li name="447b" id="447b" class="graf graf--li graf-after--li">Add the following JSON object as the body:</li></ul><pre name="f738" id="f738" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">{<br>  &quot;name&quot;: &quot;Samwise Gamgee&quot;,<br>  &quot;age&quot;: 30<br>}</code></pre><p name="1d6e" id="1d6e" class="graf graf--p graf-after--pre">Click on <code class="markup--code markup--p-code">Send</code>, and the API should return the list of hobbits, including Sam!</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="bfc4" id="bfc4" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*nGyJHK1Q_sSB6fjbBbF3xA.png" data-width="1200" data-height="25" src="https://cdn-images-1.medium.com/max/1200/1*nGyJHK1Q_sSB6fjbBbF3xA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="45d1" id="45d1" class="graf graf--h3 graf-after--figure">Try It:</h3><p name="1dec" id="1dec" class="graf graf--p graf-after--h3">Please code along as we implement the <code class="markup--code markup--p-code">PUT</code> endpoint and a way for the client to specify the sort direction.</p><h3 name="81a3" id="81a3" class="graf graf--h3 graf-after--p">Implement Update Functionality</h3><p name="a3ef" id="a3ef" class="graf graf--p graf-after--h3">Let’s continue practicing reading route parameters and information from the request body. Let’s take a look at our existing PUT endpoint:</p><pre name="ca43" id="ca43" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">server.put(&#39;/hobbits&#39;, (req, res) =&gt; {<br>  res.status(200).json({ url: &#39;/hobbits&#39;, operation: &#39;PUT&#39; });<br>});</code></pre><p name="05da" id="05da" class="graf graf--p graf-after--pre">We start by adding support for a route parameter the clients can use to specify the id of the hobbit they intend to update:</p><pre name="aecd" id="aecd" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">server.put(&#39;/hobbits/:id&#39;, (req, res) =&gt; {<br>  res.status(200).json({ url: &#39;/hobbits&#39;, operation: &#39;PUT&#39; });<br>});</code></pre><p name="56a1" id="56a1" class="graf graf--p graf-after--pre">Next, we read the hobbit information from the request body using <code class="markup--code markup--p-code">req.body</code> and use it to update the existing hobbit.</p><pre name="adf0" id="adf0" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">server.put(&#39;/hobbits/:id&#39;, (req, res) =&gt; {<br>  const hobbit = hobbits.find(h =&gt; h.id == req.params.id);</code></pre><pre name="053a" id="053a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  if (!hobbit) {<br>    res.status(404).json({ message: &#39;Hobbit does not exist&#39; });<br>  } else {<br>    // modify the existing hobbit<br>    Object.assign(hobbit, req.body);</code></pre><pre name="eeab" id="eeab" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    res.status(200).json(hobbit);<br>  }<br>});</code></pre><p name="ff84" id="ff84" class="graf graf--p graf-after--pre">Concentrate on the code related to reading the <code class="markup--code markup--p-code">id</code> from the <code class="markup--code markup--p-code">req.params</code> object and reading the hobbit information from <code class="markup--code markup--p-code">req.body</code>. The rest of the code will change as this is a simple example using an in-memory array. Most production APIs will use a database.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="acb1" id="acb1" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*nGyJHK1Q_sSB6fjbBbF3xA.png" data-width="1200" data-height="25" src="https://cdn-images-1.medium.com/max/1200/1*nGyJHK1Q_sSB6fjbBbF3xA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="c188" id="c188" class="graf graf--h3 graf-after--figure">TBC…………………………………</h3><h3 name="9678" id="9678" class="graf graf--h3 graf-after--h3">If you found this guide helpful feel free to checkout my GitHub/gists where I host similar content:</h3><div name="1c2f" id="1c2f" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://gist.github.com/bgoonz" data-href="https://gist.github.com/bgoonz" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://gist.github.com/bgoonz"><strong class="markup--strong markup--mixtapeEmbed-strong">bgoonz’s gists</strong><br><em class="markup--em markup--mixtapeEmbed-em">Instantly share code, notes, and snippets. Web Developer, Electrical Engineer JavaScript | CSS | Bootstrap | Python |…</em>gist.github.com</a><a href="https://gist.github.com/bgoonz" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="ab25adbb500306703daab23d08a7739a" data-thumbnail-img-id="0*3O67jrqm3EHjTK2H" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*3O67jrqm3EHjTK2H);"></a></div><div name="3585" id="3585" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://github.com/bgoonz" data-href="https://github.com/bgoonz" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/bgoonz"><strong class="markup--strong markup--mixtapeEmbed-strong">bgoonz — Overview</strong><br><em class="markup--em markup--mixtapeEmbed-em">Web Developer, Electrical Engineer JavaScript | CSS | Bootstrap | Python | React | Node.js | Express | Sequelize…</em>github.com</a><a href="https://github.com/bgoonz" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="6ee74d5200d495ddc7ddad0c92bd6dce" data-thumbnail-img-id="0*Udg3rbeFyslZ9dyl" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Udg3rbeFyslZ9dyl);"></a></div><h3 name="cb1a" id="cb1a" class="graf graf--h3 graf-after--mixtapeEmbed">Discover More:</h3><div name="1e6c" id="1e6c" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://bgoonz-blog.netlify.app/" data-href="https://bgoonz-blog.netlify.app/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://bgoonz-blog.netlify.app/"><strong class="markup--strong markup--mixtapeEmbed-strong">Web-Dev-Hub</strong><br><em class="markup--em markup--mixtapeEmbed-em">Memoization, Tabulation, and Sorting Algorithms by Example Why is looking at runtime not a reliable method of…</em>bgoonz-blog.netlify.app</a><a href="https://bgoonz-blog.netlify.app/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a2f1abe4ed6a87b0b90d28e55f930d20" data-thumbnail-img-id="0*yHs_xDis1qQ8JjWg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*yHs_xDis1qQ8JjWg);"></a></div></div><div class="section-inner sectionLayout--outsetColumn"><figure name="7a7e" id="7a7e" class="graf graf--figure graf--layoutOutsetCenter graf-after--mixtapeEmbed"><img class="graf-image" data-image-id="1*nGyJHK1Q_sSB6fjbBbF3xA.png" data-width="1200" data-height="25" src="https://cdn-images-1.medium.com/max/1200/1*nGyJHK1Q_sSB6fjbBbF3xA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="6468" id="6468" class="graf graf--h3 graf-after--figure">Update(Bonus Best Practices):</h3><h3 name="23b0" id="23b0" class="graf graf--h3 graf-after--h3">Things to do in your code</h3><p name="0e6e" id="0e6e" class="graf graf--p graf-after--h3">Here are some things you can do in your code to improve your application’s performance:</p><ul class="postList"><li name="b2b0" id="b2b0" class="graf graf--li graf-after--p"><a href="#use-gzip-compression" data-href="#use-gzip-compression" class="markup--anchor markup--li-anchor" title="#use-gzip-compression">Use gzip compression</a></li><li name="23bb" id="23bb" class="graf graf--li graf-after--li"><a href="#dont-use-synchronous-functions" data-href="#dont-use-synchronous-functions" class="markup--anchor markup--li-anchor" title="#dont-use-synchronous-functions">Don’t use synchronous functions</a></li><li name="904e" id="904e" class="graf graf--li graf-after--li"><a href="#do-logging-correctly" data-href="#do-logging-correctly" class="markup--anchor markup--li-anchor" title="#do-logging-correctly">Do logging correctly</a></li><li name="f619" id="f619" class="graf graf--li graf-after--li"><a href="#handle-exceptions-properly" data-href="#handle-exceptions-properly" class="markup--anchor markup--li-anchor" title="#handle-exceptions-properly">Handle exceptions properly</a></li></ul><h3 name="560a" id="560a" class="graf graf--h3 graf-after--li">Use gzip compression</h3><p name="4a73" id="4a73" class="graf graf--p graf-after--h3">Gzip compressing can greatly decrease the size of the response body and hence increase the speed of a web app. Use the <a href="https://www.npmjs.com/package/compression" data-href="https://www.npmjs.com/package/compression" class="markup--anchor markup--p-anchor" title="https://www.npmjs.com/package/compression" rel="noopener" target="_blank">compression</a> middleware for gzip compression in your Express app. For example:</p><pre name="caa0" id="caa0" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">var compression = require(&#39;compression&#39;)<br>var express = require(&#39;express&#39;)<br>var app = express()<br>app.use(compression())</code></pre><p name="ffc5" id="ffc5" class="graf graf--p graf-after--pre">For a high-traffic website in production, the best way to put compression in place is to implement it at a reverse proxy level (see <a href="#use-a-reverse-proxy" data-href="#use-a-reverse-proxy" class="markup--anchor markup--p-anchor" title="#use-a-reverse-proxy">Use a reverse proxy</a>). In that case, you do not need to use compression middleware. For details on enabling gzip compression in Nginx, see <a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html" data-href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html" class="markup--anchor markup--p-anchor" title="http://nginx.org/en/docs/http/ngx_http_gzip_module.html" rel="noopener" target="_blank">Module ngx_http_gzip_module</a> in the Nginx documentation.</p><h3 name="2794" id="2794" class="graf graf--h3 graf-after--p">Don’t use synchronous functions</h3><p name="2954" id="2954" class="graf graf--p graf-after--h3">Synchronous functions and methods tie up the executing process until they return. A single call to a synchronous function might return in a few microseconds or milliseconds, however in high-traffic websites, these calls add up and reduce the performance of the app. Avoid their use in production.</p><p name="9a3b" id="9a3b" class="graf graf--p graf-after--p">Although Node and many modules provide synchronous and asynchronous versions of their functions, always use the asynchronous version in production. The only time when a synchronous function can be justified is upon initial startup.</p><p name="e4c6" id="e4c6" class="graf graf--p graf-after--p">If you are using Node.js 4.0+ or io.js 2.1.0+, you can use the <code class="markup--code markup--p-code">--trace-sync-io</code> command-line flag to print a warning and a stack trace whenever your application uses a synchronous API. Of course, you wouldn’t want to use this in production, but rather to ensure that your code is ready for production. See the <a href="https://nodejs.org/api/cli.html#cli_trace_sync_io" data-href="https://nodejs.org/api/cli.html#cli_trace_sync_io" class="markup--anchor markup--p-anchor" title="https://nodejs.org/api/cli.html#cli_trace_sync_io" rel="noopener" target="_blank">node command-line options documentation</a> for more information.</p><h3 name="1eab" id="1eab" class="graf graf--h3 graf-after--p">Do logging correctly</h3><p name="a697" id="a697" class="graf graf--p graf-after--h3">In general, there are two reasons for logging from your app: For debugging and for logging app activity (essentially, everything else). Using <code class="markup--code markup--p-code">console.log()</code> or <code class="markup--code markup--p-code">console.error()</code> to print log messages to the terminal is common practice in development. But <a href="https://nodejs.org/api/console.html#console_console_1" data-href="https://nodejs.org/api/console.html#console_console_1" class="markup--anchor markup--p-anchor" title="https://nodejs.org/api/console.html#console_console_1" rel="noopener" target="_blank">these functions are synchronous</a> when the destination is a terminal or a file, so they are not suitable for production, unless you pipe the output to another program.</p><h4 name="189a" id="189a" class="graf graf--h4 graf-after--p">For debugging</h4><p name="89f1" id="89f1" class="graf graf--p graf-after--h4">If you’re logging for purposes of debugging, then instead of using <code class="markup--code markup--p-code">console.log()</code>, use a special debugging module like <a href="https://www.npmjs.com/package/debug" data-href="https://www.npmjs.com/package/debug" class="markup--anchor markup--p-anchor" title="https://www.npmjs.com/package/debug" rel="noopener" target="_blank">debug</a>. This module enables you to use the DEBUG environment variable to control what debug messages are sent to <code class="markup--code markup--p-code">console.error()</code>, if any. To keep your app purely asynchronous, you’d still want to pipe <code class="markup--code markup--p-code">console.error()</code> to another program. But then, you’re not really going to debug in production, are you?</p><h4 name="0f1a" id="0f1a" class="graf graf--h4 graf-after--p">For app activity</h4><p name="18b4" id="18b4" class="graf graf--p graf-after--h4">If you’re logging app activity (for example, tracking traffic or API calls), instead of using <code class="markup--code markup--p-code">console.log()</code>, use a logging library like <a href="https://www.npmjs.com/package/winston" data-href="https://www.npmjs.com/package/winston" class="markup--anchor markup--p-anchor" title="https://www.npmjs.com/package/winston" rel="noopener" target="_blank">Winston</a> or <a href="https://www.npmjs.com/package/bunyan" data-href="https://www.npmjs.com/package/bunyan" class="markup--anchor markup--p-anchor" title="https://www.npmjs.com/package/bunyan" rel="noopener" target="_blank">Bunyan</a>. For a detailed comparison of these two libraries, see the StrongLoop blog post <a href="https://strongloop.com/strongblog/compare-node-js-logging-winston-bunyan/" data-href="https://strongloop.com/strongblog/compare-node-js-logging-winston-bunyan/" class="markup--anchor markup--p-anchor" title="https://strongloop.com/strongblog/compare-node-js-logging-winston-bunyan/" rel="noopener" target="_blank">Comparing Winston and Bunyan Node.js Logging</a>.</p><h3 name="0a1c" id="0a1c" class="graf graf--h3 graf-after--p">Handle exceptions properly</h3><p name="350d" id="350d" class="graf graf--p graf-after--h3">Node apps crash when they encounter an uncaught exception. Not handling exceptions and taking appropriate actions will make your Express app crash and go offline. If you follow the advice in <a href="#ensure-your-app-automatically-restarts" data-href="#ensure-your-app-automatically-restarts" class="markup--anchor markup--p-anchor" title="#ensure-your-app-automatically-restarts">Ensure your app automatically restarts</a> below, then your app will recover from a crash. Fortunately, Express apps typically have a short startup time. Nevertheless, you want to avoid crashing in the first place, and to do that, you need to handle exceptions properly.</p><p name="2344" id="2344" class="graf graf--p graf-after--p">To ensure you handle all exceptions, use the following techniques:</p><ul class="postList"><li name="4365" id="4365" class="graf graf--li graf-after--p"><a href="#use-try-catch" data-href="#use-try-catch" class="markup--anchor markup--li-anchor" title="#use-try-catch">Use try-catch</a></li><li name="25cc" id="25cc" class="graf graf--li graf-after--li"><a href="#use-promises" data-href="#use-promises" class="markup--anchor markup--li-anchor" title="#use-promises">Use promises</a></li></ul><p name="9e44" id="9e44" class="graf graf--p graf-after--li">Before diving into these topics, you should have a basic understanding of Node/Express error handling: using error-first callbacks, and propagating errors in middleware. Node uses an “error-first callback” convention for returning errors from asynchronous functions, where the first parameter to the callback function is the error object, followed by result data in succeeding parameters. To indicate no error, pass null as the first parameter. The callback function must correspondingly follow the error-first callback convention to meaningfully handle the error. And in Express, the best practice is to use the next() function to propagate errors through the middleware chain.</p><p name="0669" id="0669" class="graf graf--p graf-after--p">For more on the fundamentals of error handling, see:</p><ul class="postList"><li name="e3b5" id="e3b5" class="graf graf--li graf-after--p"><a href="https://www.joyent.com/developers/node/design/errors" data-href="https://www.joyent.com/developers/node/design/errors" class="markup--anchor markup--li-anchor" title="https://www.joyent.com/developers/node/design/errors" rel="noopener" target="_blank">Error Handling in Node.js</a></li><li name="af28" id="af28" class="graf graf--li graf-after--li"><a href="https://strongloop.com/strongblog/robust-node-applications-error-handling/" data-href="https://strongloop.com/strongblog/robust-node-applications-error-handling/" class="markup--anchor markup--li-anchor" title="https://strongloop.com/strongblog/robust-node-applications-error-handling/" rel="noopener" target="_blank">Building Robust Node Applications: Error Handling</a> (StrongLoop blog)</li></ul><h4 name="dc00" id="dc00" class="graf graf--h4 graf-after--li">What not to do</h4><p name="7bbf" id="7bbf" class="graf graf--p graf-after--h4">One thing you should <em class="markup--em markup--p-em">not</em> do is to listen for the <code class="markup--code markup--p-code">uncaughtException</code> event, emitted when an exception bubbles all the way back to the event loop. Adding an event listener for <code class="markup--code markup--p-code">uncaughtException</code> will change the default behavior of the process that is encountering an exception; the process will continue to run despite the exception. This might sound like a good way of preventing your app from crashing, but continuing to run the app after an uncaught exception is a dangerous practice and is not recommended, because the state of the process becomes unreliable and unpredictable.</p><p name="7dfc" id="7dfc" class="graf graf--p graf-after--p">Additionally, using <code class="markup--code markup--p-code">uncaughtException</code> is officially recognized as <a href="https://nodejs.org/api/process.html#process_event_uncaughtexception" data-href="https://nodejs.org/api/process.html#process_event_uncaughtexception" class="markup--anchor markup--p-anchor" title="https://nodejs.org/api/process.html#process_event_uncaughtexception" rel="noopener" target="_blank">crude</a>. So listening for <code class="markup--code markup--p-code">uncaughtException</code> is just a bad idea. This is why we recommend things like multiple processes and supervisors: crashing and restarting is often the most reliable way to recover from an error.</p><p name="5b2e" id="5b2e" class="graf graf--p graf-after--p">We also don’t recommend using <a href="https://nodejs.org/api/domain.html" data-href="https://nodejs.org/api/domain.html" class="markup--anchor markup--p-anchor" title="https://nodejs.org/api/domain.html" rel="noopener" target="_blank">domains</a>. It generally doesn’t solve the problem and is a deprecated module.</p><h4 name="f8fe" id="f8fe" class="graf graf--h4 graf-after--p">Use try-catch</h4><p name="1c85" id="1c85" class="graf graf--p graf-after--h4">Try-catch is a JavaScript language construct that you can use to catch exceptions in synchronous code. Use try-catch, for example, to handle JSON parsing errors as shown below.</p><p name="0582" id="0582" class="graf graf--p graf-after--p">Use a tool such as <a href="http://jshint.com/" data-href="http://jshint.com/" class="markup--anchor markup--p-anchor" title="http://jshint.com/" rel="noopener" target="_blank">JSHint</a> or <a href="http://www.jslint.com/" data-href="http://www.jslint.com/" class="markup--anchor markup--p-anchor" title="http://www.jslint.com/" rel="noopener" target="_blank">JSLint</a> to help you find implicit exceptions like <a href="http://www.jshint.com/docs/options/#undef" data-href="http://www.jshint.com/docs/options/#undef" class="markup--anchor markup--p-anchor" title="http://www.jshint.com/docs/options/#undef" rel="noopener" target="_blank">reference errors on undefined variables</a>.</p><p name="fc0f" id="fc0f" class="graf graf--p graf-after--p">Here is an example of using try-catch to handle a potential process-crashing exception. This middleware function accepts a query field parameter named “params” that is a JSON object.</p><pre name="1c58" id="1c58" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">app.get(&#39;/search&#39;, function (req, res) {<br>  // Simulating async operation<br>  setImmediate(function () {<br>    var jsonStr = req.query.params<br>    try {<br>      var jsonObj = JSON.parse(jsonStr)<br>      res.send(&#39;Success&#39;)<br>    } catch (e) {<br>      res.status(400).send(&#39;Invalid JSON string&#39;)<br>    }<br>  })<br>})</code></pre><p name="0501" id="0501" class="graf graf--p graf-after--pre">However, try-catch works only for synchronous code. Because the Node platform is primarily asynchronous (particularly in a production environment), try-catch won’t catch a lot of exceptions.</p><h4 name="d6ff" id="d6ff" class="graf graf--h4 graf-after--p">Use promises</h4><p name="af50" id="af50" class="graf graf--p graf-after--h4">Promises will handle any exceptions (both explicit and implicit) in asynchronous code blocks that use <code class="markup--code markup--p-code">then()</code>. Just add <code class="markup--code markup--p-code">.catch(next)</code> to the end of promise chains. For example:</p><pre name="40ad" id="40ad" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">app.get(&#39;/&#39;, function (req, res, next) {<br>  // do some sync stuff<br>  queryDb()<br>    .then(function (data) {<br>      // handle data<br>      return makeCsv(data)<br>    })<br>    .then(function (csv) {<br>      // handle csv<br>    })<br>    .catch(next)<br>})</code></pre><pre name="7f3e" id="7f3e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">app.use(function (err, req, res, next) {<br>  // handle error<br>})</code></pre><p name="5595" id="5595" class="graf graf--p graf-after--pre">Now all errors asynchronous and synchronous get propagated to the error middleware.</p><p name="6cb9" id="6cb9" class="graf graf--p graf-after--p">However, there are two caveats:</p><ol class="postList"><li name="f314" id="f314" class="graf graf--li graf-after--p">All your asynchronous code must return promises (except emitters). If a particular library does not return promises, convert the base object by using a helper function like <a href="http://bluebirdjs.com/docs/api/promise.promisifyall.html" data-href="http://bluebirdjs.com/docs/api/promise.promisifyall.html" class="markup--anchor markup--li-anchor" title="http://bluebirdjs.com/docs/api/promise.promisifyall.html" rel="noopener" target="_blank">Bluebird.promisifyAll()</a>.</li><li name="319a" id="319a" class="graf graf--li graf-after--li">Event emitters (like streams) can still cause uncaught exceptions. So make sure you are handling the error event properly; for example:</li><li name="b3a0" id="b3a0" class="graf graf--li graf-after--li">const wrap = fn =&gt; (…args) =&gt; fn(…args).catch(args[2])</li><li name="37a8" id="37a8" class="graf graf--li graf-after--li">app.get(‘/’, wrap(async (req, res, next) =&gt; { const company = await getCompanyById(<a href="http://req.query.id" data-href="http://req.query.id" class="markup--anchor markup--li-anchor" title="http://req.query.id" rel="noopener" target="_blank">req.query.id</a>) const stream = getLogoStreamById(<a href="http://company.id" data-href="http://company.id" class="markup--anchor markup--li-anchor" title="http://company.id" rel="noopener" target="_blank">company.id</a>) stream.on(‘error’, next).pipe(res) }))</li></ol><p name="8524" id="8524" class="graf graf--p graf-after--li">The <code class="markup--code markup--p-code">wrap()</code> function is a wrapper that catches rejected promises and calls <code class="markup--code markup--p-code">next()</code> with the error as the first argument. For details, see <a href="https://strongloop.com/strongblog/async-error-handling-expressjs-es7-promises-generators/#cleaner-code-with-generators" data-href="https://strongloop.com/strongblog/async-error-handling-expressjs-es7-promises-generators/#cleaner-code-with-generators" class="markup--anchor markup--p-anchor" title="https://strongloop.com/strongblog/async-error-handling-expressjs-es7-promises-generators/#cleaner-code-with-generators" rel="noopener" target="_blank">Asynchronous Error Handling in Express with Promises, Generators and ES7</a>.</p><p name="d57e" id="d57e" class="graf graf--p graf-after--p">For more information about error-handling by using promises, see <a href="https://strongloop.com/strongblog/promises-in-node-js-with-q-an-alternative-to-callbacks/" data-href="https://strongloop.com/strongblog/promises-in-node-js-with-q-an-alternative-to-callbacks/" class="markup--anchor markup--p-anchor" title="https://strongloop.com/strongblog/promises-in-node-js-with-q-an-alternative-to-callbacks/" rel="noopener" target="_blank">Promises in Node.js with Q — An Alternative to Callbacks</a>.</p><h3 name="c6a0" id="c6a0" class="graf graf--h3 graf-after--p">Things to do in your environment / setup</h3><p name="ab9b" id="ab9b" class="graf graf--p graf-after--h3">Here are some things you can do in your system environment to improve your app’s performance:</p><ul class="postList"><li name="4d6b" id="4d6b" class="graf graf--li graf-after--p"><a href="#set-node_env-to-production" data-href="#set-node_env-to-production" class="markup--anchor markup--li-anchor" title="#set-node_env-to-production">Set NODE_ENV to “production”</a></li><li name="05f1" id="05f1" class="graf graf--li graf-after--li"><a href="#ensure-your-app-automatically-restarts" data-href="#ensure-your-app-automatically-restarts" class="markup--anchor markup--li-anchor" title="#ensure-your-app-automatically-restarts">Ensure your app automatically restarts</a></li><li name="c8e0" id="c8e0" class="graf graf--li graf-after--li"><a href="#run-your-app-in-a-cluster" data-href="#run-your-app-in-a-cluster" class="markup--anchor markup--li-anchor" title="#run-your-app-in-a-cluster">Run your app in a cluster</a></li><li name="f4af" id="f4af" class="graf graf--li graf-after--li"><a href="#cache-request-results" data-href="#cache-request-results" class="markup--anchor markup--li-anchor" title="#cache-request-results">Cache request results</a></li><li name="4d4a" id="4d4a" class="graf graf--li graf-after--li"><a href="#use-a-load-balancer" data-href="#use-a-load-balancer" class="markup--anchor markup--li-anchor" title="#use-a-load-balancer">Use a load balancer</a></li><li name="121c" id="121c" class="graf graf--li graf-after--li"><a href="#use-a-reverse-proxy" data-href="#use-a-reverse-proxy" class="markup--anchor markup--li-anchor" title="#use-a-reverse-proxy">Use a reverse proxy</a></li></ul><h3 name="e29a" id="e29a" class="graf graf--h3 graf-after--li">Set NODE_ENV to “production”</h3><p name="1e23" id="1e23" class="graf graf--p graf-after--h3">The NODE_ENV environment variable specifies the environment in which an application is running (usually, development or production). One of the simplest things you can do to improve performance is to set NODE_ENV to “production.”</p><p name="a71e" id="a71e" class="graf graf--p graf-after--p">Setting NODE_ENV to “production” makes Express:</p><ul class="postList"><li name="3499" id="3499" class="graf graf--li graf-after--p">Cache view templates.</li><li name="83b7" id="83b7" class="graf graf--li graf-after--li">Cache CSS files generated from CSS extensions.</li><li name="456c" id="456c" class="graf graf--li graf-after--li">Generate less verbose error messages.</li></ul><p name="4767" id="4767" class="graf graf--p graf-after--li"><a href="http://apmblog.dynatrace.com/2015/07/22/the-drastic-effects-of-omitting-node_env-in-your-express-js-applications/" data-href="http://apmblog.dynatrace.com/2015/07/22/the-drastic-effects-of-omitting-node_env-in-your-express-js-applications/" class="markup--anchor markup--p-anchor" title="http://apmblog.dynatrace.com/2015/07/22/the-drastic-effects-of-omitting-node_env-in-your-express-js-applications/" rel="noopener" target="_blank">Tests indicate</a> that just doing this can improve app performance by a factor of three!</p><p name="f585" id="f585" class="graf graf--p graf-after--p">If you need to write environment-specific code, you can check the value of NODE_ENV with <code class="markup--code markup--p-code">process.env.NODE_ENV</code>. Be aware that checking the value of any environment variable incurs a performance penalty, and so should be done sparingly.</p><p name="584a" id="584a" class="graf graf--p graf-after--p">In development, you typically set environment variables in your interactive shell, for example by using <code class="markup--code markup--p-code">export</code> or your <code class="markup--code markup--p-code">.bash_profile</code> file. But in general you shouldn’t do that on a production server; instead, use your OS’s init system (systemd or Upstart). The next section provides more details about using your init system in general, but setting NODE_ENV is so important for performance (and easy to do), that it’s highlighted here.</p><p name="5a0e" id="5a0e" class="graf graf--p graf-after--p">With Upstart, use the <code class="markup--code markup--p-code">env</code> keyword in your job file. For example:</p><pre name="b8b1" id="b8b1" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code"># /etc/init/env.conf<br> env NODE_ENV=production</code></pre><p name="e925" id="e925" class="graf graf--p graf-after--pre">For more information, see the <a href="http://upstart.ubuntu.com/cookbook/#environment-variables" data-href="http://upstart.ubuntu.com/cookbook/#environment-variables" class="markup--anchor markup--p-anchor" title="http://upstart.ubuntu.com/cookbook/#environment-variables" rel="noopener" target="_blank">Upstart Intro, Cookbook and Best Practices</a>.</p><p name="2d4a" id="2d4a" class="graf graf--p graf-after--p">With systemd, use the <code class="markup--code markup--p-code">Environment</code> directive in your unit file. For example:</p><pre name="32d3" id="32d3" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code"># /etc/systemd/system/myservice.service<br>Environment=NODE_ENV=production</code></pre><p name="3a85" id="3a85" class="graf graf--p graf-after--pre">For more information, see <a href="https://coreos.com/os/docs/latest/using-environment-variables-in-systemd-units.html" data-href="https://coreos.com/os/docs/latest/using-environment-variables-in-systemd-units.html" class="markup--anchor markup--p-anchor" title="https://coreos.com/os/docs/latest/using-environment-variables-in-systemd-units.html" rel="noopener" target="_blank">Using Environment Variables In systemd Units</a>.</p><h3 name="3b8d" id="3b8d" class="graf graf--h3 graf-after--p">Ensure your app automatically restarts</h3><p name="de0b" id="de0b" class="graf graf--p graf-after--h3">In production, you don’t want your application to be offline, ever. This means you need to make sure it restarts both if the app crashes and if the server itself crashes. Although you hope that neither of those events occurs, realistically you must account for both eventualities by:</p><ul class="postList"><li name="9675" id="9675" class="graf graf--li graf-after--p">Using a process manager to restart the app (and Node) when it crashes.</li><li name="d5af" id="d5af" class="graf graf--li graf-after--li">Using the init system provided by your OS to restart the process manager when the OS crashes. It’s also possible to use the init system without a process manager.</li></ul><p name="3687" id="3687" class="graf graf--p graf-after--li">Node applications crash if they encounter an uncaught exception. The foremost thing you need to do is to ensure your app is well-tested and handles all exceptions (see <a href="#handle-exceptions-properly" data-href="#handle-exceptions-properly" class="markup--anchor markup--p-anchor" title="#handle-exceptions-properly">handle exceptions properly</a> for details). But as a fail-safe, put a mechanism in place to ensure that if and when your app crashes, it will automatically restart.</p><h4 name="4214" id="4214" class="graf graf--h4 graf-after--p">Use a process manager</h4><p name="6dcf" id="6dcf" class="graf graf--p graf-after--h4">In development, you started your app simply from the command line with <code class="markup--code markup--p-code">node server.js</code> or something similar. But doing this in production is a recipe for disaster. If the app crashes, it will be offline until you restart it. To ensure your app restarts if it crashes, use a process manager. A process manager is a “container” for applications that facilitates deployment, provides high availability, and enables you to manage the application at runtime.</p><p name="8044" id="8044" class="graf graf--p graf-after--p">In addition to restarting your app when it crashes, a process manager can enable you to:</p><ul class="postList"><li name="bf0c" id="bf0c" class="graf graf--li graf-after--p">Gain insights into runtime performance and resource consumption.</li><li name="47ed" id="47ed" class="graf graf--li graf-after--li">Modify settings dynamically to improve performance.</li><li name="f0ed" id="f0ed" class="graf graf--li graf-after--li">Control clustering (StrongLoop PM and pm2).</li></ul><p name="a9d5" id="a9d5" class="graf graf--p graf-after--li">The most popular process managers for Node are as follows:</p><ul class="postList"><li name="1163" id="1163" class="graf graf--li graf-after--p"><a href="http://strong-pm.io/" data-href="http://strong-pm.io/" class="markup--anchor markup--li-anchor" title="http://strong-pm.io/" rel="noopener" target="_blank">StrongLoop Process Manager</a></li><li name="bb4a" id="bb4a" class="graf graf--li graf-after--li"><a href="https://github.com/Unitech/pm2" data-href="https://github.com/Unitech/pm2" class="markup--anchor markup--li-anchor" title="https://github.com/Unitech/pm2" rel="noopener" target="_blank">PM2</a></li><li name="1264" id="1264" class="graf graf--li graf-after--li"><a href="https://www.npmjs.com/package/forever" data-href="https://www.npmjs.com/package/forever" class="markup--anchor markup--li-anchor" title="https://www.npmjs.com/package/forever" rel="noopener" target="_blank">Forever</a></li></ul><p name="6f6d" id="6f6d" class="graf graf--p graf-after--li">For a feature-by-feature comparison of the three process managers, see <a href="http://strong-pm.io/compare/" data-href="http://strong-pm.io/compare/" class="markup--anchor markup--p-anchor" title="http://strong-pm.io/compare/" rel="noopener" target="_blank">http://strong-pm.io/compare/</a>. For a more detailed introduction to all three, see <a href="/%7B%7B%20page.lang%20%7D%7D/advanced/pm.html" data-href="/%7B%7B%20page.lang%20%7D%7D/advanced/pm.html" class="markup--anchor markup--p-anchor" title="/%7B%7B%20page.lang%20%7D%7D/advanced/pm.html" target="_blank">Process managers for Express apps</a>.</p><p name="633e" id="633e" class="graf graf--p graf-after--p">Using any of these process managers will suffice to keep your application up, even if it does crash from time to time.</p><p name="4cc3" id="4cc3" class="graf graf--p graf-after--p">However, StrongLoop PM has lots of features that specifically target production deployment. You can use it and the related StrongLoop tools to:</p><ul class="postList"><li name="0a60" id="0a60" class="graf graf--li graf-after--p">Build and package your app locally, then deploy it securely to your production system.</li><li name="db02" id="db02" class="graf graf--li graf-after--li">Automatically restart your app if it crashes for any reason.</li><li name="e1d5" id="e1d5" class="graf graf--li graf-after--li">Manage your clusters remotely.</li><li name="6f8a" id="6f8a" class="graf graf--li graf-after--li">View CPU profiles and heap snapshots to optimize performance and diagnose memory leaks.</li><li name="51e9" id="51e9" class="graf graf--li graf-after--li">View performance metrics for your application.</li><li name="7393" id="7393" class="graf graf--li graf-after--li">Easily scale to multiple hosts with integrated control for Nginx load balancer.</li></ul><p name="f0af" id="f0af" class="graf graf--p graf-after--li">As explained below, when you install StrongLoop PM as an operating system service using your init system, it will automatically restart when the system restarts. Thus, it will keep your application processes and clusters alive forever.</p><h3 name="4f1d" id="4f1d" class="graf graf--h3 graf-after--p">Cache request results</h3><p name="e93f" id="e93f" class="graf graf--p graf-after--h3">Another strategy to improve the performance in production is to cache the result of requests, so that your app does not repeat the operation to serve the same request repeatedly.</p><p name="224a" id="224a" class="graf graf--p graf-after--p">Use a caching server like <a href="https://www.varnish-cache.org/" data-href="https://www.varnish-cache.org/" class="markup--anchor markup--p-anchor" title="https://www.varnish-cache.org/" rel="noopener" target="_blank">Varnish</a> or <a href="https://www.nginx.com/resources/wiki/start/topics/examples/reverseproxycachingexample/" data-href="https://www.nginx.com/resources/wiki/start/topics/examples/reverseproxycachingexample/" class="markup--anchor markup--p-anchor" title="https://www.nginx.com/resources/wiki/start/topics/examples/reverseproxycachingexample/" rel="noopener" target="_blank">Nginx</a> (see also <a href="https://serversforhackers.com/nginx-caching/" data-href="https://serversforhackers.com/nginx-caching/" class="markup--anchor markup--p-anchor" title="https://serversforhackers.com/nginx-caching/" rel="noopener" target="_blank">Nginx Caching</a>) to greatly improve the speed and performance of your app.</p><h3 name="ffea" id="ffea" class="graf graf--h3 graf-after--p">Use a load balancer</h3><p name="ab6c" id="ab6c" class="graf graf--p graf-after--h3">No matter how optimized an app is, a single instance can handle only a limited amount of load and traffic. One way to scale an app is to run multiple instances of it and distribute the traffic via a load balancer. Setting up a load balancer can improve your app’s performance and speed, and enable it to scale more than is possible with a single instance.</p><p name="f79a" id="f79a" class="graf graf--p graf-after--p">A load balancer is usually a reverse proxy that orchestrates traffic to and from multiple application instances and servers. You can easily set up a load balancer for your app by using <a href="http://nginx.org/en/docs/http/load_balancing.html" data-href="http://nginx.org/en/docs/http/load_balancing.html" class="markup--anchor markup--p-anchor" title="http://nginx.org/en/docs/http/load_balancing.html" rel="noopener" target="_blank">Nginx</a> or <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-haproxy-and-load-balancing-concepts" data-href="https://www.digitalocean.com/community/tutorials/an-introduction-to-haproxy-and-load-balancing-concepts" class="markup--anchor markup--p-anchor" title="https://www.digitalocean.com/community/tutorials/an-introduction-to-haproxy-and-load-balancing-concepts" rel="noopener" target="_blank">HAProxy</a>.</p><p name="8685" id="8685" class="graf graf--p graf-after--p">With load balancing, you might have to ensure that requests that are associated with a particular session ID connect to the process that originated them. This is known as <em class="markup--em markup--p-em">session affinity</em>, or <em class="markup--em markup--p-em">sticky sessions</em>, and may be addressed by the suggestion above to use a data store such as Redis for session data (depending on your application). For a discussion, see <a href="http://socket.io/docs/using-multiple-nodes/" data-href="http://socket.io/docs/using-multiple-nodes/" class="markup--anchor markup--p-anchor" title="http://socket.io/docs/using-multiple-nodes/" rel="noopener" target="_blank">Using multiple nodes</a>.</p><h3 name="7df5" id="7df5" class="graf graf--h3 graf-after--p">Use a reverse proxy</h3><p name="3cb6" id="3cb6" class="graf graf--p graf-after--h3">A reverse proxy sits in front of a web app and performs supporting operations on the requests, apart from directing requests to the app. It can handle error pages, compression, caching, serving files, and load balancing among other things.</p><p name="8cf6" id="8cf6" class="graf graf--p graf-after--p graf--trailing">Handing over tasks that do not require knowledge of application state to a reverse proxy frees up Express to perform specialized application tasks. For this reason, it is recommended to run Express behind a reverse proxy like <a href="https://www.nginx.com/" data-href="https://www.nginx.com/" class="markup--anchor markup--p-anchor" title="https://www.nginx.com/" rel="noopener" target="_blank">Nginx</a> or <a href="http://www.haproxy.org/" data-href="http://www.haproxy.org/" class="markup--anchor markup--p-anchor" title="http://www.haproxy.org/" rel="noopener" target="_blank">HAProxy</a> in production.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bryanguner" class="p-author h-card">Bryan Guner</a> on <a href="https://medium.com/p/75e3267b284a"><time class="dt-published" datetime="2021-08-04T20:23:46.317Z">August 4, 2021</time></a>.</p><p><a href="https://medium.com/@bryanguner/prerequisites-to-writing-express-apis-75e3267b284a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 10, 2021.</p></footer></article></body></html>