<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Fundamental Javascript Concepts You Should Understand</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Fundamental Javascript Concepts You Should Understand</h1>
</header>
<section data-field="subtitle" class="p-summary">
Plain Old JS Object Lesson Concepts
</section>
<section data-field="body" class="e-content">
<section name="653d" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3dba" id="3dba" class="graf graf--h3 graf--leading graf--title">Fundamental Javascript Concepts You Should Understand</h3><h3 name="771a" id="771a" class="graf graf--h3 graf-after--h3">Plain Old JS Object Lesson Concepts</h3><figure name="acca" id="acca" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*bEuahctJRS_qCQgV.jpg" data-width="639" data-height="724" src="https://cdn-images-1.medium.com/max/800/0*bEuahctJRS_qCQgV.jpg"></figure><ul class="postList"><li name="d911" id="d911" class="graf graf--li graf-after--figure">Label variables as either Primitive vs. Reference</li><li name="42a0" id="42a0" class="graf graf--li graf-after--li">primitives: strings, booleans, numbers, null and undefined</li><li name="4423" id="4423" class="graf graf--li graf-after--li">primitives are immutable</li><li name="fd1a" id="fd1a" class="graf graf--li graf-after--li">refereces: objects (including arrays)</li><li name="d581" id="d581" class="graf graf--li graf-after--li">references are mutable</li><li name="65e2" id="65e2" class="graf graf--li graf-after--li">Identify when to use <code class="markup--code markup--li-code">.</code> vs <code class="markup--code markup--li-code">[]</code> when accessing values of an object</li><li name="eb9d" id="eb9d" class="graf graf--li graf-after--li">dot syntax <code class="markup--code markup--li-code">object.key</code></li><li name="8e03" id="8e03" class="graf graf--li graf-after--li">easier to read</li><li name="1662" id="1662" class="graf graf--li graf-after--li">easier to write</li><li name="5796" id="5796" class="graf graf--li graf-after--li">cannot use variables as keys</li><li name="588a" id="588a" class="graf graf--li graf-after--li">keys cannot begin with a number</li><li name="5501" id="5501" class="graf graf--li graf-after--li">bracket notation <code class="markup--code markup--li-code">object[&quot;key]</code></li><li name="5734" id="5734" class="graf graf--li graf-after--li">allows variables as keys</li><li name="76ca" id="76ca" class="graf graf--li graf-after--li">strings that start with numbers can be use as keys</li><li name="822a" id="822a" class="graf graf--li graf-after--li">Write an object literal with a variable key using interpolation</li></ul><h4 name="d38b" id="d38b" class="graf graf--h4 graf-after--li">put it in brackets to access the value of the variable, rather than just make the value that string</h4><pre name="e15d" id="e15d" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">let a = &quot;b&quot;;<br>    let obj = {<br>        a: &quot;letter_a&quot;,<br>        [a]: &quot;letter b&quot;<br>    }</code></pre><ul class="postList"><li name="e4fc" id="e4fc" class="graf graf--li graf-after--pre">Use the <code class="markup--code markup--li-code">obj[key] !== undefined</code> pattern to check if a given variable that contains a key exists in an object</li><li name="0baa" id="0baa" class="graf graf--li graf-after--li">can also use <code class="markup--code markup--li-code">(key in object)</code> syntax interchangeably (returns a boolean)</li><li name="ad4c" id="ad4c" class="graf graf--li graf-after--li">Utilize Object.keys and Object.values in a function</li><li name="b548" id="b548" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Object.keys(obj)</code> returns an array of all the keys in <code class="markup--code markup--li-code">obj</code></li><li name="f39b" id="f39b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Object.values(obj)</code> returns an array of the values in <code class="markup--code markup--li-code">obj</code></li></ul><h4 name="1b24" id="1b24" class="graf graf--h4 graf-after--li">Iterate through an object using a <code class="markup--code markup--h4-code">for in</code> loop</h4><pre name="9621" id="9621" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">let printValues = function(obj) {<br>      for (let key in obj) {<br>          let value = obj[key];<br>          console.log(value);<br>      }<br>  }</code></pre><h4 name="edf6" id="edf6" class="graf graf--h4 graf-after--pre">Define a function that utilizes <code class="markup--code markup--h4-code">...rest</code> syntax to accept an arbitrary number of arguments</h4><ul class="postList"><li name="58a5" id="58a5" class="graf graf--li graf-after--h4"><code class="markup--code markup--li-code">...rest</code> syntax will store all additional arguments in an array</li><li name="5f8b" id="5f8b" class="graf graf--li graf-after--li">array will be empty if there are no additional arguments</li></ul><pre name="264d" id="264d" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">let myFunction = function(str, ...strs) {<br>        console.log(&quot;The first string is &quot; + str);<br>        console.log(&quot;The rest of the strings are:&quot;);<br>        strs.forEach(function(str) {<br>            console.log(str);<br>        })<br>    }</code></pre><h4 name="16b1" id="16b1" class="graf graf--h4 graf-after--pre">Use <code class="markup--code markup--h4-code">...spread</code> syntax for Object literals and Array literals</h4><pre name="1061" id="1061" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">let arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];<br>  let longer = [...arr1, &quot;d&quot;, &quot;e&quot;]; <em class="markup--em markup--pre-em">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</em><br>  <em class="markup--em markup--pre-em">// without spread syntax, this would give you a nested array</em><br>  let withoutRest = [arr1, &quot;d&quot;, &quot;e&quot;] <em class="markup--em markup--pre-em">// [[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;d&quot;, &quot;e&quot;]</em></code></pre><ul class="postList"><li name="118b" id="118b" class="graf graf--li graf-after--pre">Destructure an array to reference specific elements</li></ul><pre name="d312" id="d312" class="graf graf--pre graf-after--li">let array = [35, 9];</pre><pre name="53dd" id="53dd" class="graf graf--pre graf-after--pre">let [firstEl, secondEl] = array;</pre><pre name="b69c" id="b69c" class="graf graf--pre graf-after--pre">console.log(firstEl); // =&gt; 35</pre><pre name="27b5" id="27b5" class="graf graf--pre graf-after--pre">console.log(secondEl); // =&gt; 9</pre><pre name="3870" id="3870" class="graf graf--pre graf-after--pre">// can also destructure using … syntax let array = [35, 9, 14]; let [head, …tail] = array; console.log(head); // =&gt; 35 console.log(tail); // =&gt; [9, 14]</pre><pre name="5770" id="5770" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">-Destructure an object to reference specific values<br>    -<br>    if you want to use variable names that don &#39;t match the keys, you can use aliasing -<br>    `let { oldkeyname: newkeyname } = object` -<br>    rule of thumb— only destructure values from objects that are two levels deep ``<br>`javascript<br>let obj = {<br>   name: &quot;Wilfred&quot;,<br>   appearance: [&quot;short&quot;, &quot;mustache&quot;],<br>   favorites: {<br>      color: &quot;mauve&quot;,<br>      food: &quot;spaghetti squash&quot;,<br>      number: 3<br>   }<br>}<br>// with variable names that match keys<br>let { name, appearance } = obj;<br>console.log(name); // &quot;Wilfred&quot;<br>console.log(appearance); // [&quot;short&quot;, &quot;mustache&quot;]</code></pre><pre name="bbc8" id="bbc8" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// with new variable names (aliasing)<br>let {name: myName, appearance: myAppearance} = obj;</code></pre><pre name="7c9a" id="7c9a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(myName); // &quot;Wilfred&quot;<br>console.log(myAppearance); // [&quot;short&quot;, &quot;mustache&quot;]</code></pre><pre name="65fb" id="65fb" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// in a function call<br>let sayHello = function({name}) {<br>console.log(&quot;Hello, &quot; + name); // &quot;Hello Wilfred&quot;<br>}</code></pre><pre name="f3ba" id="f3ba" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// nested objects + aliasing<br>let { favorites: {color, food: vegetable} } = obj;<br>console.log(color, vegetable); //=&gt; mauve spaghetti squash</code></pre><h4 name="fccd" id="fccd" class="graf graf--h4 graf-after--pre">Write a function that accepts a array as an argument and returns an object representing the count of each character in the array</h4><pre name="f816" id="f816" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em">//</em><br>  let elementCounts = function(array) {<br>      let obj = {};<br>      array.forEach(function(el) {<br>          if (el in obj) obj[el] += 1;<br>          else obj[el] = 1;<br>      })<br>      return obj;<br>  }<br>  console.log(elementCounts([&quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;f&quot;])); <em class="markup--em markup--pre-em">// =&gt; Object {e: 1, f: 2, g: 1}</em></code></pre><h3 name="daee" id="daee" class="graf graf--h3 graf-after--pre">Callbacks Lesson Concepts</h3><ul class="postList"><li name="a16e" id="a16e" class="graf graf--li graf-after--h3">Given multiple plausible reasons, identify why functions are called “First Class Objects” in JavaScript.</li><li name="0d89" id="0d89" class="graf graf--li graf-after--li">they can be stored in variables, passed as arguments to other functions, and serve as return value for a function</li><li name="e458" id="e458" class="graf graf--li graf-after--li">supports same basic operations as other types (strings, bools, numbers)</li><li name="6af2" id="6af2" class="graf graf--li graf-after--li">higher-order functions take functions as arguments or return functions as values</li><li name="adbe" id="adbe" class="graf graf--li graf-after--li">Given a code snippet containing an anonymous callback, a named callback, and multiple <code class="markup--code markup--li-code">console.log</code>s, predict what will be printed</li><li name="e93b" id="e93b" class="graf graf--li graf-after--li">what is this referring to?</li><li name="c73f" id="c73f" class="graf graf--li graf-after--li">Write a function that takes in a value and two callbacks. The function should return the result of the callback that is greater.</li></ul><pre name="04f3" id="04f3" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">let greaterCB = function(val, callback1, callback2) {<br>    if (callback1(val) &gt; callback2(val)) {<br>        return callback1(val);<br>    }<br>    return callback2(val);<br>}</code></pre><pre name="11d8" id="11d8" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">let greaterCB = function(val, callback1, callback2) {<br>    if (callback1(val) &gt; callback2(val)) {<br>        return callback1(val);<br>    }<br>    return callback2(val);<br>}</code></pre><p name="db0b" id="db0b" class="graf graf--p graf-after--pre">// shorter version let greaterCB = function(val, callback1, callback2) { return Math.max(callback1(val), callback2(val)); } // even shorter, cause why not let greaterCB = (val, cb1, cb2) =&gt; Math.max(cb1(val), cb2(val));</p><pre name="0e19" id="0e19" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">-Write a<br>function, myMap, that takes in an array and a callback as arguments.The<br>function should mimic the behavior of `Array#map`.<br>``<br>`javascript<br>let myMap = function(array, callback) {<br>   let newArr = [];<br>   for (let i = 0; i &lt; array.length; i ++) {<br>      mapped = callback(array[i], i, array);<br>      newArr.push(mapped);<br>   }<br>   return newArr;<br>}<br>console.log( myMap([16,25,36], Math.sqrt)); <em class="markup--em markup--pre-em">// =&gt; [4, 5, 6];</em></code></pre><pre name="c48e" id="c48e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">let myMapArrow = (array, callback) =&gt; {<br>   let newArr = [];<br>   array.forEach( (ele, ind, array) =&gt; {<br>      newArr.push(callback(ele, ind, array));<br>   })<br>   return newArr;<br>}<br>console.log(myMapArrow([16,25,36], Math.sqrt)); <em class="markup--em markup--pre-em">// =&gt; [4, 5, 6];</em></code></pre><h4 name="3533" id="3533" class="graf graf--h4 graf-after--pre">Write a function, myFilter, that takes in an array and a callback as arguments. The function should mimic the behavior of <code class="markup--code markup--h4-code">Array#filter</code>.</h4><pre name="3af1" id="3af1" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">let myFilter = function(array, callback) {<br>      let filtered = [];<br>      for (let i = 0; i &lt; array.length; i++) {<br>          if (callback(array[i])) {<br>              filtered.push(array[i], i, array);<br>          }<br>      }<br>  }</code></pre><h4 name="4a5c" id="4a5c" class="graf graf--h4 graf-after--pre">Write a function, myEvery, that takes in an array and a callback as arguments. The function should mimic the behavior of <code class="markup--code markup--h4-code">Array#every</code>.</h4><pre name="f225" id="f225" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">let myEvery = function(array, callback) {<br>      for (let i = 0; i &lt; array.length; i++) {<br>          if (!callback(array[i], i, array)) {<br>              return false<br>          }<br>      }<br>      return true;<br>  }<br>  <em class="markup--em markup--pre-em">// with arrow function syntax</em><br>  let myEvery = (array, callback) =&gt; {<br>      for (let i = 0; i &lt; array.length; i++) {<br>          if (!callback(array[i])) {<br>              return false<br>          }<br>      }<br>      return true;<br>  }</code></pre><h3 name="d45e" id="d45e" class="graf graf--h3 graf-after--pre">Scope Lesson Concepts</h3><ul class="postList"><li name="685f" id="685f" class="graf graf--li graf-after--h3">Identify the difference between <code class="markup--code markup--li-code">const</code>, <code class="markup--code markup--li-code">let</code>, and <code class="markup--code markup--li-code">var</code> declarations</li><li name="7308" id="7308" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">const</code> - cannot reassign variable, scoped to block</li><li name="e07f" id="e07f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">let</code> - can reassign variable, scoped to block</li><li name="670d" id="670d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">var</code> - outdated, may or may not be reassigned, scoped to function. can be not just reassigned, but also redeclared!</li><li name="b254" id="b254" class="graf graf--li graf-after--li">a variable will always evaluate to the value it contains regardless of how it was declared</li><li name="aace" id="aace" class="graf graf--li graf-after--li">Explain the difference between <code class="markup--code markup--li-code">const</code>, <code class="markup--code markup--li-code">let</code>, and <code class="markup--code markup--li-code">var</code> declarations</li><li name="5d79" id="5d79" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">var</code> is function scoped—so if you declare it anywhere in a function, the declaration (but not assignment) is &quot;hoisted&quot;</li><li name="a54b" id="a54b" class="graf graf--li graf-after--li">so it will exist in memory as “undefined” which is bad and unpredictable</li><li name="2dc2" id="2dc2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">var</code> will also allow you to redeclare a variable, while <code class="markup--code markup--li-code">let</code> or <code class="markup--code markup--li-code">const</code> will raise a syntax error. you shouldn&#39;t be able to do that!</li><li name="1f74" id="1f74" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">const</code> won&#39;t let you reassign a variable, but if it points to a mutable object, you will still be able to change the value by mutating the object</li><li name="2c20" id="2c20" class="graf graf--li graf-after--li">block-scoped variables allow new variables with the same name in new scopes</li><li name="c3d4" id="c3d4" class="graf graf--li graf-after--li">block-scoped still performs hoisting of all variables within the block, but it doesn’t initialize to the value of <code class="markup--code markup--li-code">undefined</code> like <code class="markup--code markup--li-code">var</code> does, so it throws a specific reference error if you try to access the value before it has been declared</li><li name="f797" id="f797" class="graf graf--li graf-after--li">if you do not use <code class="markup--code markup--li-code">var</code> or <code class="markup--code markup--li-code">let</code> or <code class="markup--code markup--li-code">const</code> when initializing, it will be declared as global—THIS IS BAD</li><li name="2212" id="2212" class="graf graf--li graf-after--li">if you assign a value without a declaration, it exists in the global scope (so then it would be accessible by all outer scopes, so bad). however, there’s no hoisting, so it doesn’t exist in the scope until after the line is run</li><li name="86d1" id="86d1" class="graf graf--li graf-after--li">Predict the evaluation of code that utilizes function scope, block scope, lexical scope, and scope chaining</li><li name="25dc" id="25dc" class="graf graf--li graf-after--li">scope of a program means the set of variables that are available for use within the program</li><li name="bcaf" id="bcaf" class="graf graf--li graf-after--li">global scope is represented by the <code class="markup--code markup--li-code">window</code> object in the browser and the <code class="markup--code markup--li-code">global</code> object in Node.js</li><li name="7bc3" id="7bc3" class="graf graf--li graf-after--li">global variables are available everywhere, and so increase the risk of name collisions</li><li name="5172" id="5172" class="graf graf--li graf-after--li">local scope is the set of variables available for use within the function</li><li name="ed33" id="ed33" class="graf graf--li graf-after--li">when we enter a function, we enter a new scope</li><li name="c21b" id="c21b" class="graf graf--li graf-after--li">includes functions arguments, local variables declared inside function, and any variables that were already declared when the function is defined (hmm about that last one)</li><li name="51ad" id="51ad" class="graf graf--li graf-after--li">for blocks (denoted by curly braces <code class="markup--code markup--li-code">{}</code>, as in conditionals or <code class="markup--code markup--li-code">for</code> loops), variables can be block scoped</li><li name="09f1" id="09f1" class="graf graf--li graf-after--li">inner scope does not have access to variables in the outer scope</li><li name="587e" id="587e" class="graf graf--li graf-after--li">scope chaining — if a given variable is not found in immediate scope, javascript will search all accessible outer scopes until variable is found</li><li name="6ea5" id="6ea5" class="graf graf--li graf-after--li">so an inner scope can access outer scope variables</li><li name="5188" id="5188" class="graf graf--li graf-after--li">but an outer scope can never access inner scope variables</li></ul><h4 name="e609" id="e609" class="graf graf--h4 graf-after--li">Define an arrow function</h4><pre name="5804" id="5804" class="graf graf--pre graf-after--h4">let arrowFunction = (param1, param2) =&gt; {</pre><pre name="2b4c" id="2b4c" class="graf graf--pre graf-after--pre">let sum = param1 + param2;</pre><pre name="4695" id="4695" class="graf graf--pre graf-after--pre">return sum;</pre><pre name="dea4" id="dea4" class="graf graf--pre graf-after--pre">}</pre><pre name="cb31" id="cb31" class="graf graf--pre graf-after--pre">// with 1 param you can remove parens around parameters let arrowFunction = param =&gt;</pre><pre name="961b" id="961b" class="graf graf--pre graf-after--pre">// if your return statement is one line, you can use implied return let arrowFunction = param =&gt; param + 1;</pre><pre name="2ea9" id="2ea9" class="graf graf--pre graf-after--pre">// you don’t have to assign to variable, can be anonymous // if you never need to use it again param =&gt; param + 1;</pre><h4 name="187d" id="187d" class="graf graf--h4 graf-after--pre">Given an arrow function, deduce the value of <code class="markup--code markup--h4-code">this</code> without executing the code</h4><ul class="postList"><li name="0ee6" id="0ee6" class="graf graf--li graf-after--h4">arrow functions are automatically bound to the context they were declared in.</li><li name="9fb2" id="9fb2" class="graf graf--li graf-after--li">unlike regular function which use the context they are invoked in (unless they have been bound using <code class="markup--code markup--li-code">Function#bind</code>).</li><li name="683a" id="683a" class="graf graf--li graf-after--li">if you implement an arrow function as a method in an object the context it will be bound to is NOT the object itself, but the global context.</li><li name="e9e1" id="e9e1" class="graf graf--li graf-after--li">so you can’t use an arrow function to define a method directly</li></ul><pre name="526d" id="526d" class="graf graf--pre graf-after--li">let obj = {<br>name: “my object”,<br>unboundFunc: function () {</pre><pre name="a97c" id="a97c" class="graf graf--pre graf-after--pre">return <a href="http://this.name" data-href="http://this.name" class="markup--anchor markup--pre-anchor" title="http://this.name" rel="noopener" target="_blank">this.name</a>;</pre><pre name="6d6f" id="6d6f" class="graf graf--pre graf-after--pre">// this function will be able to be called on different objects</pre><pre name="47fc" id="47fc" class="graf graf--pre graf-after--pre">},<br>boundToGlobal: () =&gt; { return <a href="http://this.name" data-href="http://this.name" class="markup--anchor markup--pre-anchor" title="http://this.name" rel="noopener" target="_blank">this.name</a>; // this function, no matter how you call it, will be called // on the global object, and it cannot be rebound // this is because it was defined using arrow syntax },</pre><pre name="8102" id="8102" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">makeFuncBoundToObj: function() {<br>        return () =&gt; {<br>            return this.name;<br>        }<br>        <em class="markup--em markup--pre-em">// this function will return a function that will be bound</em><br>        <em class="markup--em markup--pre-em">// to the object where we call the outer method</em><br>        <em class="markup--em markup--pre-em">// because the arrow syntax is nested inside one of this</em><br>        <em class="markup--em markup--pre-em">// function&#39;s methods, it cannot be rebound</em><br>    },</code></pre><pre name="e4f1" id="e4f1" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">    makeUnboundFunc: function() {<br>        return function() {<br>            return this.name;<br>        }<br>        <em class="markup--em markup--pre-em">//this function will return a function that will still be unbound</em><br>    },</code></pre><pre name="6fe0" id="6fe0" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">    immediatelyInvokedFunc: function() {<br>        return this.name;<br>    }(), <em class="markup--em markup--pre-em">// this property will be set to the return value of this anonymous function,</em><br>    <em class="markup--em markup--pre-em">// which is invoked during the object definition;</em><br>    <em class="markup--em markup--pre-em">// basically, it&#39;s a way to check the context inside of an object, at this moment</em></code></pre><pre name="67cf" id="67cf" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">    innerObj: {<br>        name: &quot;inner object&quot;,<br>        innerArrowFunc: () =&gt; {<br>            return this.name;<br>        } <em class="markup--em markup--pre-em">// the context inside a nested object is not the parent, it&#39;s still</em><br>        <em class="markup--em markup--pre-em">// the global object. entering an object definition doesn&#39;t change the context</em><br>    },</code></pre><pre name="e194" id="e194" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">    let otherObj = {<br>        name: &quot;my other object&quot;<br>    }<br><em class="markup--em markup--pre-em">// call unboundFunc on obj, we get &quot;my object&quot; console.log(&quot;unboundFunc: &quot;, obj.unboundFunc()); // =&gt; &quot;my object&quot; // assign unboundFunc to a variable and call it let newFunc = obj.unboundFunc; // this newFunc will default to being called on global object console.log(&quot;newFunc: &quot;,newFunc()); // =&gt; undefined // but you could bind it directly to a different object if you wanted console.log(&quot;newFunc: &quot;, newFunc.bind(otherObj)()); // &quot;my other object&quot;</em><br><em class="markup--em markup--pre-em">// meanwhile, obj.boundToGlobal will only ever be called on global object console.log(&quot;boundToGlobal: &quot;, obj.boundToGlobal()); //=&gt; undefined let newBoundFunc = obj.boundToGlobal; console.log(&quot;newBoundFunc: &quot;, newBoundFunc()); // =&gt; undefined // even if you try to directly bind to another object, it won&#39;t work! console.log(&quot;newBoundFunc: &quot;, newBoundFunc.bind(otherObj)()); // =&gt; undefined</em><br><em class="markup--em markup--pre-em">// let&#39;s make a new function that will always be bound to the context // where we call our function maker let boundFunc = obj.makeFuncBoundToObj();// note that we&#39;re invoking, not just assigning console.log(&quot;boundFunc: &quot;, boundFunc()); // =&gt; &quot;my object&quot; // we can&#39;t rebind this function console.log(&quot;boundFunc: &quot;, boundFunc.bind(otherObj)()) // =&gt;&quot;my object&quot;</em><br><em class="markup--em markup--pre-em">// but if I call makeFuncBoundToObj on another context // the new bound function is stuck with that other context let boundToOther = obj.makeFuncBoundToObj.bind(otherObj)(); console.log(&quot;boundToOther: &quot;, boundToOther()); // =&gt; &quot;my other object&quot; console.log(&quot;boundToOther: &quot;, boundToOther.bind(obj)()) // &quot;my other object&quot;</em><br><em class="markup--em markup--pre-em">// the return value of my immediately invoked function // shows that the context inside of the object is the // global object, not the object itself // context only changes inside a function that is called // on an object console.log(&quot;immediatelyInvokedFunc: &quot;, obj.immediatelyInvokedFunc); // =&gt; undefined</em><br><em class="markup--em markup--pre-em">// even though we&#39;re inside a nested object, the context is // still the same as it was outside the outer object // in this case, the global object console.log(&quot;innerArrowFunc: &quot;, obj.innerObj.innerArrowFunc()); // =&gt; undefined</em></code></pre><pre name="b116" id="b116" class="graf graf--pre graf-after--pre">}</pre><pre name="9349" id="9349" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">-Implement a closure and explain how the closure effects scope<br>    -<br>    a closure is &quot;the combination of a function and the lexical environment within which that function was declared&quot; -<br>    alternatively, &quot;when an inner function uses or changes variables in an outer function&quot; -<br>    closures have access to any variables within their own scope + scope of outer functions + global scope— the set of all these available variables is &quot;lexical environemnt&quot; -<br>    closure keeps reference to all variables ** even<br>if the outer<br>function has returned **<br>    -each<br>function has a private mutable state that cannot be accessed externally<br>    -<br>    the inner<br>function will maintain a reference to the scope in which it was declared.so it has access to variables that were initialized in any outer scope— even<br>if that scope<br>    -<br>    if a variable exists in the scope of what could have been accessed by a<br>function(e.g.global scope, outer<br>    function, etc), does that variable wind up in the closure even<br>if it never got accessed ?<br>    -<br>    if you change the value of a variable(e.g.i++) you will change the value of that variable in the scope that it was declared in</code></pre><pre name="42e1" id="42e1" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    ``<br>`javascript<br>function createCounter() {<br>   // this function starts a counter at 0, then returns a<br>   // new function that can access and change that counter<br>   //<br>   // each new counter you create will have a single internal<br>   // state, that can be changed only by calling the function.<br>   // you can&#39;t access that state from outside of the function,<br>   // even though the count variable in question is initialized<br>   // by the outer function, and it remains accessible to the<br>   // inner function after the outer function returns.<br>   let count = 0;<br>   return function() {<br>      count ++;<br>      return count;<br>   }<br>}</code></pre><pre name="8691" id="8691" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">let counter = createCounter();<br>console.log(counter()); //=&gt; 1<br>console.log(counter()); //=&gt; 2<br>// so the closure here comes into play because<br>// an inner function is accessing and changing<br>// a variable from an outer function</code></pre><pre name="4a38" id="4a38" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// the closure is the combination of the counter<br>// function and the all the variables that existed<br>// in the scope that it was declared in. because<br>// inner blocks/functions have access to outer<br>// scopes, that includes the scope of the outer<br>// function.</code></pre><pre name="b89c" id="b89c" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// so counter variable is a closure, in that<br>// it contains the inner count value that was<br>// initialized by the outer createCounter() function<br>// count has been captured or closed over</code></pre><pre name="9db8" id="9db8" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// this state is private, so if i run createCounter again<br>// i get a totally separate count that doesn&#39;t interact<br>// with the previous one and each of the new functions<br>// will have their own internal state based on the<br>// initial declaration in the now-closed outer function</code></pre><pre name="e5d2" id="e5d2" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">let counter2 = createCounter();<br>console.log(counter2()); // =&gt; 1</code></pre><pre name="cd4e" id="cd4e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// if i set a new function equal to my existing counter<br>// the internal state is shared with the new function<br>let counter3 = counter2;<br>console.log(counter3());</code></pre><h4 name="76a8" id="76a8" class="graf graf--h4 graf-after--pre">Define a method that references <code class="markup--code markup--h4-code">this</code> on an object literal</h4><ul class="postList"><li name="ae61" id="ae61" class="graf graf--li graf-after--h4">when we use <code class="markup--code markup--li-code">this</code> in a method it refers to the object that the method is invoked on</li><li name="29a2" id="29a2" class="graf graf--li graf-after--li">it will let you access other pieces of information from within that object, or even other methods</li><li name="c41d" id="c41d" class="graf graf--li graf-after--li">method style invocation — <code class="markup--code markup--li-code">object.method(args)</code> (e.g. built in examples like <code class="markup--code markup--li-code">Array#push</code>, or <code class="markup--code markup--li-code">String#toUpperCase</code>)</li><li name="c99d" id="c99d" class="graf graf--li graf-after--li">context is set every time we invoke a function</li><li name="fa43" id="fa43" class="graf graf--li graf-after--li">function style invocation sets the context to the global object no matter what</li><li name="8cc1" id="8cc1" class="graf graf--li graf-after--li">being inside an object does not make the context that object! you still have to use method-style invocation</li><li name="f578" id="f578" class="graf graf--li graf-after--li">Utilize the built in <code class="markup--code markup--li-code">Function#bind</code> on a callback to maintain the context of this</li><li name="26ba" id="26ba" class="graf graf--li graf-after--li">when we call bind on a function, we get an exotic function back — so the context will always be the same for that new function</li></ul><pre name="deaa" id="deaa" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">let cat = {<br>  purr: function () {<br>  console.log(&quot;meow&quot;);<br>  },<br>  purrMore: function () {<br>  this.purr();<br>  },<br>  };<br>  let sayMeow = cat.purrMore; console.log(sayMeow()); // TypeError: this.purr is not a function</code></pre><pre name="b55e" id="b55e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  // we can use the built in Function.bind to ensure our context, our this, // is the cat object let boundCat = sayMeow.bind(cat);<br>  boundCat(); // prints &quot;meow&quot;</code></pre><pre name="00a2" id="00a2" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">-`bind`<br>   can also work with arguments, so you can have a version of a<br>   function with particular arguments and a particular context.the first arg will be the context aka the `this`<br>   you want it to use.the next arguments will be the functions arguments that you are binding -<br>       if you just want to bind it to those arguments in particular, you can use `null`<br>   as the first argument, so the context won &#39;t be bound, just the arguments -<br>       Given a code snippet, identify what `this`<br>   refers to<br>       -<br>       important to recognize the difference between scope and context -<br>       scope works like a dictionary that has all the variables that are available within a given block, plus a pointer back the next outer scope(which itself has pointers to new scopes until you reach the global scope.so you can think about a whole given block &#39;s scope as a kind of linked list of dictionaries) (also, this is not to say that scope is actually implemented in this way, that is just the schema that i can use to understand it) -<br>           context refers to the value of the `this`<br>           keyword -<br>           the keyword `this`<br>           exists in every<br>           function and it evaluates to the object that is currently invoking that<br>           function -so the context is fairly straightforward when we talk about methods being called on specific objects -<br>           you could, however, call an object &#39;s method on something other than that object, and then this would refer to the context where/how it was called, e.g.<br>           ``<br>           `javascript<br>let dog = {<br>   name: &quot;Bowser&quot;,<br>   changeName: function () {<br>      this.name = &quot;Layla&quot;;<br>  },<br>};</code></pre><pre name="3210" id="3210" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// note this is **not invoked** - we are assigning the function itself<br>let change = dog.changeName;<br>console.log(change()); // undefined</code></pre><pre name="d70c" id="d70c" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// our dog still has the same name<br>console.log(dog); // { name: &#39;Bowser&#39;, changeName: [Function: changeName] }</code></pre><pre name="5366" id="5366" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// instead of changing the dog we changed the global name!!!<br>console.log(this); // Object [global] {etc, etc, etc,  name: &#39;Layla&#39;}</code></pre><h3 name="c74f" id="c74f" class="graf graf--h3 graf-after--pre">CALLING SOMETHING IN THE WRONG CONTEXT CAN MESS YOU UP!</h3><ul class="postList"><li name="b960" id="b960" class="graf graf--li graf-after--h3">could throw an error if it expects this to have some other method or whatever that doesn’t exist</li><li name="1880" id="1880" class="graf graf--li graf-after--li">you could also overwrite values or assign values to exist in a space where they should not exist</li><li name="c9f0" id="c9f0" class="graf graf--li graf-after--li">if you call a function as a callback, it will set <code class="markup--code markup--li-code">this</code> to be the outer function itself, even if the function you were calling is a method that was called on a particular object</li></ul><pre name="8ddd" id="8ddd" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">let cat = {<br>  purr: function () {<br>  console.log(&quot;meow&quot;);<br>  },<br>  purrMore: function () {<br>  this.purr();<br>  },<br>  };<br>  global.setTimeout(cat.purrMore, 5000); // 5 seconds later: TypeError: this.purr is not a function</code></pre><p name="0fea" id="0fea" class="graf graf--p graf-after--pre">we can use strict mode with <code class="markup--code markup--p-code">&quot;use strict&quot;;</code> this will prevent you from accessing the global object with <code class="markup--code markup--p-code">this</code> in functions, so if you try to call <code class="markup--code markup--p-code">this</code> in the global context and change a value, you will get a type error, and the things you try to access will be undefined</p><pre name="8599" id="8599" class="graf graf--pre graf-after--p">let sayMeow = cat.purrMore; console.log(sayMeow()); // TypeError: this.purr is not a function</pre><pre name="3569" id="3569" class="graf graf--pre graf-after--pre">// we can use the built in Function.bind to ensure our context, our <code class="markup--code markup--pre-code">this</code> , // is the cat object let boundCat = sayMeow.bind(cat);</pre><pre name="156d" id="156d" class="graf graf--pre graf-after--pre">boundCat(); // prints “meow”</pre><pre name="b1b8" id="b1b8" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">-`bind`<br>   can also work with arguments, so you can have a version of a<br>   function with particular arguments and a particular context.the first arg will be the context aka the `this`<br>   you want it to use.the next arguments will be the functions arguments that you are binding -<br>       if you just want to bind it to those arguments in particular, you can use `null`<br>   as the first argument, so the context won &#39;t be bound, just the arguments -<br>       Given a code snippet, identify what `this`<br>   refers to<br>       -<br>       important to recognize the difference between scope and context -<br>       scope works like a dictionary that has all the variables that are available within a given block, plus a pointer back the next outer scope(which itself has pointers to new scopes until you reach the global scope.so you can think about a whole given block &#39;s scope as a kind of linked list of dictionaries) (also, this is not to say that scope is actually implemented in this way, that is just the schema that i can use to understand it) -<br>           context refers to the value of the `this`<br>           keyword -<br>           the keyword `this`<br>           exists in every<br>           function and it evaluates to the object that is currently invoking that<br>           function -so the context is fairly straightforward when we talk about methods being called on specific objects -<br>           you could, however, call an object &#39;s method on something other than that object, and then this would refer to the context where/how it was called, e.g.<br>           ``<br>           `javascript<br>let dog = {<br>   name: &quot;Bowser&quot;,<br>   changeName: function () {<br>      this.name = &quot;Layla&quot;;<br>  },<br>};</code></pre><pre name="ff9b" id="ff9b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// note this is **not invoked** - we are assigning the function itself<br>let change = dog.changeName;<br>console.log(change()); // undefined</code></pre><pre name="7ef5" id="7ef5" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// our dog still has the same name<br>console.log(dog); // { name: &#39;Bowser&#39;, changeName: [Function: changeName] }</code></pre><pre name="ba61" id="ba61" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// instead of changing the dog we changed the global name!!!<br>console.log(this); // Object [global] {etc, etc, etc,  name: &#39;Layla&#39;}</code></pre><ul class="postList"><li name="48ab" id="48ab" class="graf graf--li graf-after--pre">CALLING SOMETHING IN THE WRONG CONTEXT CAN MESS YOU UP!</li><li name="857d" id="857d" class="graf graf--li graf-after--li">could throw an error if it expects this to have some other method or whatever that doesn’t exist</li><li name="e09e" id="e09e" class="graf graf--li graf-after--li">you could also overwrite values or assign values to exist in a space where they should not exist</li><li name="b6e0" id="b6e0" class="graf graf--li graf-after--li">if you call a function as a callback, it will set <code class="markup--code markup--li-code">this</code> to be the outer function itself, even if the function you were calling is a method that was called on a particular object</li></ul><blockquote name="1b4e" id="1b4e" class="graf graf--blockquote graf-after--li">we can use strict mode with <code class="markup--code markup--blockquote-code">&quot;use strict&quot;;</code> this will prevent you from accessing the global object with <code class="markup--code markup--blockquote-code">this</code> in functions, so if you try to call <code class="markup--code markup--blockquote-code">this</code> in the global context and change a value, you will get a type error, and the things you try to access will be undefined</blockquote><h3 name="328e" id="328e" class="graf graf--h3 graf-after--blockquote">POJOs</h3><h4 name="fc8e" id="fc8e" class="graf graf--h4 graf-after--h3">1. Label variables as either Primitive vs. Reference</h4><p name="44bc" id="44bc" class="graf graf--p graf-after--h4">Javascript considers most data types to be ‘primitive’, these data types are immutable, and are passed by value. The more complex data types: Array and Object are mutable, are considered ‘reference’ data types, and are passed by reference.</p><ul class="postList"><li name="6f83" id="6f83" class="graf graf--li graf-after--p">Boolean — Primitive</li><li name="6556" id="6556" class="graf graf--li graf-after--li">Null — Primitive</li><li name="0048" id="0048" class="graf graf--li graf-after--li">Undefined — Primitive</li><li name="8dec" id="8dec" class="graf graf--li graf-after--li">Number — Primitive</li><li name="684c" id="684c" class="graf graf--li graf-after--li">String — Primitive</li><li name="41c1" id="41c1" class="graf graf--li graf-after--li">Array — Reference</li><li name="9371" id="9371" class="graf graf--li graf-after--li">Object — Reference</li><li name="64c8" id="64c8" class="graf graf--li graf-after--li">Function — Reference</li></ul><h4 name="5322" id="5322" class="graf graf--h4 graf-after--li">2. Identify when to use . vs [] when accessing values of an object</h4><pre name="8f4b" id="8f4b" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">let obj = {<br>    &quot;one&quot;: 1,<br>    &quot;two&quot;: 2<br>};</code></pre><pre name="ebe0" id="ebe0" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em">// Choose the square brackets property accessor when the property name is determined at</em><br><em class="markup--em markup--pre-em">// runtime, or if the property name is not a valid identifier</em><br>let myKey = &quot;one&quot;;<br>console.log(obj[myKey]);</code></pre><pre name="0b36" id="0b36" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em">// Choose the dot property accessor when the property name is known ahead of time.</em><br>console.log(obj.two);</code></pre><h4 name="68a8" id="68a8" class="graf graf--h4 graf-after--pre">3. Write an object literal with a variable key using interpolation</h4><pre name="c04e" id="c04e" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">let keyName = &quot;two&quot;;</code></pre><pre name="cae3" id="cae3" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em">// If the key is not known, you can use an alternative `[]` syntax for</em><br><em class="markup--em markup--pre-em">// object initialization only</em><br>let obj2 = {<br>    [keyName]: 2<br>}<br>console.log(obj2);</code></pre><h4 name="3aed" id="3aed" class="graf graf--h4 graf-after--pre">4. Use the obj[key] !== undefined pattern to check if a given variable that contains a key exists in an object</h4><pre name="354d" id="354d" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">function doesKeyExist(obj, key) {<br>    <em class="markup--em markup--pre-em">// obj[key] !== undefined</em><br>    <em class="markup--em markup--pre-em">// or:</em><br>    return key in obj;<br>}</code></pre><pre name="2778" id="2778" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">let course = {<br>    bootcamp: &#39;Lambda&#39;,<br>    course: &#39;Bootcamp Prep&#39;<br>}<br>console.log(doesKeyExist(course, &#39;course&#39;)); <em class="markup--em markup--pre-em">// =&gt; true</em><br>console.log(doesKeyExist(course, &#39;name&#39;)); <em class="markup--em markup--pre-em">// =&gt; false</em></code></pre><h4 name="9072" id="9072" class="graf graf--h4 graf-after--pre">5. Utilize Object.keys and Object.values in a function</h4><pre name="b88e" id="b88e" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">function printKeys(object) {<br>    return Object.keys(object);<br>}</code></pre><pre name="4532" id="4532" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function printValues(object) {<br>    return Object.values(object);<br>}</code></pre><pre name="d095" id="d095" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(printKeys({<br>    dog: &quot;Strelka&quot;,<br>    dog2: &quot;Belka&quot;<br>}));<br>console.log(printValues({<br>    dog: &quot;Strelka&quot;,<br>    dog2: &quot;Belka&quot;<br>}));</code></pre><h4 name="001c" id="001c" class="graf graf--h4 graf-after--pre">6. Iterate through an object using a for in loop</h4><pre name="4363" id="4363" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">let player = {<br>    name: &quot;Sergey&quot;,<br>    skill: &quot;hockey&quot;<br>};</code></pre><pre name="03f4" id="03f4" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">for (let key in player) {<br>    console.log(key, player[key]);<br>}</code></pre><pre name="99ec" id="99ec" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(Object.entries(player));</code></pre><h4 name="4f3a" id="4f3a" class="graf graf--h4 graf-after--pre">7. Define a function that utilizes …rest syntax to accept an arbitrary number of arguments</h4><pre name="405e" id="405e" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">function restSum(...otherNums) {<br>    let sum = 0;<br>    console.log(otherNums);<br>    otherNums.forEach(function(num) {<br>        sum += num;<br>    });</code></pre><pre name="0f39" id="0f39" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    return sum;<br>}</code></pre><pre name="8d93" id="8d93" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">console.log(restSum(3, 5, 6)); <em class="markup--em markup--pre-em">// =&gt; 14</em><br>console.log(restSum(1, 2, 3, 4, 5, 6, 7, 8, 9)); <em class="markup--em markup--pre-em">// =&gt; 45</em><br>console.log(restSum(0)); <em class="markup--em markup--pre-em">// =&gt; 0</em></code></pre><h4 name="452e" id="452e" class="graf graf--h4 graf-after--pre">8. Use …spread syntax for Object literals and Array literals</h4><pre name="fe0d" id="fe0d" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">let numArray = [1, 2, 3];<br>let moreNums = [...numArray, 4, 5, 6]</code></pre><pre name="604f" id="604f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(moreNums);</code></pre><pre name="77db" id="77db" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">let shoe = {<br>    color: &quot;red&quot;,<br>    size: 10<br>};<br>let newShoe = {<br>    ...shoe,<br>    brand: &quot;Nike&quot;,<br>    size: 12<br>};<br>console.log(newShoe);<br>newShoe.color = &quot;black&quot;;<br>console.log(newShoe);</code></pre><pre name="eb8f" id="eb8f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(shoe);</code></pre><h4 name="78c5" id="78c5" class="graf graf--h4 graf-after--pre">9. Destructure an array to reference specific elements</h4><pre name="7bdf" id="7bdf" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">let arr = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;];</code></pre><pre name="6bd6" id="6bd6" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">let [first] = arr;<br>console.log(first);</code></pre><h4 name="5977" id="5977" class="graf graf--h4 graf-after--pre">10. Destructure an object to reference specific values</h4><pre name="f0ea" id="f0ea" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">let me = {<br>    name: &quot;Ian&quot;,<br>    instruments: [&#39;bass&#39;, &#39;synth&#39;, &#39;guitar&#39;],<br>    siblings: {<br>        brothers: [&#39;Alistair&#39;],<br>        sisters: [&#39;Meghan&#39;]<br>    }<br>}</code></pre><pre name="13b9" id="13b9" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">let {<br>    name,<br>    instruments: musical_instruments,<br>    siblings: {<br>        sisters<br>    }<br>} = me;</code></pre><pre name="f5da" id="f5da" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(name);<br>console.log(musical_instruments);<br>console.log(sisters);</code></pre><h4 name="42f0" id="42f0" class="graf graf--h4 graf-after--pre">11. Write a function that accepts a string as an argument and returns an object representing the count of each character in the array</h4><pre name="f94b" id="f94b" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">function charCount(inputString) {</code></pre><pre name="1a65" id="1a65" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    let res = inputString.split(&quot;&quot;).reduce(function(accum, el) {<br>        if (el in accum) {<br>            accum[el] = accum[el] + 1;<br>        } else {<br>            accum[el] = 1;<br>        }<br>        return accum;<br>    }, {})<br>    return res;</code></pre><pre name="88b0" id="88b0" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">}</code></pre><pre name="e56c" id="e56c" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(charCount(&#39;aaabbbeebbcdkjfalksdfjlkasdfasdfiiidkkdingds&#39;));</code></pre><h3 name="1b11" id="1b11" class="graf graf--h3 graf-after--pre">Review of Concepts</h3><h4 name="6f2e" id="6f2e" class="graf graf--h4 graf-after--h3">1. Identify the difference between const, let, and var declarations</h4><h4 name="a14d" id="a14d" class="graf graf--h4 graf-after--h4">2. Explain the difference between const, let, and var declarations</h4><pre name="6635" id="6635" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">var a = &quot;a&quot;;</code></pre><ul class="postList"><li name="2dba" id="2dba" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">var</code> is the historical keyword used for variable declaration.</li><li name="50d3" id="50d3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">var</code> declares variables in function scope, or global scope if not inside a function.</li><li name="4bc8" id="4bc8" class="graf graf--li graf-after--li">We consider <code class="markup--code markup--li-code">var</code> to be deprecated and it is never used in this course.</li></ul><pre name="1924" id="1924" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">let b = &quot;b&quot;;</code></pre><ul class="postList"><li name="8bab" id="8bab" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">let</code> is the keyword we use most often for variable declaration.</li><li name="0642" id="0642" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">let</code> declares variables in block scope.</li><li name="bf7b" id="bf7b" class="graf graf--li graf-after--li">variables declared with <code class="markup--code markup--li-code">let</code> are re-assignable.</li></ul><pre name="87f4" id="87f4" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">const c = &quot;c&quot;;</code></pre><ul class="postList"><li name="e199" id="e199" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">const</code> is a specialized form of <code class="markup--code markup--li-code">let</code> that can only be used to <strong class="markup--strong markup--li-strong">initialize</strong> a variable.</li><li name="4522" id="4522" class="graf graf--li graf-after--li">Except when it is declared, you cannot assign to a <code class="markup--code markup--li-code">const</code> variable.</li><li name="4e5a" id="4e5a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">const</code> scopes variables the same way that <code class="markup--code markup--li-code">let</code> does.</li></ul><h4 name="2ff5" id="2ff5" class="graf graf--h4 graf-after--li">3. Predict the evaluation of code that utilizes function scope, block scope, lexical scope, and scope chaining</h4><p name="45ea" id="45ea" class="graf graf--p graf-after--h4">Consider this <code class="markup--code markup--p-code">run</code> function, inside which <code class="markup--code markup--p-code">foo</code> and <code class="markup--code markup--p-code">bar</code> have <code class="markup--code markup--p-code">function scope</code> . <code class="markup--code markup--p-code">i</code> and <code class="markup--code markup--p-code">baz</code> are scoped to the block expression.</p><pre name="28c5" id="28c5" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em">// function and block scope in this example</em><br>function run() {<br>    var foo = &quot;Foo&quot;;<br>    let bar = &quot;Bar&quot;;</code></pre><pre name="d9a3" id="d9a3" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    console.log(foo, bar);</code></pre><pre name="ecd3" id="ecd3" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    {<br>        console.log(foo);<br>        let baz = &quot;Bazz&quot;;<br>        console.log(baz);<br>    }</code></pre><pre name="74a6" id="74a6" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">    console.log(baz); <em class="markup--em markup--pre-em">// ReferenceError</em><br>}</code></pre><pre name="8abe" id="8abe" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">run();</code></pre><p name="7b94" id="7b94" class="graf graf--p graf-after--pre">Notice that referencing <code class="markup--code markup--p-code">baz</code> from outside it&#39;s block results in JavaScript throwing a ReferenceError.</p><p name="df94" id="df94" class="graf graf--p graf-after--p">Consider this <code class="markup--code markup--p-code">run</code> function, inside of which <code class="markup--code markup--p-code">foo</code> has <code class="markup--code markup--p-code">function scope</code> .</p><pre name="0e28" id="0e28" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">function run() {<br>    console.log(foo); <em class="markup--em markup--pre-em">// undefined</em><br>    var foo = &quot;Foo&quot;;<br>    console.log(foo); <em class="markup--em markup--pre-em">// Foo</em><br>}</code></pre><pre name="1bc5" id="1bc5" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">run();</code></pre><p name="f3b4" id="f3b4" class="graf graf--p graf-after--pre">Consider this <code class="markup--code markup--p-code">func1</code> function and it&#39;s nested scopes.</p><pre name="8fc0" id="8fc0" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em">// global scope</em><br>function func1(arg1) {<br>    <em class="markup--em markup--pre-em">// func1 scope</em></code></pre><pre name="582e" id="582e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">    return function func2(arg2) {<br>        <em class="markup--em markup--pre-em">// func2 scope</em></code></pre><pre name="f27b" id="f27b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">        return function func3(arg3) {<br>            <em class="markup--em markup--pre-em">// func3 scope</em></code></pre><pre name="64ed" id="64ed" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">            console.log(arg1, arg2, arg3);<br>        }<br>    }<br>}</code></pre><h4 name="5068" id="5068" class="graf graf--h4 graf-after--pre">6. Implement a closure and explain how the closure effects scope</h4><pre name="bb56" id="bb56" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">const adder = (arg1) =&gt; {<br>    return (arg2) =&gt; {<br>        return arg1 + arg2;<br>    }<br>};</code></pre><pre name="4c8e" id="4c8e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">const func2 = adder(2);<br>const result = func2(2);<br>console.log(result); <em class="markup--em markup--pre-em">// =&gt; 4;</em></code></pre><h4 name="167b" id="167b" class="graf graf--h4 graf-after--pre">4. Define an arrow function</h4><pre name="069f" id="069f" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">const returnValue = (val) =&gt; val;</code></pre><p name="36d1" id="36d1" class="graf graf--p graf-after--pre">This simple construct will create a function that accepts <code class="markup--code markup--p-code">val</code> as a parameter, and returns <code class="markup--code markup--p-code">val</code> immediately. We do not need to type <code class="markup--code markup--p-code">return val</code> , because this is a single-line function.</p><p name="9a32" id="9a32" class="graf graf--p graf-after--p">Identically, we could write</p><pre name="44a4" id="44a4" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const returnValue = (val) =&gt; {<br>    return val;<br>};</code></pre><h4 name="8ef7" id="8ef7" class="graf graf--h4 graf-after--pre">5. Given an arrow function, deduce the value of <code class="markup--code markup--h4-code">this</code> without executing the code</h4><pre name="8105" id="8105" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">function fDAdder(arr) {<br>    console.log(this);</code></pre><pre name="073b" id="073b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    return arr.reduce((acc, ele) =&gt; {<br>        return acc + ele;<br>    });<br>};</code></pre><pre name="18e6" id="18e6" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">fDAdder([1, 2, 4, 6]);</code></pre><p name="598d" id="598d" class="graf graf--p graf-after--pre">If we use a function declaration style function, the <code class="markup--code markup--p-code">this</code> variable is set to the <code class="markup--code markup--p-code">global</code> object (i.e. <code class="markup--code markup--p-code">Object [global]</code> in Node. JS and <code class="markup--code markup--p-code">Window</code> in your browser).</p><pre name="35b5" id="35b5" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const adder = (arr) =&gt; {<br>    console.log(this);<br>    arr.reduce((acc, ele) =&gt; sum += ele);<br>};<br>adder([1, 2, 4, 6]);</code></pre><p name="cf86" id="cf86" class="graf graf--p graf-after--pre">In this example, we use a fat arrow style function. Note that when we declare a functions like this <code class="markup--code markup--p-code">this</code> becomes</p><h4 name="71c1" id="71c1" class="graf graf--h4 graf-after--p">7. Define a method that references this on an object literal</h4><pre name="c9ad" id="c9ad" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">const pokemon = {<br>    firstname: &#39;Pika&#39;,<br>    lastname: &#39;Chu&#39;,<br>    getPokeName: function() {<br>        const fullname = `${this.firstname} ${this.lastname}`;<br>        return fullname;<br>    }<br>};</code></pre><pre name="2c6b" id="2c6b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(pokemon.getPokeName());</code></pre><h4 name="2274" id="2274" class="graf graf--h4 graf-after--pre">8. Utilize the built in Function#bind on a callback to maintain the context of <code class="markup--code markup--h4-code">this</code></h4><pre name="5cdd" id="5cdd" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">const pokemon = {<br>    firstname: &#39;Pika&#39;,<br>    lastname: &#39;Chu&#39;,<br>    getPokeName: function() {<br>        const fullname = `${this.firstname} ${this.lastname}`;<br>        return fullname;<br>    }<br>};</code></pre><pre name="75e1" id="75e1" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const logPokemon = pokemon.getPokename.bind(pokemon);</code></pre><pre name="fef7" id="fef7" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">logPokemon(&#39;sushi&#39;, &#39;algorithms&#39;); <em class="markup--em markup--pre-em">// Pika Chu loves sushi and algorithms</em></code></pre><h4 name="4012" id="4012" class="graf graf--h4 graf-after--pre">9. Given a code snippet, identify what <code class="markup--code markup--h4-code">this</code> refers to</h4><pre name="03c4" id="03c4" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">function Person(name) {<br>    <em class="markup--em markup--pre-em">// this.name = name; </em><br>    <em class="markup--em markup--pre-em">// let that = this;</em></code></pre><pre name="8fe9" id="8fe9" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">    setTimeout(function() {<br>        <em class="markup--em markup--pre-em">// console.log(this); // =&gt; Window</em><br>        <em class="markup--em markup--pre-em">// console.log(that); // =&gt; [Function] =&gt; Person</em><br>        <em class="markup--em markup--pre-em">// this.sayName(); // =&gt; no method error</em><br>        that.sayName();<br>    }, 1000);<br>}</code></pre><pre name="d123" id="d123" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">Person.prototype.sayName = function() {<br>    console.log(this.name);<br>};</code></pre><pre name="67ab" id="67ab" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const jane = new Person(&quot;Jane&quot;);</code></pre><h3 name="d97f" id="d97f" class="graf graf--h3 graf-after--pre">Check Out My New Blog:</h3><div name="2449" id="2449" class="graf graf--mixtapeEmbed graf-after--h3 graf--trailing"><a href="https://bgoonz-blog.netlify.app/" data-href="https://bgoonz-blog.netlify.app/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://bgoonz-blog.netlify.app/"><strong class="markup--strong markup--mixtapeEmbed-strong">Stackbit Web-Dev-HubTheme</strong><br><em class="markup--em markup--mixtapeEmbed-em">Memoization, Tabulation, and Sorting Algorithms by Example Why is looking at runtime not a reliable method of…</em>bgoonz-blog.netlify.app</a><a href="https://bgoonz-blog.netlify.app/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a2f1abe4ed6a87b0b90d28e55f930d20" data-thumbnail-img-id="0*IRiK5qLqEzQx6waz" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*IRiK5qLqEzQx6waz);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bryanguner" class="p-author h-card">Bryan Guner</a> on <a href="https://medium.com/p/81c4d839b827"><time class="dt-published" datetime="2021-05-27T15:47:07.425Z">May 27, 2021</time></a>.</p><p><a href="https://medium.com/@bryanguner/fundamental-javascript-concepts-you-should-understand-81c4d839b827" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 10, 2021.</p></footer></article></body></html>