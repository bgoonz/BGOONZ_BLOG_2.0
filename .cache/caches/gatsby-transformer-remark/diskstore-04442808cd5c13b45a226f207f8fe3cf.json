{"expireTime":9007200908525415000,"key":"transformer-remark-markdown-html-4c9d49167f903ba0f27aa26a02ec2139--","val":"<h1>Classes</h1>\n<p>Classes are a template for creating objects. They encapsulate data with code to work on that data. Classes in JS are built on prototypes but also have some syntax and semantics that are not shared with ES5 class-like semantics.</p>\n<h2>Defining classes</h2>\n<p>Classes are in fact \"special functions\", and just as you can define <a href=\"operators/function\">function expressions</a> and <a href=\"statements/function\">function declarations</a>, the class syntax has two components: <a href=\"operators/class\">class expressions</a> and <a href=\"statements/class\">class declarations</a>.</p>\n<h3>Class declarations</h3>\n<p>One way to define a class is using a <strong>class declaration</strong>. To declare a class, you use the <code>class</code> keyword with the name of the class (\"Rectangle\" here).</p>\n<pre><code>class Rectangle {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n}\n</code></pre>\n<h4>Hoisting</h4>\n<p>An important difference between <strong>function declarations</strong> and <strong>class declarations</strong> is that function declarations are <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Hoisting\">hoisted</a> and class declarations are not. You first need to declare your class and then access it, otherwise code like the following will throw a <a href=\"global_objects/referenceerror\"><code>ReferenceError</code></a>:</p>\n<pre><code>const p = new Rectangle(); // ReferenceError\n\nclass Rectangle {}\n</code></pre>\n<h3>Class expressions</h3>\n<p>A <strong>class expression</strong> is another way to define a class. Class expressions can be named or unnamed. The name given to a named class expression is local to the class's body. (it can be retrieved through the class's (not an instance's) <a href=\"global_objects/function/name\"><code>name</code></a> property, though).</p>\n<pre><code>// unnamed\nlet Rectangle = class {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n};\nconsole.log(Rectangle.name);\n// output: \"Rectangle\"\n\n// named\nlet Rectangle = class Rectangle2 {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n};\nconsole.log(Rectangle.name);\n// output: \"Rectangle2\"\n</code></pre>\n<p><strong>Note:</strong> Class <strong>expressions</strong> are subject to the same hoisting restrictions as described in the <a href=\"#class_declarations\">Class declarations</a> section.</p>\n<h2>Class body and method definitions</h2>\n<p>The body of a class is the part that is in curly brackets <code>{}</code>. This is where you define class members, such as methods or constructor.</p>\n<h3>Strict mode</h3>\n<p>The body of a class is executed in <a href=\"strict_mode\">strict mode</a>, i.e., code written here is subject to stricter syntax for increased performance, some otherwise silent errors will be thrown, and certain keywords are reserved for future versions of ECMAScript.</p>\n<h3>Constructor</h3>\n<p>The <a href=\"classes/constructor\">constructor</a> method is a special method for creating and initializing an object created with a <code>class</code>. There can only be one special method with the name \"constructor\" in a class. A <a href=\"global_objects/syntaxerror\"><code>SyntaxError</code></a> will be thrown if the class contains more than one occurrence of a <code>constructor</code> method.</p>\n<p>A constructor can use the <code>super</code> keyword to call the constructor of the super class.</p>\n<h3>Prototype methods</h3>\n<p>See also <a href=\"functions/method_definitions\">method definitions</a>.</p>\n<pre><code>class Rectangle {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n  // Getter\n  get area() {\n    return this.calcArea();\n  }\n  // Method\n  calcArea() {\n    return this.height * this.width;\n  }\n}\n\nconst square = new Rectangle(10, 10);\n\nconsole.log(square.area); // 100\n</code></pre>\n<h3>Generator methods</h3>\n<p>See also <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\">Iterators and generators</a>.</p>\n<pre><code>class Polygon {\n  constructor(...sides) {\n    this.sides = sides;\n  }\n  // Method\n  *getSides() {\n    for(const side of this.sides){\n      yield side;\n    }\n  }\n}\n\nconst pentagon = new Polygon(1,2,3,4,5);\n\nconsole.log([...pentagon.getSides()]); // [1,2,3,4,5]\n</code></pre>\n<h3>Static methods and properties</h3>\n<p>The <a href=\"classes/static\">static</a> keyword defines a static method or property for a class. Static members (properties and methods) are called without <a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects#the_object_(class_instance)\">instantiating</a> their class and <strong>cannot</strong> be called through a class instance. Static methods are often used to create utility functions for an application, whereas static properties are useful for caches, fixed-configuration, or any other data you don't need to be replicated across instances.</p>\n<pre><code>class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  static displayName = \"Point\";\n  static distance(a, b) {\n    const dx = a.x - b.x;\n    const dy = a.y - b.y;\n\n    return Math.hypot(dx, dy);\n  }\n}\n\nconst p1 = new Point(5, 5);\nconst p2 = new Point(10, 10);\np1.displayName; // undefined\np1.distance;    // undefined\np2.displayName; // undefined\np2.distance;    // undefined\n\nconsole.log(Point.displayName);      // \"Point\"\nconsole.log(Point.distance(p1, p2)); // 7.0710678118654755\n</code></pre>\n<h3>Binding <code>this</code> with prototype and static methods</h3>\n<p>When a static or prototype method is called without a value for <a href=\"operators/this\"><code>this</code></a>, such as by assigning the method to a variable and then calling it, the <code>this</code> value will be <code>undefined</code> inside the method. This behavior will be the same even if the <a href=\"strict_mode\"><code>\"use strict\"</code></a> directive isn't present, because code within the <code>class</code> body's syntactic boundary is always executed in strict mode.</p>\n<pre><code>class Animal {\n  speak() {\n    return this;\n  }\n  static eat() {\n    return this;\n  }\n}\n\nlet obj = new Animal();\nobj.speak(); // the Animal object\nlet speak = obj.speak;\nspeak(); // undefined\n\nAnimal.eat() // class Animal\nlet eat = Animal.eat;\neat(); // undefined\n</code></pre>\n<p>If we rewrite the above using traditional function-based syntax in non-strict mode, then <code>this</code> method calls are automatically bound to the initial <code>this</code> value, which by default is the <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Global_object\">global object</a>. In strict mode, autobinding will not happen; the value of <code>this</code> remains as passed.</p>\n<pre><code>function Animal() { }\n\nAnimal.prototype.speak = function() {\n  return this;\n}\n\nAnimal.eat = function() {\n  return this;\n}\n\nlet obj = new Animal();\nlet speak = obj.speak;\nspeak(); // global object (in non-strict mode)\n\nlet eat = Animal.eat;\neat(); // global object (in non-strict mode)\n</code></pre>\n<h3>Instance properties</h3>\n<p>Instance properties must be defined inside of class methods:</p>\n<pre><code>class Rectangle {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n}\n</code></pre>\n<p>Static (class-side) data properties and prototype data properties must be defined outside of the ClassBody declaration:</p>\n<pre><code>Rectangle.staticWidth = 20;\nRectangle.prototype.prototypeWidth = 25;\n</code></pre>\n<h3>Field declarations</h3>\n<p><strong>Warning:</strong> Public and private field declarations are an <a href=\"https://github.com/tc39/proposal-class-fields\">experimental feature (stage 3)</a> proposed at <a href=\"https://tc39.es\">TC39</a>, the JavaScript standards committee. Support in browsers is limited, but the feature can be used through a build step with systems like <a href=\"https://babeljs.io/\">Babel</a>.</p>\n<h4>Public field declarations</h4>\n<p>With the JavaScript field declaration syntax, the above example can be written as:</p>\n<pre><code>class Rectangle {\n  height = 0;\n  width;\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n}\n</code></pre>\n<p>By declaring fields up-front, class definitions become more self-documenting, and the fields are always present.</p>\n<p>As seen above, the fields can be declared with or without a default value.</p>\n<p>See <a href=\"classes/public_class_fields\">public class fields</a> for more information.</p>\n<h4>Private field declarations</h4>\n<p>Using private fields, the definition can be refined as below.</p>\n<pre><code>class Rectangle {\n  #height = 0;\n  #width;\n  constructor(height, width) {\n    this.#height = height;\n    this.#width = width;\n  }\n}\n</code></pre>\n<p>It's an error to reference private fields from outside of the class; they can only be read or written within the class body. By defining things that are not visible outside of the class, you ensure that your classes' users can't depend on internals, which may change from version to version.</p>\n<p><strong>Note:</strong> Private fields can only be declared up-front in a field declaration.</p>\n<p>Private fields cannot be created later through assigning to them, the way that normal properties can.</p>\n<p>For more information, see <a href=\"classes/private_class_fields\">private class fields</a>.</p>\n<h2>Sub classing with <code>extends</code></h2>\n<p>The <a href=\"classes/extends\"><code>extends</code></a> keyword is used in <em>class declarations</em> or <em>class expressions</em> to create a class as a child of another class.</p>\n<pre><code>class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name) {\n    super(name); // call the super class constructor and pass in the name parameter\n  }\n\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nlet d = new Dog('Mitzie');\nd.speak(); // Mitzie barks.\n</code></pre>\n<p>If there is a constructor present in the subclass, it needs to first call super() before using \"this\".</p>\n<p>One may also extend traditional function-based \"classes\":</p>\n<pre><code>function Animal (name) {\n  this.name = name;\n}\n\nAnimal.prototype.speak = function () {\n  console.log(`${this.name} makes a noise.`);\n}\n\nclass Dog extends Animal {\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nlet d = new Dog('Mitzie');\nd.speak(); // Mitzie barks.\n\n// For similar methods, the child's method takes precedence over parent's method\n</code></pre>\n<p>Note that classes cannot extend regular (non-constructible) objects. If you want to inherit from a regular object, you can instead use <a href=\"global_objects/object/setprototypeof\"><code>Object.setPrototypeOf()</code></a>:</p>\n<pre><code>const Animal = {\n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n};\n\nclass Dog {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// If you do not do this you will get a TypeError when you invoke speak\nObject.setPrototypeOf(Dog.prototype, Animal);\n\nlet d = new Dog('Mitzie');\nd.speak(); // Mitzie makes a noise.\n</code></pre>\n<h2>Species</h2>\n<p>You might want to return <a href=\"global_objects/array\"><code>Array</code></a> objects in your derived array class <code>MyArray</code>. The species pattern lets you override default constructors.</p>\n<p>For example, when using methods such as <a href=\"global_objects/array/map\"><code>map()</code></a> that returns the default constructor, you want these methods to return a parent <code>Array</code> object, instead of the <code>MyArray</code> object. The <a href=\"global_objects/symbol/species\"><code>Symbol.species</code></a> symbol lets you do this:</p>\n<pre><code>class MyArray extends Array {\n  // Overwrite species to the parent Array constructor\n  static get [Symbol.species]() { return Array; }\n}\n\nlet a = new MyArray(1,2,3);\nlet mapped = a.map(x => x * x);\n\nconsole.log(mapped instanceof MyArray); // false\nconsole.log(mapped instanceof Array);   // true\n</code></pre>\n<h2>Super class calls with <code>super</code></h2>\n<p>The <a href=\"operators/super\"><code>super</code></a> keyword is used to call corresponding methods of super class. This is one advantage over prototype-based inheritance.</p>\n<pre><code>class Cat {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Lion extends Cat {\n  speak() {\n    super.speak();\n    console.log(`${this.name} roars.`);\n  }\n}\n\nlet l = new Lion('Fuzzy');\nl.speak();\n// Fuzzy makes a noise.\n// Fuzzy roars.\n</code></pre>\n<h2>Mix-ins</h2>\n<p>Abstract subclasses or <em>mix-ins</em> are templates for classes. An ECMAScript class can only have a single superclass, so multiple inheritance from tooling classes, for example, is not possible. The functionality must be provided by the superclass.</p>\n<p>A function with a superclass as input and a subclass extending that superclass as output can be used to implement mix-ins in ECMAScript:</p>\n<pre><code>let calculatorMixin = Base => class extends Base {\n  calc() { }\n};\n\nlet randomizerMixin = Base => class extends Base {\n  randomize() { }\n};\n</code></pre>\n<p>A class that uses these mix-ins can then be written like this:</p>\n<pre><code>class Foo { }\nclass Bar extends calculatorMixin(randomizerMixin(Foo)) { }\n</code></pre>\n<h2>Re-running a class definition</h2>\n<p>A class can't be redefined. Attempting to do so produces a <code>SyntaxError</code>.</p>\n<p>If you're experimenting with code in a web browser, such as the Firefox Web Console (<strong>Tools</strong> > <strong>Web Developer</strong> > <strong>Web Console</strong>) and you 'Run' a definition of a class with the same name twice, you'll get a <code>SyntaxError: redeclaration of let ClassName;</code>. (See further discussion of this issue in <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1428672\">bug 1428672</a>.) Doing something similar in Chrome Developer Tools gives you a message like <code>Uncaught SyntaxError: Identifier 'ClassName' has already been declared at &#x3C;anonymous>:1:1</code>.</p>"}