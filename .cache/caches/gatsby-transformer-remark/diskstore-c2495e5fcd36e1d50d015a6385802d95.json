{"expireTime":9007200903816792000,"key":"transformer-remark-markdown-html-8d7796d92f02620eb76546f64f656e1f--","val":"<h3>Introduction</h3>\n<p>The latest alpha release of React introduced a new concept called <em>Hooks</em>. Hooks were introduced to React to solve <a href=\"https://reactjs.org/docs/hooks-intro.html#classes-confuse-both-people-and-machines\">common problems</a>. However, they primarily serve as an alternative for classes. With Hooks, you can create functional components that use state and lifecycle methods.</p>\n<p>Hooks are currently available in React v16.7.0-alpha. There are no plans to remove classes. Hooks provide another way to write React.</p>\n<p>Given that Hooks are still new, many developers are looking to apply the concept in their existing React applications or new applications. In this post, you'll explore five ways to convert React class components to functional components using React Hooks.</p>\n<h2>Prerequisites</h2>\n<p>To complete this tutorial, you'll need:</p>\n<ul>\n<li>Familiarity with JavaScript. You can review the <a href=\"https://www.digitalocean.com/community/tutorial_series/how-to-code-in-javascript\">How To Code in JavaScript</a> series to learn more and get started.</li>\n<li>Familiarity with React. You can review our <a href=\"https://www.digitalocean.com/community/tutorial_series/how-to-code-in-react-js\">How To Code in React.js</a> series for guides to help you get started.</li>\n</ul>\n<p>No local development is required, but <a href=\"https://codesandbox.io/\">CodeSandbox</a> examples are provided for further experimentation.</p>\n<h2>Step 1 — Understanding a Class without State or Lifecycle Methods</h2>\n<p>Let's start with a React class that has neither state nor lifecycle components:</p>\n<p>ExampleClassComponent.js</p>\n<p>Here you have a typical React class, which lacks state or a lifecycle method. It alerts a name when a button is clicked.</p>\n<p>The functional equivalent of this class will look like this:</p>\n<p>ExampleFunctionalComponent.js</p>\n<p>Like the first example, this functional class behaves in a typical way.</p>\n<p>However, this example does not use Hooks or anything new yet. In these examples, you have no need for state or lifecycle.</p>\n<p>Let's take a look at class-based components with state and learn how to convert them to functional components using Hooks.</p>\n<h2>Step 2 — Adding Hooks to Classes with State</h2>\n<p>Let's consider a situation where you have a global name variable that you can update within the app from a text input field.</p>\n<p>In React, you handle cases like this by defining the name variable in a <code>state</code> object and calling <code>setState()</code> when we have a new value to update the <code>name</code> variable with:</p>\n<p>ExampleClassComponentWithState.js</p>\n<p>When a user types a name in the input field and clicks the <strong>Alert</strong> button, it pops up an alert with the name defined in state.</p>\n<p>You can convert this entire class into a functional React component using Hooks:</p>\n<p>ExampleFunctionalComponentWithState.js</p>\n<p>Here, you have introduced the <code>useState</code> Hook. It allows you to make use of state in React functional components. With the <code>useState()</code> Hook, you can use state in this functional component. It uses a similar syntax with a destructuring assignment for arrays.</p>\n<p>Consider this line:</p>\n<p>Here, <code>name</code> is the equivalent of <code>this.state</code> in a normal class component, and <code>setName</code> is the equivalent of <code>this.setState</code>.</p>\n<p>The initial value of the state in the <code>useState()</code> Hook comes from an argument. In other words, the <code>useState()</code> argument is the initial value of the state. In your case, you set it to <code>'John Doe'</code>. This means that the initial state of the name in state is <code>'John Doe'</code>.</p>\n<p>This code is an example of how you can convert a class-based React component with state to a functional component using Hooks.</p>\n<p>Let's explore other scenarios, including classes with multiple state properties.</p>\n<h2>Step 3 — Adding Hooks to Classes with Multiple State Properties</h2>\n<p>You have looked at how you might convert one state property with <code>useState</code>, but the same approach won't quite work when you have multiple state properties. If, for example, you had two or more input fields for <code>userName</code>, <code>firstName</code>, and <code>lastName</code>, then you would have a class-based component with three state properties:</p>\n<p>ExampleClassComponentWithMultipleStateProperties.js</p>\n<p>To convert this class to a functional component with Hooks, you will have to take a somewhat unconventional route. Using the <code>useState()</code> Hook, the above example can be written as:</p>\n<p>ExampleFunctionalComponentWithMultipleStateProperties.js</p>\n<p>Here's a <a href=\"https://codesandbox.io/s/ypjynxx16x\">CodeSandbox</a> for this example.</p>\n<p>This demonstrates how you can convert a class-based component with multiple state properties to a functional component using the <code>useState()</code> Hook.</p>\n<h2>Step 4 — Adding Hooks to a Class with State and <code>componentDidMount</code></h2>\n<p>Let's consider a class with <code>state</code> and <code>componentDidMount</code>. To demonstrate, you will look at a scenario where you set an initial state for the three input fields and have them all update to a different set of values after five seconds.</p>\n<p>To achieve this, you will declare an initial state value for the input fields and implement a <code>componentDidMount()</code> lifecycle method that will run after the initial render to update the state values:</p>\n<p>ExampleClassComponentWithStateAndComponentDidMount.js</p>\n<p>When the app runs, the input fields will have the initial values you've defined in the state object. These values will then update to the values you've defined inside the <code>componentDidMount()</code> method after five seconds.</p>\n<p>Next, you will convert this class to a functional component using the React <code>useState</code> and <code>useEffect</code> Hooks:</p>\n<p>ExampleFunctionalComponentWithStateAndComponentDidMount.js</p>\n<p>Here's a <a href=\"https://codesandbox.io/s/jzoz2n97my\">CodeSandbox</a> for this example.</p>\n<p>In terms of functionality, this component does exactly the same thing as the previous example. The only difference is that instead of using the conventional <code>state</code> object and <code>componentDidMount()</code> lifecycle method as you did in the class component, you used the <code>useState</code> and <code>useEffect</code> Hooks.</p>\n<h2>Step 5 — Adding Hooks to a Class with State, <code>componentDidMount</code>, and <code>componentDidUpdate</code></h2>\n<p>Next, let's look at a React class with state and two lifecycle methods: <code>componentDidMount</code> and <code>componentDidUpdate</code>. Most of the solutions up to this point have used the <code>useState</code> Hook. In this example, you will focus on the <code>useEffect</code> Hook.</p>\n<p>To best demonstrate how this works, let's modify your code to dynamically update the <code>&#x3C;h3></code> header on the page.</p>\n<p>Currently, the header says <code>This is a Class Component</code>. Now, you will define a <code>componentDidMount()</code> method to update the header to say <code>Welcome to React Hooks</code> after three seconds:</p>\n<p>ExampleClassComponentWithStateAndTwoLifecycleMethods.js</p>\n<p>When the app runs, it will start with the initial header <code>This is a Class Component</code> and change it to <code>Welcome to React Hooks</code> after three seconds. This is the classic <code>componentDidMount()</code> behavior since it runs after the <code>render</code> function is executed successfully.</p>\n<p>Let's add functionality to dynamically update the header from another input field so that the header gets updated with the new text while you type.</p>\n<p>To accomplish this, you will need to implement the <code>componentDidUpdate()</code> lifecycle method:</p>\n<p>ExampleClassComponent.js</p>\n<p>Here, you have <code>state</code>, <code>componentDidMount()</code>, and <code>componentDidUpdate()</code>. When you run the app, the <code>componentDidMount()</code> function will update the header to <code>Welcome to React Hooks</code> after three seconds. When you start typing in the header text input field, the <code>&#x3C;h3></code> text will update with the input text as defined in the <code>componentDidUpdate()</code> method.</p>\n<p>Next, you will convert this class to a functional component with the <code>useEffect()</code> Hook:</p>\n<p>ExampleFunctionalComponentWithStateAndTwoLifecycleMethods.js</p>\n<p>Check out this example on <a href=\"https://codesandbox.io/embed/ork242q3y\">CodeSandbox</a>.</p>\n<p>You achieved the same functionality with this component as you did previously by using the <code>useEffect()</code> Hook. You optimized the code as well, since you did not have to write separate code for the <code>componentDidMount()</code> and <code>componentDidUpdate()</code> functions. With the <code>useEffect()</code> Hook, you get the functionality of both. This is because <code>useEffect()</code> runs both after the initial render and after every subsequent update by default.</p>\n<h2>Step 6 — Converting <code>PureComponent</code> to <code>React memo</code></h2>\n<p><a href=\"https://reactjs.org/docs/react-api.html#reactpurecomponent\">React PureComponent</a> works in a similar manner to <a href=\"https://reactjs.org/docs/react-api.html#reactcomponent\">Component</a>. The major difference between them is that <code>React.Component</code> doesn't implement the <code>shouldComponentUpdate()</code> lifecycle method while <code>React.PureComponent</code> does.</p>\n<p>If you have an application where the <code>render()</code> function renders the same result given the same props and state, you can use <code>React.PureComponent</code> for a performance boost in some cases.</p>\n<p><code>React.memo()</code> works in a similar way. When your function component renders the same result given the same props, you can wrap it in a call to <code>React.memo()</code> to enhance performance. Using <code>PureComponent</code> and <code>React.memo()</code> gives React applications a considerable increase in performance as it reduces the number of render operations in the app.</p>\n<p>To understand what they both do, you will first look at code where a component renders every two seconds, whether or not there's a change in value or state:</p>\n<p>ExampleClassComponent.js</p>\n<p>When you run the app and check the logs, you will notice that it renders the component every two seconds, without any change in state or props. This is a situation that you can improve with both <code>PureComponent</code> and <code>React.memo()</code>.</p>\n<p><img src=\"https://assets.digitalocean.com/articles/five-ways-to-convert-react-class-components-to-functional-components-with-react-hooks/1.png\" alt=\"Console log output for multiple render operations\"></p>\n<p>Most of the time, you only want to re-render a component when there's been a change in state or props. Using the example above, you can improve it with <code>PureComponent</code> so that the component only re-renders when there's a change in state or props.</p>\n<p>You can accomplish this by importing <code>PureComponent</code> and extending it:</p>\n<p>ExamplePureComponent.js</p>\n<p>Now, if you run the app again, you only get the initial render. Nothing else happens after that. This is because you have <code>class App extends PureComponent {}</code> instead of <code>class App extends Component {}</code>.</p>\n<p><img src=\"https://assets.digitalocean.com/articles/five-ways-to-convert-react-class-components-to-functional-components-with-react-hooks/2.png\" alt=\"Console log output for a single render operation\"></p>\n<p>This solves the problem of components being re-rendered without respect to the current state. However, if you implement a state change within your <code>setState</code> method, you would run into another issue.</p>\n<p>For example, consider the following changes to <code>setState()</code>:</p>\n<p>Currently, <code>value</code> set to <code>1</code>:</p>\n<p>Let's consider a situation where <code>value</code> is set to <code>Math.random()</code>:</p>\n<p>In this scenario, the first example component would re-render each time the value updates to the next random number. However, <code>PureComponent</code> makes it possible to re-render components only when there has been a change in state or props.</p>\n<p>Now you can explore how to use <code>React.memo()</code> to achieve the same fix. To accomplish this, wrap the component with <code>React.memo()</code>:</p>\n<p>ExampleReactMemo.js</p>\n<p>Here's the <a href=\"https://codesandbox.io/s/100zmv7ljj\">CodeSandbox</a> for this example.</p>\n<p>This achieves the same result as using <code>PureComponent</code>. The component only renders after the initial render and does not re-render again until there is a change in state or props.</p>\n<h2>Conclusion</h2>\n<p>In this tutorial, you have explored a few approaches to covert an existing class-based component to a functional component using React Hooks.</p>\n<p>You have also looked at a special case of converting a React <code>PureComponent</code> class to <code>React.memo()</code>.</p>\n<p>To use Hooks in your applications, be sure to update your version of React to the supported version:</p>"}