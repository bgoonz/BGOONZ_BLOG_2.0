{
    "expireTime": 9007200881511493000,
    "key": "transformer-remark-markdown-html-ast-f8c355fc3056984d6d0a1508d797a154--",
    "val": {
        "type": "root",
        "children": [
            {
                "type": "raw",
                "value": "<div class=\"note\">\n  <strong>Note:</strong> These are the gatsby plugins that power the file system of this website! <strong>See more in the Docs</strong> section.\n</div>",
                "position": { "start": { "line": 2, "column": 1, "offset": 1 }, "end": { "line": 4, "column": 7, "offset": 171 } }
            },
            { "type": "text", "value": "\n" },
            {
                "type": "element",
                "tagName": "h3",
                "properties": {},
                "children": [
                    {
                        "type": "text",
                        "value": "Code:",
                        "position": { "start": { "line": 6, "column": 5, "offset": 177 }, "end": { "line": 6, "column": 10, "offset": 182 } }
                    }
                ],
                "position": { "start": { "line": 6, "column": 1, "offset": 173 }, "end": { "line": 6, "column": 10, "offset": 182 } }
            },
            { "type": "text", "value": "\n" },
            {
                "type": "element",
                "tagName": "blockquote",
                "properties": {},
                "children": [
                    { "type": "text", "value": "\n" },
                    {
                        "type": "element",
                        "tagName": "p",
                        "properties": {},
                        "children": [
                            {
                                "type": "text",
                                "value": "Gatsby Source File System",
                                "position": { "start": { "line": 8, "column": 3, "offset": 186 }, "end": { "line": 8, "column": 28, "offset": 211 } }
                            }
                        ],
                        "position": { "start": { "line": 8, "column": 3, "offset": 186 }, "end": { "line": 8, "column": 28, "offset": 211 } }
                    },
                    { "type": "text", "value": "\n" }
                ],
                "position": { "start": { "line": 8, "column": 1, "offset": 184 }, "end": { "line": 8, "column": 28, "offset": 211 } }
            },
            { "type": "text", "value": "\n" },
            {
                "type": "element",
                "tagName": "pre",
                "properties": {},
                "children": [
                    {
                        "type": "element",
                        "tagName": "code",
                        "properties": {},
                        "children": [
                            {
                                "type": "text",
                                "value": "js\nconst path = require('path');\nconst fs = require('fs');\nconst { createFilePath } = require('gatsby-source-filesystem');\nconst _ = require('lodash');\n\nfunction findFileNode({ node, getNode }) {\n    let fileNode = node;\n    let ids = [fileNode.id];\n\n    while (fileNode && fileNode.internal.type !== `File` && fileNode.parent) {\n        fileNode = getNode(fileNode.parent);\n\n        if (!fileNode) {\n            break;\n        }\n\n        if (_.includes(ids, fileNode.id)) {\n            console.log(`found cyclic reference between nodes`);\n            break;\n        }\n\n        ids.push(fileNode.id);\n    }\n\n    if (!fileNode || fileNode.internal.type !== `File`) {\n        console.log('did not find ancestor File node');\n        return null;\n    }\n\n    return fileNode;\n}\n\nexports.onCreateNode = ({ node, getNode, actions }, options) => {\n    const { createNodeField } = actions;\n\n    if (node.internal.type === 'MarkdownRemark') {\n        let fileNode = findFileNode({ node, getNode });\n        if (!fileNode) {\n            throw new Error('could not find parent File node for MarkdownRemark node: ' + node);\n        }\n\n        let url;\n        if (node.frontmatter.url) {\n            url = node.frontmatter.url;\n        } else if (_.get(options, 'uglyUrls', false)) {\n            url = path.join(fileNode.relativeDirectory, fileNode.name + '.html');\n        } else {\n            url = createFilePath({ node, getNode });\n        }\n\n        createNodeField({ node, name: 'url', value: url });\n        createNodeField({\n            node,\n            name: 'absolutePath',\n            value: fileNode.absolutePath\n        });\n        createNodeField({\n            node,\n            name: 'relativePath',\n            value: fileNode.relativePath\n        });\n        createNodeField({ node, name: 'absoluteDir', value: fileNode.dir });\n        createNodeField({\n            node,\n            name: 'relativeDir',\n            value: fileNode.relativeDirectory\n        });\n        createNodeField({ node, name: 'base', value: fileNode.base });\n        createNodeField({ node, name: 'ext', value: fileNode.ext });\n        createNodeField({ node, name: 'name', value: fileNode.name });\n    }\n};\n\nexports.createPages = ({ graphql, getNode, actions, getNodesByType }) => {\n    const { createPage, deletePage } = actions;\n\n    // Use GraphQL to bring only the \"id\" and \"html\" (added by gatsby-transformer-remark)\n    // properties of the MarkdownRemark nodes. Don't bring additional fields\n    // such as \"relativePath\". Otherwise, Gatsby's GraphQL resolvers might infer\n    // types these fields as File and change their structure. For example, the\n    // \"html\" attribute exists only on a GraphQL node, but does not exist on the\n    // underlying node.\n    return graphql(`\n        {\n            allMarkdownRemark {\n                edges {\n                    node {\n                        id\n                        html\n                    }\n                }\n            }\n        }\n    `).then((result) => {\n        if (result.errors) {\n            return Promise.reject(result.errors);\n        }\n\n        const nodes = result.data.allMarkdownRemark.edges.map(({ node }) => node);\n        const siteNode = getNode('Site');\n        const siteDataNode = getNode('SiteData');\n        const sitePageNodes = getNodesByType('SitePage');\n        const sitePageNodesByPath = _.keyBy(sitePageNodes, 'path');\n        const siteData = _.get(siteDataNode, 'data', {});\n\n        const pages = nodes.map((graphQLNode) => {\n            // Use the node id to get the underlying node. It is not exactly the\n            // same node returned by GraphQL, because GraphQL resolvers might\n            // transform node fields.\n            const node = getNode(graphQLNode.id);\n            return {\n                url: node.fields.url,\n                relativePath: node.fields.relativePath,\n                relativeDir: node.fields.relativeDir,\n                base: node.fields.base,\n                name: node.fields.name,\n                frontmatter: node.frontmatter,\n                html: graphQLNode.html\n            };\n        });\n\n        nodes.forEach((graphQLNode) => {\n            const node = getNode(graphQLNode.id);\n            const url = node.fields.url;\n\n            const template = node.frontmatter.template;\n            if (!template) {\n                console.error(`Error: undefined template for ${url}`);\n                return;\n            }\n\n            const component = path.resolve(`./src/templates/${template}.js`);\n            if (!fs.existsSync(component)) {\n                console.error(`Error: component \"src/templates/${template}.js\" missing for ${url}`);\n                return;\n            }\n\n            const existingPageNode = _.get(sitePageNodesByPath, url);\n\n            const page = {\n                path: url,\n                component: component,\n                context: {\n                    url: url,\n                    relativePath: node.fields.relativePath,\n                    relativeDir: node.fields.relativeDir,\n                    base: node.fields.base,\n                    name: node.fields.name,\n                    frontmatter: node.frontmatter,\n                    html: graphQLNode.html,\n                    pages: pages,\n                    site: {\n                        siteMetadata: _.get(siteData, 'site-metadata', {}),\n                        pathPrefix: siteNode.pathPrefix,\n                        data: _.omit(siteData, 'site-metadata')\n                    }\n                }\n            };\n\n            if (existingPageNode && !_.get(page, 'context.menus')) {\n                page.context.menus = _.get(existingPageNode, 'context.menus');\n            }\n\n            createPage(page);\n        });\n    });\n};\n\n```\n</pre>\n"
                            }
                        ],
                        "position": { "start": { "line": 10, "column": 1, "offset": 213 }, "end": { "line": 180, "column": 11, "offset": 6575 } }
                    }
                ],
                "position": { "start": { "line": 10, "column": 1, "offset": 213 }, "end": { "line": 180, "column": 11, "offset": 6575 } }
            },
            { "type": "text", "value": "\n" },
            {
                "type": "element",
                "tagName": "h5",
                "properties": {},
                "children": [
                    {
                        "type": "text",
                        "value": "Gatsby Source Data",
                        "position": { "start": { "line": 182, "column": 7, "offset": 6583 }, "end": { "line": 182, "column": 25, "offset": 6601 } }
                    }
                ],
                "position": { "start": { "line": 182, "column": 1, "offset": 6577 }, "end": { "line": 182, "column": 25, "offset": 6601 } }
            },
            { "type": "text", "value": "\n" },
            {
                "type": "element",
                "tagName": "pre",
                "properties": {},
                "children": [
                    {
                        "type": "element",
                        "tagName": "code",
                        "properties": {},
                        "children": [{ "type": "text", "value": "<pre>\n```javascript\n" }],
                        "position": { "start": { "line": 184, "column": 1, "offset": 6603 }, "end": { "line": 189, "column": 5, "offset": 6634 } }
                    }
                ],
                "position": { "start": { "line": 184, "column": 1, "offset": 6603 }, "end": { "line": 189, "column": 5, "offset": 6634 } }
            },
            { "type": "text", "value": "\n" },
            {
                "type": "element",
                "tagName": "pre",
                "properties": {},
                "children": [
                    {
                        "type": "element",
                        "tagName": "code",
                        "properties": { "className": ["language-javascript"] },
                        "children": [
                            {
                                "type": "text",
                                "value": "const path = require('path');\nconst yaml = require('js-yaml');\nconst fse = require('fs-extra');\nconst chokidar = require('chokidar');\nconst _ = require('lodash');\n\nconst metadataFileName = 'site-metadata.json';\n\nconst parsers = {\n    yaml: (data) => yaml.safeLoad(data, { schema: yaml.JSON_SCHEMA }),\n    json: (data) => JSON.parse(data)\n};\n\nconst supportedExtensions = {\n    yaml: parsers.yaml,\n    yml: parsers.yaml,\n    json: parsers.json\n};\n\nexports.sourceNodes = (props, pluginOptions = {}) => {\n    const createContentDigest = props.createContentDigest;\n    const { createNode } = props.actions;\n    const reporter = props.reporter;\n\n    if (!_.get(pluginOptions, 'path')) {\n        pluginOptions.path = 'src/data';\n    }\n\n    if (!path.isAbsolute(pluginOptions.path)) {\n        pluginOptions.path = path.resolve(process.cwd(), pluginOptions.path);\n    }\n\n    reporter.info(`[gatsby-source-data] setup file watcher and create site data`);\n\n    const dataPath = pluginOptions.path;\n    const createSiteDataFromFilesPartial = _.partial(createSiteDataFromFiles, {\n        dataPath,\n        createNode,\n        createContentDigest,\n        reporter\n    });\n    const watcher = chokidar.watch([dataPath, metadataFileName], {\n        cwd: '.',\n        ignoreInitial: true\n    });\n    watcher.on('add', createSiteDataFromFilesPartial);\n    watcher.on('change', createSiteDataFromFilesPartial);\n    watcher.on('unlink', createSiteDataFromFilesPartial);\n\n    return createSiteDataFromFiles({ dataPath, createNode, createContentDigest, reporter }, null);\n};\n\nasync function createSiteDataFromFiles({ dataPath, createNode, createContentDigest, reporter }, changedFile) {\n    reporter.info(`[gatsby-source-data] create site data from files, updated path: ${changedFile}`);\n    let dataFiles = [];\n\n    const dataPathExists = await fse.pathExists(dataPath);\n    if (dataPathExists) {\n        dataFiles = await readDirRecursively(dataPath);\n    }\n\n    const metadataPath = path.resolve(metadataFileName);\n    const metadataExists = await fse.pathExists(metadataPath);\n    if (metadataExists) {\n        dataFiles.push(metadataFileName);\n    }\n\n    const sortedDataFiles = dataFiles.slice().sort();\n    const data = await convertDataFilesToJSON(sortedDataFiles, dataPath, reporter);\n\n    createNode({\n        id: 'SiteData',\n        parent: null,\n        children: [],\n        data: data,\n        internal: {\n            type: 'SiteData',\n            contentDigest: createContentDigest(JSON.stringify(data)),\n            description: `Site data from ${path.relative(process.cwd(), dataPath)}`\n        }\n    });\n}\n\nasync function readDirRecursively(dir, options) {\n    const rootDir = _.get(options, 'rootDir', dir);\n    const files = await fse.readdir(dir);\n    const promises = _.map(files, async (file) => {\n        const filePath = path.join(dir, file);\n        const stats = await fse.stat(filePath);\n        if (stats.isDirectory()) {\n            return readDirRecursively(filePath, { rootDir });\n        } else if (stats.isFile()) {\n            return path.relative(rootDir, filePath);\n        } else {\n            return null;\n        }\n    });\n    const recFiles = await Promise.all(promises);\n    return _.chain(recFiles).compact().flatten().value();\n}\n\nfunction convertDataFilesToJSON(dataFiles, dataDirPath, reporter) {\n    let promises = _.map(dataFiles, (filePath) => {\n        const pathObject = path.parse(filePath);\n        const absFilePath = pathObject.base === metadataFileName ? metadataFileName : path.join(dataDirPath, filePath);\n        const relPath = pathObject.base === metadataFileName ? metadataFileName : filePath;\n        const relDir = pathObject.base === metadataFileName ? '' : pathObject.dir;\n        const ext = pathObject.ext.substring(1);\n        if (!_.has(supportedExtensions, ext)) {\n            return null;\n        }\n        return fse.readFile(absFilePath).then((data) => {\n            const propPath = _.compact(relDir.split(path.sep).concat(pathObject.name));\n            const res = {};\n            try {\n                const parsedData = supportedExtensions[ext](data);\n                _.set(res, propPath, parsedData);\n            } catch (err) {\n                reporter.warn(`[gatsby-source-data] could not parse file: ${relPath}`);\n            }\n            return res;\n        });\n    });\n    return Promise.all(promises).then((results) => {\n        return _.reduce(results, (data, res) => _.merge(data, res), {});\n    });\n}\n"
                            }
                        ],
                        "position": { "start": { "line": 191, "column": 1, "offset": 6636 }, "end": { "line": 319, "column": 4, "offset": 11121 } }
                    }
                ],
                "position": { "start": { "line": 191, "column": 1, "offset": 6636 }, "end": { "line": 319, "column": 4, "offset": 11121 } }
            },
            { "type": "text", "value": "\n" },
            {
                "type": "element",
                "tagName": "pre",
                "properties": {},
                "children": [
                    {
                        "type": "element",
                        "tagName": "code",
                        "properties": { "className": ["language-javascript"] },
                        "children": [{ "type": "text", "value": "</pre>\n" }],
                        "position": { "start": { "line": 321, "column": 1, "offset": 11123 }, "end": { "line": 323, "column": 4, "offset": 11147 } }
                    }
                ],
                "position": { "start": { "line": 321, "column": 1, "offset": 11123 }, "end": { "line": 323, "column": 4, "offset": 11147 } }
            }
        ],
        "position": { "start": { "line": 1, "column": 1, "offset": 0 }, "end": { "line": 324, "column": 1, "offset": 11148 } }
    }
}
