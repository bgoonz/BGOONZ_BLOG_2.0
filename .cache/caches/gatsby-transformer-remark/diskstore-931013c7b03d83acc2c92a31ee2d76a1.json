{"expireTime":9007200911206587000,"key":"transformer-remark-markdown-html-c3f7f934f2f600f41b26ebe9ffac5f8e-gatsby-remark-prismjs-","val":"<h2>JS Fat Arrow Functions</h2>\n<p>Classical JavaScript function syntax doesn't provide for any flexibility, be that a 1 statement function or an unfortunate multi-page function. Every time you need a function you have to type out the dreaded <code class=\"language-text\">function () {}</code>. More concise function syntax was one of the many reasons why <a href=\"http://coffeescript.org/\">CoffeeScript</a> gained so much momentum back in the day. This is especially pronounced in the case of tiny callback functions. Lets look at a Promise chain:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getVerifiedToken(selector) {\n  return getUsers(selector)\n    .then(function (users) { return users[0]; })\n    .then(verifyUser)\n    .then(function (user, verifiedToken) { return verifiedToken; })\n    .catch(function (err) { log(err.stack); });\n}</code></pre></div>\n<p>Above is more or less plausible piece of code written using classical JavaScript <code class=\"language-text\">function</code> syntax. Here is what the same code could look like rewritten using the arrow syntax:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getVerifiedToken(selector) {\n  return getUsers(selector)\n    .then(users => users[0])\n    .then(verifyUser)\n    .then((user, verifiedToken) => verifiedToken)\n    .catch(err => log(err.stack));\n}</code></pre></div>\n<p>A few important things to notice here:</p>\n<ol>\n<li>We've lost <code class=\"language-text\">function</code> and <code class=\"language-text\">{}</code> because all of our callback functions are one liners.</li>\n<li>We've lost <code class=\"language-text\">()</code> around the argument list when there's just one argument (rest arguments are an exception, eg <code class=\"language-text\">(...args) => ...</code>)</li>\n<li>We've lost the <code class=\"language-text\">return</code> keyword because when omitting <code class=\"language-text\">{}</code>, single line arrow functions perform an implicit return (these functions are often referred to as lambda functions in other languages).</li>\n</ol>\n<p>It's important to reinforce the last point. Implicit return only happens for single statement arrow functions. When arrow function is declared with <code class=\"language-text\">{}</code>, even if it's a single statement, implicit return does not happen:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const getVerifiedToken = selector => {\n  return getUsers()\n    .then(users => users[0])\n    .then(verifyUser)\n    .then((user, verifiedToken) => verifiedToken)\n    .catch(err => log(err.stack));\n}</code></pre></div>\n<p>Here's the really fun bit. Because our function has only one statement, we can still get rid of the <code class=\"language-text\">{}</code> and it will look almost exactly like <a href=\"http://coffeescript.org/\">CoffeeScript</a> syntax:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const getVerifiedToken = selector =>\n  getUsers()\n    .then(users => users[0])\n    .then(verifyUser)\n    .then((user, verifiedToken) => verifiedToken)\n    .catch(err => log(err.stack));</code></pre></div>\n<p>Yep, the example above is completely valid ES2015 syntax (I was also surprised that it <a href=\"http://babeljs.io/repl/#?\">compiles fine</a>). When we talk about single statement arrow functions, it doesn't mean the statement can't be spread out to multiple lines for better comprehension.</p>\n<p>There's one caveat, however, with omitting <code class=\"language-text\">{}</code> from arrow functions -- how do you return an empty object, eg <code class=\"language-text\">{}</code>?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const emptyObject = () => {};\nemptyObject(); // ?</code></pre></div>\n<p>Unfortunately there's no way to distinguish between empty block <code class=\"language-text\">{}</code> and an object <code class=\"language-text\">{}</code>. Because of that <code class=\"language-text\">emptyObject()</code> evaluates to <code class=\"language-text\">undefined</code> and <code class=\"language-text\">{}</code> interpreted as empty block. To return an empty object from fat arrow functions you have to surround it with brackets like so <code class=\"language-text\">({})</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const emptyObject = () => ({});\nemptyObject(); // {}</code></pre></div>\n<p>Here's all of the above together:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function () { return 1; }\n() => { return 1; }\n() => 1\n\nfunction (a) { return a * 2; }\n(a) => { return a * 2; }\n(a) => a * 2\na => a * 2\n\nfunction (a, b) { return a * b; }\n(a, b) => { return a * b; }\n(a, b) => a * b\n\nfunction () { return arguments[0]; }\n(...args) => args[0]\n\n() => {} // undefined\n() => ({}) // {}</code></pre></div>\n<h2>Lexical <code class=\"language-text\">this</code></h2>\n<p>The story of clobbering <code class=\"language-text\">this</code> in JavaScript is a really old one. Each <code class=\"language-text\">function</code> in JavaScript defines its own <code class=\"language-text\">this</code> context, which is as easy to get around as it is annoying. The example below tries to display a clock that updates every second using jQuery:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$('.current-time').each(function () {\n  setInterval(function () {\n    $(this).text(Date.now());\n  }, 1000);\n});</code></pre></div>\n<p>When attempting to reference the DOM element <code class=\"language-text\">this</code> set by <code class=\"language-text\">each</code> in the <code class=\"language-text\">setInterval</code> callback, we unfortunately get a brand new <code class=\"language-text\">this</code> that belongs to the callback itself. A common way around this is to declare <code class=\"language-text\">that</code> or <code class=\"language-text\">self</code> variable:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$('.current-time').each(function () {\n  var self = this;\n\n  setInterval(function () {\n    $(self).text(Date.now());\n  }, 1000);\n});</code></pre></div>\n<p>The fat arrow functions allow you to solve this problem because they don't introduce their own <code class=\"language-text\">this</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$('.current-time').each(function () {\n  setInterval(() => $(this).text(Date.now()), 1000);\n});</code></pre></div>\n<h2>What about arguments?</h2>\n<p>One of the caveats with arrow functions is that they also don't have their own <code class=\"language-text\">arguments</code> variable like regular functions:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function log(msg) {\n  const print = () => console.log(arguments[0]);\n  print(`LOG: ${msg}`);\n}\n\nlog('hello'); // hello</code></pre></div>\n<p>To reiterate, fat arrow functions don't have their own <code class=\"language-text\">this</code> and <code class=\"language-text\">arguments</code>. Having said that, you can still get all arguments passed into the arrow functions using rest parameters (also known as spread operator):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function log(msg) {\n  const print = (...args) => console.log(args[0]);\n  print(`LOG: ${msg}`);\n}\n\nlog('hello'); // LOG: hello</code></pre></div>\n<h2>What about yield?</h2>\n<p>Fat arrow functions can't be used as generators. That's it -- no exceptions, no caveats and no workarounds.</p>\n<h2>Bottom Line</h2>\n<p>Fat arrow functions are one of my favorite additions to JavaScript. It might be very tempting to just start using <code class=\"language-text\">=></code> instead of <code class=\"language-text\">function</code> everywhere. I've seen whole libraries written just using <code class=\"language-text\">=></code> and I don't think it's the right thing to do because of the special features that <code class=\"language-text\">=></code> introduces. I recommend using arrow functions only in places where you explicitly want to use the new features:</p>\n<ul>\n<li>Single statement functions that immediately return (lambdas)</li>\n<li>Functions that need to work with parent scope <code class=\"language-text\">this</code></li>\n</ul>"}