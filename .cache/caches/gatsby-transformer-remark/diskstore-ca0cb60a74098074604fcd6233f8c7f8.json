{"expireTime":9007200908525415000,"key":"transformer-remark-markdown-html-2686f12aa36e9603630333defd8d4037--","val":"<h1>What is THIS</h1>\n<h1>What is <code>this</code>?</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\"><strong><code>this</code></strong></a> is a special \"variable\" which implicitly exists in every\nfunction. It can be thought of being similar to Java's <code>this</code> and Python's\n<code>self</code>, but it's much more flexible than that.</p>\n<div class=\"callout warning\">\n<p><strong>Important</strong>: The value of <code>this</code> is determined when the\nfunction is <strong>called</strong>, not when the function is\n<em>defined</em>.</p>\n</div>\n<p>Given the following function:</p>\n<hr>\n<pre><code class=\"language-js\">function foo() {\n    console.log(this);\n}\n</code></pre>\n<p>these would be the values of <code>this</code> if called in those specific ways:</p>\n<pre><code class=\"language-js\">// \"normal call\": global object / window in browsers\n//                undefined in strict mode\nfoo();\n\n// as object \"method\": to the object\nvar obj = { method: foo };\nobj.method();\n\n// via .call / .apply: To the value passed as first argument\nfoo.call(bar);\n</code></pre>\n<h2>What is the this keyword</h2>\n<p>In general, the <code>this</code> references the object of which the function is a property. In other words, the <code>this</code> references the object that is currently calling the function.</p>\n<p>Suppose you have an object called <code>counter</code> that has a method <code>next()</code>. When you call the <code>next()</code> method, you can access the <code>this</code> object.</p>\n<pre><code class=\"language-js\">let counter = {\n  count: 0,\n  next: function () {\n    return ++this.count;\n  },\n};\n\ncounter.next();Code language: JavaScript (javascript)\n</code></pre>\n<p>Inside the <code>next()</code> function, the <code>this</code> references the <code>counter</code> object. See the following method call:</p>\n<pre><code class=\"language-js\">counter.next();Code language: CSS (css)\n</code></pre>\n<p>The <code>next()</code> is a function that is the property of the <code>counter</code> object. Therefore, inside the <code>next()</code> function, the <code>this</code> references the <code>counter</code> object.</p>\n<h2>Global context</h2>\n<p>In the global context, the <code>this</code> references the <a href=\"https://www.javascripttutorial.net/es-next/javascript-globalthis/\">global object</a>, which is the <code>window</code> object on the web browser or <code>global</code> object on Node.js.</p>\n<p>This behavior is consistent in both strict and non-strict modes. Here's the output on the web browser:</p>\n<pre><code class=\"language-js\">console.log(this === window); // trueCode language: JavaScript (javascript)\n</code></pre>\n<p>If you assign a property to <code>this</code> object in the global context, JavaScript will add the property to the global object as shown in the following example:</p>\n<pre><code class=\"language-js\">this.color= 'Red';\nconsole.log(window.color); // 'Red'Code language: JavaScript (javascript)\n</code></pre>\n<h2>Function context</h2>\n<p>In JavaScript, you can call a <a href=\"https://www.javascripttutorial.net/javascript-function/\">function</a> in the following ways:</p>\n<ul>\n<li>Function invocation</li>\n<li>Method invocation</li>\n<li>Constructor invocation</li>\n<li>Indirect invocation</li>\n</ul>\n<p>Each function invocation defines its own context. Therefore, the <code>this</code> behaves differently.</p>\n<h3>1) Simple function invocation</h3>\n<p>In the non-strict mode, the <code>this</code> references the global object when the function is called as follows:</p>\n<hr>\n<pre><code class=\"language-js\">function show() {\n   console.log(this === window); // true\n}\n\nshow();Code language: JavaScript (javascript)\n</code></pre>\n<p>When you call the <code>show()</code> function, the <code>this</code> references the <a href=\"https://www.javascripttutorial.net/es-next/javascript-globalthis/\">global object</a>, which is the <code>window</code> on the web browser and <code>global</code> on Node.js.</p>\n<p>Calling the <code>show()</code> function is the same as:</p>\n<pre><code class=\"language-js\">window.show();Code language: JavaScript (javascript)\n</code></pre>\n<p>In the strict mode, JavaScript sets the <code>this</code> inside a function to <code>undefined</code>. For example:</p>\n<pre><code class=\"language-js\">\"use strict\";\n\nfunction show() {\n    console.log(this === undefined);\n}\n\nshow();Code language: JavaScript (javascript)\n</code></pre>\n<p>To enable the strict mode, you use the directive <code>\"use strict\"</code> at the beginning of the JavaScript file. If you want to apply the strict mode to a specific function only, you place it at the top of the function body.</p>\n<p>Note that the strict mode has been available since ECMAScript 5.1. The <code>strict</code> mode applies to both function and nested functions. For example:</p>\n<hr>\n<pre><code class=\"language-js\">function show() {\n    \"use strict\";\n    console.log(this === undefined); // true\n\n    function display() {\n        console.log(this === undefined); // true\n    }\n    display();\n}\n\nshow();Code language: JavaScript (javascript)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"language-js\">true\ntrueCode language: JavaScript (javascript)\n</code></pre>\n<p>In the <code>display()</code> inner function, the <code>this</code> also set to <code>undefined</code> as shown in the console.</p>\n<h3>2) Method invocation</h3>\n<p>When you call a method of an object, JavaScript sets <code>this</code> to the object that owns the method. See the following <code>car</code> object:</p>\n<pre><code class=\"language-js\">let car = {\n    brand: 'Honda',\n    getBrand: function () {\n        return this.brand;\n    }\n}\n\nconsole.log(car.getBrand()); // HondaCode language: JavaScript (javascript)\n</code></pre>\n<p>In this example, the <code>this</code> object in the <code>getBrand()</code> method references the <code>car</code> object.</p>\n<p>Since a method is a property of an object which is a value, you can store it in a variable.</p>\n<pre><code class=\"language-js\">let brand = car.getBrand;Code language: JavaScript (javascript)\n</code></pre>\n<p>And then call the method via the variable</p>\n<pre><code class=\"language-js\">console.log(brand()); // undefinedCode language: JavaScript (javascript)\n</code></pre>\n<p>You get <code>undefined</code> instead of <code>\"Honda\"</code> because when you call a method without specifying its object, JavaScript sets <code>this</code> to the global object in non-strict mode and <code>undefined</code> in the strict mode.</p>\n<p>To fix this issue, you use the <code>[bind()](https://www.javascripttutorial.net/javascript-bind/)</code> method of the <code>Function.prototype</code> object. The <code>bind()</code> method creates a new function whose the <code>this</code> keyword is set to a specified value.</p>\n<pre><code class=\"language-js\">let brand = car.getBrand.bind(car);\nconsole.log(brand()); // Honda\nCode language: JavaScript (javascript)\n</code></pre>\n<p>In this example, when you call the <code>brand()</code> method, the <code>this</code> keyword is bound to the <code>car</code> object. For example:</p>\n<pre><code class=\"language-js\">let car = {\n    brand: 'Honda',\n    getBrand: function () {\n        return this.brand;\n    }\n}\n\nlet bike = {\n    brand: 'Harley Davidson'\n}\n\nlet brand = car.getBrand.bind(bike);\nconsole.log(brand());Code language: JavaScript (javascript)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"language-js\">Harley Davidson\n</code></pre>\n<p>In this example, the <code>bind()</code> method sets the <code>this</code> to the <code>bike</code> object, therefore, you see the value of the <code>brand</code> property of the <code>bike</code> object on the console.</p>\n<h3>3) Constructor invocation</h3>\n<p>When you use the <code>new</code> keyword to create an instance of a function object, you use the function as a constructor.</p>\n<p>The following example declares a <code>Car</code> function, then invokes it as a constructor:</p>\n<hr>\n<pre><code class=\"language-js\">function Car(brand) {\n    this.brand = brand;\n}\n\nCar.prototype.getBrand = function () {\n    return this.brand;\n}\n\nlet car = new Car('Honda');\nconsole.log(car.getBrand());Code language: JavaScript (javascript)\n</code></pre>\n<p>The expression <code>new Car('Honda')</code> is a constructor invocation of the <code>Car</code> function.</p>\n<p>JavaScript creates a new object and sets <code>this</code> to the newly created object. This pattern works great with only one potential problem.</p>\n<p>Now, you can invoke the <code>Car()</code> as a function or as a constructor. If you omit the <code>new</code> keyword as follows:</p>\n<pre><code class=\"language-js\">var bmw = Car('BMW');\nconsole.log(bmw.brand);\n// => TypeError: Cannot read property 'brand' of undefinedCode language: JavaScript (javascript)\n</code></pre>\n<p>Since the <code>this</code> value in the <code>Car()</code> sets to the global object, the <code>bmw.brand</code> returns <code>undefined</code>.</p>\n<p>To make sure that the <code>Car()</code> function is always invoked using constructor invocation, you add a check at the beginning of the <code>Car()</code> function as follows:</p>\n<hr>\n<pre><code class=\"language-js\">function Car(brand) {\n    if (!(this instanceof Car)) {\n        throw Error('Must use the new operator to call the function');\n    }\n    this.brand = brand;\n}Code language: JavaScript (javascript)\n</code></pre>\n<p>ES6 introduced a meta-property named <a href=\"https://www.javascripttutorial.net/es6/javascript-new-target/\"><code>new.target</code></a> that allows you to detect whether a function is invoked as a simple invocation or as a constructor.</p>\n<p>You can modify the <code>Car()</code> function that uses the <code>new.target</code> metaproperty as follows:</p>\n<hr>\n<pre><code class=\"language-js\">function Car(brand) {\n    if (!new.target) {\n        throw Error('Must use the new operator to call the function');\n    }\n    this.brand = brand;\n}Code language: JavaScript (javascript)\n</code></pre>\n<h3>4) Indirect Invocation</h3>\n<p>In JavaScript, <a href=\"https://www.javascripttutorial.net/javascript-functions-are-first-class-citizens/\">functions are first-class citizens</a>. In other words, functions are objects, which are instances of the <a href=\"https://www.javascripttutorial.net/javascript-function-type/\">Function type</a>.</p>\n<p>The <code>Function</code> type has two methods: <code>[call()](https://www.javascripttutorial.net/javascript-call/)</code> and <code>[apply()](https://www.javascripttutorial.net/javascript-apply-method/)</code> . These methods allow you to set the <code>this</code> value when calling a function. For example:</p>\n<hr>\n<pre><code class=\"language-js\">function getBrand(prefix) {\n    console.log(prefix + this.brand);\n}\n\nlet honda = {\n    brand: 'Honda'\n};\nlet audi = {\n    brand: 'Audi'\n};\n\ngetBrand.call(honda, \"It's a \");\ngetBrand.call(audi, \"It's an \");Code language: JavaScript (javascript)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"language-js\">It's a Honda\nIt's an AudiCode language: PHP (php)\n</code></pre>\n<p>In this example, we called the <code>getBrand()</code> function indirectly using the <code>call()</code> method of the <code>getBrand</code> function. We passed <code>honda</code> and  <code>audi</code> object as the first argument of the <code>call()</code> method, therefore, we got the corresponding brand in each call.</p>\n<p>The <code>apply()</code> method is similar to the <code>call()</code> method except that its second argument is an array of arguments.</p>\n<pre><code class=\"language-js\">getBrand.apply(honda, [\"It's a \"]); // \"It's a Honda\"\ngetBrand.apply(audi, [\"It's an \"]); // \"It's a Audi\"Code language: JavaScript (javascript)\n</code></pre>\n<h2>Arrow functions</h2>\n<p><a href=\"https://www.javascripttutorial.net/es6/\">ES6</a> introduced a new concept named <a href=\"https://www.javascripttutorial.net/es6/javascript-arrow-function/\">arrow function</a>. In arrow functions, JavaScript sets the <code>this</code> lexically.</p>\n<p>It means the arrow function does not create its own <a href=\"https://www.javascripttutorial.net/javascript-execution-context/\">execution context</a> but inherits the <code>this</code> from the outer function where the arrow function is defined. See the following example:</p>\n<pre><code class=\"language-js\">let getThis = () => this;\nconsole.log(getThis() === window); // trueCode language: JavaScript (javascript)\n</code></pre>\n<p>In this example, the <code>this</code> value is set to the global object i.e., <code>window</code> in the web browser.</p>\n<p>Since an arrow function does not create its own execution context, defining a method using an arrow function will cause an issue. For example:</p>\n<hr>\n<pre><code class=\"language-js\">function Car() {\n    this.speed = 120;\n}\n\nCar.prototype.getSpeed = () => {\n    return this.speed;\n}\n\nvar car = new Car();\ncar.getSpeed(); // TypeErrorCode language: JavaScript (javascript)\n</code></pre>\n<p>Inside the <code>getSpeed()</code> method, the <code>this</code> value reference the global object, not the <code>Car</code> object. Therefore the <code>car.getSpeed()</code> invocation causes an error because the global object does not have the <code>speed</code> property.</p>"}