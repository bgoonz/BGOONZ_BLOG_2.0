{"expireTime":9007200908525415000,"key":"transformer-remark-markdown-html-fef2e7d21de4835a432542252f111ba4--","val":"<h1>Array.prototype.sort()</h1>\n<p>The <code>sort()</code> method sorts the elements of an array <em>[in place](<a href=\"https://en.wikipedia.org/wiki/In-place\">https://en.wikipedia.org/wiki/In-place</a></em>algorithm)_ and returns the sorted array. The default sort order is ascending, built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values.</p>\n<p>The time and space complexity of the sort cannot be guaranteed as it depends on the implementation.</p>\n<h2>Syntax</h2>\n<pre><code>// Functionless\nsort()\n\n// Arrow function\nsort((firstEl, secondEl) => { ... } )\n\n// Compare function\nsort(compareFn)\n\n// Inline compare function\nsort(function compareFn(firstEl, secondEl) { ... })\n</code></pre>\n<h3>Parameters</h3>\n<p><code>compareFunction</code> <span class=\"badge inline optional\">Optional</span>\nSpecifies a function that defines the sort order. If omitted, the array elements are converted to strings, then sorted according to each character's Unicode code point value.</p>\n<p><code>firstEl</code>\nThe first element for comparison.</p>\n<p><code>secondEl</code>\nThe second element for comparison.</p>\n<h3>Return value</h3>\n<p>The sorted array. Note that the array is sorted <em>[in place](<a href=\"https://en.wikipedia.org/wiki/In-place\">https://en.wikipedia.org/wiki/In-place</a></em>algorithm)_, and no copy is made.</p>\n<h2>Description</h2>\n<p>If <code>compareFunction</code> is not supplied, all non-<code>undefined</code> array elements are sorted by converting them to strings and comparing strings in UTF-16 code units order. For example, \"banana\" comes before \"cherry\". In a numeric sort, 9 comes before 80, but because numbers are converted to strings, \"80\" comes before \"9\" in the Unicode order. All <code>undefined</code> elements are sorted to the end of the array.</p>\n<p><strong>Note:</strong> In UTF-16, Unicode characters above <code>\\uFFFF</code> are encoded as two surrogate code units, of the range <code>\\uD800</code>-<code>\\uDFFF</code>. The value of each code unit is taken separately into account for the comparison. Thus the character formed by the surrogate pair <code>\\uD655\\uDE55</code> will be sorted before the character <code>\\uFF3A</code>.</p>\n<p>If <code>compareFunction</code> is supplied, all non-<code>undefined</code> array elements are sorted according to the return value of the compare function (all <code>undefined</code> elements are sorted to the end of the array, with no call to <code>compareFunction</code>). If <code>a</code> and <code>b</code> are two elements being compared, then:</p>\n<ul>\n<li>If <code>compareFunction(a, b)</code> returns less than 0, leave <code>a</code> and <code>b</code> unchanged.</li>\n<li>If <code>compareFunction(a, b)</code> returns 0, leave <code>a</code> and <code>b</code> unchanged with respect to each other, but sorted with respect to all different elements. Note: the ECMAScript standard only started guaranteeing this behavior <a href=\"https://www.ecma-international.org/ecma-262/10.0/index.html#sec-intro\">in 2019</a>, thus, older browsers may not respect this.</li>\n<li>If <code>compareFunction(a, b)</code> returns greater than 0, sort <code>b</code> before <code>a</code>.</li>\n<li><code>compareFunction(a, b)</code> must always return the same value when given a specific pair of elements <code>a</code> and <code>b</code> as its two arguments. If inconsistent results are returned, then the sort order is undefined.</li>\n</ul>\n<p>So, the compare function has the following form:</p>\n<pre><code>function compare(a, b) {\n  if (a is less than b by some ordering criterion) {\n    return -1;\n  }\n  if (a is greater than b by the ordering criterion) {\n    return 1;\n  }\n  // a must be equal to b\n  return 0;\n}\n</code></pre>\n<p>To compare numbers instead of strings, the compare function can subtract <code>b</code> from <code>a</code>. The following function will sort the array in ascending order (if it doesn't contain <code>Infinity</code> and <code>NaN</code>):</p>\n<pre><code>function compareNumbers(a, b) {\n  return a - b;\n}\n</code></pre>\n<p>The <code>sort</code> method can be conveniently used with <a href=\"../../operators/function\">function expressions</a>:</p>\n<pre><code>var numbers = [4, 2, 5, 1, 3];\nnumbers.sort(function(a, b) {\n  return a - b;\n});\nconsole.log(numbers);\n\n// [1, 2, 3, 4, 5]\n</code></pre>\n<p>ES2015 provides <a href=\"../../functions/arrow_functions\">arrow function expressions</a> with even shorter syntax.</p>\n<pre><code>let numbers = [4, 2, 5, 1, 3];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers);\n\n// [1, 2, 3, 4, 5]\n</code></pre>\n<p>Arrays of objects can be sorted by comparing the value of one of their properties.</p>\n<pre><code>var items = [\n  { name: 'Edward', value: 21 },\n  { name: 'Sharpe', value: 37 },\n  { name: 'And', value: 45 },\n  { name: 'The', value: -12 },\n  { name: 'Magnetic', value: 13 },\n  { name: 'Zeros', value: 37 }\n];\n\n// sort by value\nitems.sort(function (a, b) {\n  return a.value - b.value;\n});\n\n// sort by name\nitems.sort(function(a, b) {\n  var nameA = a.name.toUpperCase(); // ignore upper and lowercase\n  var nameB = b.name.toUpperCase(); // ignore upper and lowercase\n  if (nameA &#x3C; nameB) {\n    return -1;\n  }\n  if (nameA > nameB) {\n    return 1;\n  }\n\n  // names must be equal\n  return 0;\n});\n</code></pre>\n<h2>Examples</h2>\n<h3>Creating, displaying, and sorting an array</h3>\n<p>The following example creates four arrays and displays the original array, then the sorted arrays. The numeric arrays are sorted without a compare function, then sorted using one.</p>\n<pre><code>let stringArray = ['Blue', 'Humpback', 'Beluga'];\nlet numericStringArray = ['80', '9', '700'];\nlet numberArray = [40, 1, 5, 200];\nlet mixedNumericArray = ['80', '9', '700', 40, 1, 5, 200];\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\nstringArray.join(); // 'Blue,Humpback,Beluga'\nstringArray.sort(); // ['Beluga', 'Blue', 'Humpback']\n\nnumberArray.join(); // '40,1,5,200'\nnumberArray.sort(); // [1, 200, 40, 5]\nnumberArray.sort(compareNumbers); // [1, 5, 40, 200]\n\nnumericStringArray.join(); // '80,9,700'\nnumericStringArray.sort(); // [700, 80, 9]\nnumericStringArray.sort(compareNumbers); // [9, 80, 700]\n\nmixedNumericArray.join(); // '80,9,700,40,1,5,200'\nmixedNumericArray.sort(); // [1, 200, 40, 5, 700, 80, 9]\nmixedNumericArray.sort(compareNumbers); // [1, 5, 9, 40, 80, 200, 700]\n</code></pre>\n<h3>Sorting non-ASCII characters</h3>\n<p>For sorting strings with non-ASCII characters, i.e. strings with accented characters (e, é, è, a, ä, etc.), strings from languages other than English, use <a href=\"../string/localecompare\"><code>String.localeCompare</code></a>. This function can compare those characters so they appear in the right order.</p>\n<pre><code>var items = ['réservé', 'premier', 'communiqué', 'café', 'adieu', 'éclair'];\nitems.sort(function (a, b) {\n  return a.localeCompare(b);\n});\n\n// items is ['adieu', 'café', 'communiqué', 'éclair', 'premier', 'réservé']\n</code></pre>\n<h3>Sorting with map</h3>\n<p>The <code>compareFunction</code> can be invoked multiple times per element within the array. Depending on the <code>compareFunction</code>'s nature, this may yield a high overhead. The more work a <code>compareFunction</code> does and the more elements there are to sort, it may be more efficient to use <a href=\"map\">map</a> for sorting. The idea is to traverse the array once to extract the actual values used for sorting into a temporary array, sort the temporary array, and then traverse the temporary array to achieve the right order.</p>\n<pre><code>// the array to be sorted\nconst in = ['delta', 'alpha', 'charlie', 'bravo'];\n\n// temporary array holds objects with position and sort-value\nconst mapped = in.map((v, i) => {\n  return { i, value: someSlowOperation(v) };\n})\n\n// sorting the mapped array containing the reduced values\nmapped.sort((a, b) => {\n  if (a.value > b.value) {\n    return 1;\n  }\n  if (a.value &#x3C; b.value) {\n    return -1;\n  }\n  return 0;\n});\n\nconst result = mapped.map(v => in[v.i]);\n</code></pre>\n<p>There is an open source library available called <a href=\"https://null.house/open-source/mapsort\">mapsort</a> which applies this approach.</p>\n<h3>Sort stability</h3>\n<p>Since version 10 (or EcmaScript 2019), the <a href=\"https://tc39.es/ecma262/#sec-array.prototype.sort\">specification</a> dictates that <code>Array.prototype.sort</code> is stable.</p>\n<p>For example, say you had a list of students alongside their grades. Note that the list of students is already pre-sorted by name in alphabetical order:</p>\n<pre><code>const students = [\n  { name: \"Alex\",   grade: 15 },\n  { name: \"Devlin\", grade: 15 },\n  { name: \"Eagle\",  grade: 13 },\n  { name: \"Sam\",    grade: 14 },\n];\n</code></pre>\n<p>After sorting this array by <code>grade</code> in ascending order:</p>\n<pre><code>students.sort((firstItem, secondItem) => firstItem.grade - secondItem.grade);\n</code></pre>\n<p>The <code>students</code> variable will then have the following value:</p>\n<pre><code>[\n  { name: \"Eagle\",  grade: 13 },\n  { name: \"Sam\",    grade: 14 },\n  { name: \"Alex\",   grade: 15 }, // original maintained for similar grade (stable sorting)\n  { name: \"Devlin\", grade: 15 }, // original maintained for similar grade (stable sorting)\n];\n</code></pre>\n<p>It's important to note that students that have the same grade (for example, Alex and Devlin), will remain in the same order as before calling the sort. This is what a stable sorting algorithm guarantees.</p>\n<p>Before version 10 (or EcmaScript 2019), sort stabiliy was not guaranteed, meaning that you could end up with the following:</p>\n<pre><code>[\n  { name: \"Eagle\",  grade: 13 },\n  { name: \"Sam\",    grade: 14 },\n  { name: \"Devlin\", grade: 15 }, // original order not maintained\n  { name: \"Alex\",   grade: 15 }, // original order not maintained\n];\n</code></pre>"}