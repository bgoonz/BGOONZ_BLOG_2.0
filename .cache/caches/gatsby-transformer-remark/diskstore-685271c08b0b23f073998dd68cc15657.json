{"expireTime":9007200908525415000,"key":"transformer-remark-markdown-html-2f1459b5130a3eb13cf48576bccd7a5a--","val":"<h1>What is heap data structure</h1>\n<p>Heap is one efficient implementation of an abstract data structure called a <a href=\"https://learnersbucket.com/tutorials/data-structures/priority-queue-implementation-in-javascript\">priority queue</a>.</p>\n<hr>\n<h2>Priority Queue</h2>\n<details>\n<summary> Click To Learn About Priority Queues </summary>\n<h2>What is priority queue?</h2>\n<p>As queues are widely used in computer programming and in real lives as well, there was a need for some different models of original <a href=\"https://learnersbucket.com/tutorials/algorithms/queue-implementation-in-javascript\">queue data structure</a> to process the data more efficiently.</p>\n<p>A priority queue is one of the variants of the original queue. In this elements are added and removed based on their priorities. It is an abstract data type that captures the idea of a container whose elements have priorities attached to them. An element of highest priority always appears at the front of the queue. If that element is removed, the next highest priority element advances to the front.</p>\n<p>A real-life example of the priority queue are the patients in the hospitals, the one with at most priority are treated first and then the others.</p>\n<p>Another example is people standing in a queue at the boarding line at the airport, first and second class(Business class) peoples passengers get priority over the coach class(Economy).</p>\n<p>In India elderly or women get priority over young and men at many places like in railway and bus.</p>\n<p><img src=\"https://i0.wp.com/learnersbucket.com/wp-content/uploads/2019/09/ezgif.com-optimize-2.gif?resize=600%2C338&#x26;ssl=1\" alt=\"Priority queue in javascript\"></p>\n<h2>Why do we need priority queue?</h2>\n<p>It is used when we have to choose between the same values who have different priorities or weight.</p>\n<ul>\n<li>Dijkstra's Shortest Path Algorithm using priority queue: When the graph is stored in the form of adjacency list or matrix, priority queue can be used to extract minimum efficiently when implementing Dijkstra's algorithm.</li>\n<li>Prim's algorithm: to store keys of nodes and extract minimum key node at every step.</li>\n<li>Data compression: It is used in Huffman Codes which is used to compresses data.</li>\n<li>Operating system: It is used by operating systems for <a href=\"https://www.nginx.com/resources/glossary/load-balancing/\">load balancing</a>.</li>\n</ul>\n<p>Now I am sure that you have a good idea about priority queue, so let us start implementing it in javascript.</p>\n<h2>List of operations performed on priority queue</h2>\n<ul>\n<li>enqueue(): Adds an item at the tail of the queue.</li>\n<li>dequeue(): Removes an item from the head of the queue.</li>\n<li>front(): Retruns the first item in the queue.</li>\n<li>rear(): Retruns the last item in the queue.</li>\n<li>size(): Returns the size of the queue.</li>\n<li>isEmpty(): Returns <code>true</code> if queue is empty, <code>false</code> otherwise.</li>\n</ul>\n<p>There are two ways of implementing a priority queue.</p>\n<ul>\n<li>Add elements at appropriate place based on their priorities.</li>\n<li>Queue elements as they are added and remove them according to their priorities.</li>\n</ul>\n<p>We will be using the first approach as we just have to place the elements at the appropriate place and then it can be dequeued normally.</p>\n<h2>Implementing a priority queue in javascript</h2>\n<p>We will use an extra function (container) which will be storing the value and its priority.</p>\n<p>function  PriorityQueue(){  let items =  [];  //Container  function  QueueElement(element, priority){  this.element = element;  this.priority = priority;  }  //Other methods go here  }</p>\n<hr>\n<h3>Adding an item in the priority queue</h3>\n<p>This is the only major method which will be modifying to store the data based on priorities.</p>\n<p>We will iterate each element that is already present in the queue and compare their priority with the new element's priority. If the new elements priority is greater then will add it at that place.</p>\n<p>To add elements at specific index we will need to shift the remaining elements back, But [javascript array] has an inbuilt method for this <code>splice(index, count, element)</code> which we will be using.</p>\n<p>//Add a new element in queue  this.enqueue =  function(element, priority){  let queueElement =  new  QueueElement(element, priority);  //To check if element is added  let added =  false;  for(let i =  0; i &#x3C; items.length; i++){  //We are using giving priority to higher numbers  //If new element has more priority then add it at that place  if(queueElement.priority > items[i].priority){ items.splice(i,  0, queueElement);  //Mark the flag true added =  true;  break;  }  }  //If element is not added  //Then add it to the end of the queue  if(!added){ items.push(queueElement);  }  }</p>\n<hr>\n<h3>Remove an item from the priority queue</h3>\n<p>//Remove element from the queue  this.dequeue =  ()  =>  {  return items.shift();  }</p>\n<hr>\n<h3>Return the first element from the priority queue</h3>\n<p>//Return the first element from the queue  this.front =  ()  =>  {  return items[0];  }</p>\n<hr>\n<h3>Return the last element from the priority queue</h3>\n<p>//Return the last element from the queue  this.rear =  ()  =>  {  return items[items.length -  1];  }</p>\n<hr>\n<h3>Check if queue is empty</h3>\n<p>//Check if queue is empty  this.isEmpty =  ()  =>  {  return items.length ==  0;  }</p>\n<hr>\n<h3>Return the size of the queue</h3>\n<p>//Return the size of the queue  this.size =  ()  =>  {  return items.length;  }</p>\n<hr>\n<h3>Print the queue</h3>\n<p>//Print the queue  this.print  =  function(){  for(let i =  0; i &#x3C; items.length; i++){ console.log(<code>${items[i].element} - ${items[i].priority}</code>);  }  }</p>\n<hr>\n<h2>Complete code of the priority queue</h2>\n<p>function  PriorityQueue(){  let items =  [];  //Container  function  QueueElement(element, priority){  this.element = element;  this.priority = priority;  }  //Add a new element in queue  this.enqueue =  function(element, priority){  let queueElement =  new  QueueElement(element, priority);  //To check if element is added  let added =  false;  for(let i =  0; i &#x3C; items.length; i++){  //We are using giving priority to higher numbers  //If new element has more priority then add it at that place  if(queueElement.priority > items[i].priority){ items.splice(i,  0, queueElement);  //Mark the flag true added =  true;  break;  }  }  //If element is not added  //Then add it to the end of the queue  if(!added){ items.push(queueElement);  }  }  //Remove element from the queue  this.dequeue =  ()  =>  {  return items.shift();  }  //Return the first element from the queue  this.front =  ()  =>  {  return items[0];  }  //Return the last element from the queue  this.rear =  ()  =>  {  return items[items.length -  1];  }  //Check if queue is empty  this.isEmpty =  ()  =>  {  return items.length ==  0;  }  //Return the size of the queue  this.size =  ()  =>  {  return items.length;  }  //Print the queue  this.print  =  function(){  for(let i =  0; i &#x3C; items.length; i++){ console.log(<code>${items[i].element} - ${items[i].priority}</code>);  }  }  }</p>\n<p>Input:  let pQ =  new  PriorityQueue(); pQ.enqueue(1,  3); pQ.enqueue(5,  2); pQ.enqueue(6,  1); pQ.enqueue(11,  1); pQ.enqueue(13,  1); pQ.enqueue(10,  3); pQ.dequeue(); pQ.print();  Output:  \"10 - 3\"  \"5 - 2\"  \"6 - 1\"  \"11 - 1\"  \"13 - 1\"</p>\n<hr>\n<h2>ES6 class based implementation of priority queue</h2>\n<p>//Container  class  QueueElement{  constructor(element, priority){  this.element = element;  this.priority = priority;  }  }  //PriorityQueue  class  PriorityQueue{  constructor(){  this.items =  [];  }  //Add a new element in queue enqueue =  function(element, priority){  let queueElement =  new  QueueElement(element, priority);  //To check if element is added  let added =  false;  for(let i =  0; i &#x3C;  this.items.length; i++){  //We are using giving priority to higher numbers  //If new element has more priority then add it at that place  if(queueElement.priority >  this.items[i].priority){  this.items.splice(i,  0, queueElement);  //Mark the flag true added =  true;  break;  }  }  //If element is not added  //Then add it to the end of the queue  if(!added){  this.items.push(queueElement);  }  }  //Remove element from the queue dequeue =  function(){  return  this.items.shift();  }  //Return the first element from the queue front =  function(){  return  this.items[0];  }  //Return the last element from the queue rear =  function(){  return  this.items[this.items.length -  1];  }  //Check if queue is empty isEmpty =  function(){  return  this.items.length ==  0;  }  //Return the size of the queue size =  function(){  return  this.items.length;  }  //Print the queue  print  =  function(){  for(let i =  0; i &#x3C;  this.items.length; i++){ console.log(<code>${this.items[i].element} - ${this.items[i].priority}</code>);  }  }  }</p>\n<p>Input:  let pQ =  new  PriorityQueue(); pQ.enqueue(1,  3); pQ.enqueue(5,  2); pQ.enqueue(6,  1); pQ.enqueue(11,  1); pQ.enqueue(13,  1); pQ.enqueue(10,  3); pQ.dequeue(); pQ.print();  Output:  \"10 - 3\"  \"5 - 2\"  \"6 - 1\"  \"11 - 1\"  \"13 - 1\"</p>\n<hr>\n<h2>Making this class private with closure and IIFE</h2>\n<p>let  PriorityQueue  =  (function(){  //Container  class  QueueElement{  constructor(element, priority){  this.element = element;  this.priority = priority;  }  }  //PriorityQueue  return  class  PriorityQueue{  constructor(){  this.items =  [];  }  //Add a new element in queue enqueue =  function(element, priority){  let queueElement =  new  QueueElement(element, priority);  //To check if element is added  let added =  false;  for(let i =  0; i &#x3C;  this.items.length; i++){  //We are using giving priority to higher numbers  //If new element has more priority then add it at that place  if(queueElement.priority >  this.items[i].priority){  this.items.splice(i,  0, queueElement);  //Mark the flag true added =  true;  break;  }  }  //If element is not added  //Then add it to the end of the queue  if(!added){  this.items.push(queueElement);  }  }  //Remove element from the queue dequeue =  function(){  return  this.items.shift();  }  //Return the first element from the queue front =  function(){  return  this.items[0];  }  //Return the last element from the queue rear =  function(){  return  this.items[this.items.length -  1];  }  //Check if queue is empty isEmpty =  function(){  return  this.items.length ==  0;  }  //Return the size of the queue size =  function(){  return  this.items.length;  }  //Print the queue  print  =  function(){  for(let i =  0; i &#x3C;  this.items.length; i++){ console.log(<code>${this.items[i].element} - ${this.items[i].priority}</code>);  }  }  }  }());</p>\n<h4>Time Complexity</h4>\n<table>\n<thead>\n<tr>\n<th>#</th>\n<th>Access</th>\n<th>Search</th>\n<th>Insert</th>\n<th>Delete</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Average</td>\n<td>Θ(N)</td>\n<td>Θ(N)</td>\n<td>Θ(N)</td>\n<td>Θ(1)</td>\n</tr>\n<tr>\n<td>Worst</td>\n<td>O(N)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h4>Space Complexity</h4>\n<table>\n<thead>\n<tr>\n<th>#</th>\n<th>space</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Worst</td>\n<td>O(N)</td>\n</tr>\n</tbody>\n</table>\n</details>\n<p>In a heap, the highest (or lowest) priority element is always stored at the root, thus priority queue is often referred to as heaps irrespective of their implementation.</p>\n<p>Heap is the most useful data structure when it is necessary to repeatedly remove the object with the highest (or lowest) priority.</p>\n<p>One of the most common implementations of the heap is the binary heap which is basically a binary tree.</p>\n<p>A binary heap is basically a binary tree with two additional properties.</p>\n<ol>\n<li><strong>Shape property</strong>: It must be a complete binary tree, which means all the levels of the tree, except the deepest (last) one are fully filled. In case the last level of the tree is not complete, the nodes of that level are filled from left to right.</li>\n<li><strong>Heap property</strong>: All nodes are either greater than or equal to or less than or equal to each of its children. If the parent nodes are greater than their child nodes, the heap is called a Max-Heap, and if the parent nodes are smaller than their child nodes, the heap is called Min-Heap.</li>\n</ol>\n<p><img src=\"https://i0.wp.com/learnersbucket.com/wp-content/uploads/2020/10/max-and-min-heap-1.png?resize=768%2C500&#x26;ssl=1\" alt=\"Max and Min heap\"></p>\n<hr>\n<h2>List of operations performed on binary heap</h2>\n<ul>\n<li><strong>insert(num)</strong>: Add a new key to the heap.</li>\n<li><strong>delete(num)</strong>: Removes a key from the heap.</li>\n<li><strong>heapify</strong>: Create a (min or max) heap from the given array.</li>\n<li><strong>findMax or (findMin)</strong>: Return the max element from the heap or (min).</li>\n<li><strong>extractMax or (extractMin)</strong>: Remove and return the max element from the heap or (min).</li>\n<li><strong>deleteMax or (deleteMin)</strong>: Remove the max element from the heap or (min).</li>\n<li><strong>size</strong>: Return the size of the heap.</li>\n<li><strong>isEmpty</strong>: Is heap empty or not?.</li>\n<li><strong>getList</strong>: Get the heap as an array.</li>\n</ul>\n<hr>\n<h2>Implementing binary heap data structure in Javascript</h2>\n<p>Binary heaps can be represented using an array with certain mathematical calculations.</p>\n<p>If the index of any element in the array is <code>i</code>, the element in the index <code>2i+1</code> will become the left child, and the element in the <code>2i+2</code> index will become the right child. Also, the parent of any element at index <code>i</code> is given by the lower bound of <code>(i-1)/2</code>.</p>\n<p>Thus we can create the binary heap using an array rather than using a tree.</p>\n<pre><code class=\"language-js\">function BinaryHeap(){\n  let list = [];\n  \n  //other operations will go here.\n}\n</code></pre>\n<hr>\n<h3>Heapify</h3>\n<p>The first operation which we will be adding is heapify, because either after inserting or deleting a new element in the heap we will have to heapify it to retain the form.</p>\n<p>To build a max-heap from any tree, we can start heapifying each sub-tree from the bottom up and end up with a max-heap. Repeat this for all the elements including the root element.</p>\n<p>In the case of a complete tree, the first index of a non-leaf node is given by <code>n/2 - 1</code>. All other nodes after that are leaf-nodes and thus don't need to be heapified.</p>\n<p><img src=\"https://i0.wp.com/learnersbucket.com/wp-content/uploads/2020/10/how-to-heapify-root-element-1.png?resize=768%2C500&#x26;ssl=1\" alt=\"Heapify root element\"></p>\n<pre><code>  //Heapify\n  this.maxHeapify = (arr, n, i) => {\n    let largest = i;\n    let l = 2 * i + 1; //left child index\n    let r = 2 * i + 2; //right child index\n\n    //If left child is smaller than root\n     if (l &#x3C; n &#x26;&#x26; arr[l] > arr[largest]) {\n           largest = l; \n     }\n\n     // If right child is smaller than smallest so far \n     if (r &#x3C; n &#x26;&#x26; arr[r] > arr[largest]) {\n          largest = r; \n     }\n\n     // If smallest is not root \n     if (largest != i) { \n          let temp = arr[i]; \n          arr[i] = arr[largest]; \n          arr[largest] = temp; \n\n        // Recursively heapify the affected sub-tree \n        this.maxHeapify(arr, n, largest); \n      } \n  }\n</code></pre>\n<hr>\n<h3>Inserting a new element in the heap</h3>\n<p>To add a new element, we first check if the list is empty or not. If it is empty then push the element directly, else we will have to heapify the list after addition.</p>\n<p><img src=\"https://i0.wp.com/learnersbucket.com/wp-content/uploads/2020/10/Adding-a-new-node-in-the-binary-heap-1.png?resize=768%2C500&#x26;ssl=1\" alt=\"Adding a new node in the binary heap\"></p>\n<pre><code>//Insert Value\n  this.insert = (num) => {\n    const size = list.length;\n    if(size === 0){\n      list.push(num);\n    }else{\n      list.push(num);\n      \n     for (let i = parseInt(list.length / 2 - 1); i >= 0; i--) {\n         this.maxHeapify(list, list.length, i); \n     }\n    }\n  }\n</code></pre>\n<hr>\n<h3>Removing an element from the heap</h3>\n<p>Removing a node is 4 step process.</p>\n<ol>\n<li>Find the element in the array.</li>\n<li>Swap the element with the last element.</li>\n<li>Remove the last element.</li>\n<li>Heapify the list.</li>\n</ol>\n<p><img src=\"https://i0.wp.com/learnersbucket.com/wp-content/uploads/2020/10/Delete-a-node-in-binary-heap-1-1.png?resize=768%2C500&#x26;ssl=1\" alt=\"Delete a node in binary heap \"></p>\n<pre><code>//Remove value\n  this.delete = (num) => {\n    const size = list.length;\n    \n    //Get the index of the number to be removed\n    let i;\n    for(i = 0; i &#x3C; size; i++){\n      if(num === list[i]){\n        break;\n      }\n    }\n    \n    //Swap the number with last element\n    [list[i], list[size - 1]] = [list[size - 1], list[i]];\n    \n    //Remove the last element\n    list.splice(size - 1);\n    \n    //Heapify the list again\n    for (let i = parseInt(list.length / 2 - 1); i >= 0; i--) {\n         this.maxHeapify(list, list.length, i); \n     }\n  }\n</code></pre>\n<hr>\n<h3>Find max from the heap</h3>\n<p>As the list is already max heapified, we just need to return the root element because it is the max.</p>\n<pre><code>//Return max value\n  this.findMax = () => list[0];\n</code></pre>\n<hr>\n<h3>Delete max from the heap</h3>\n<p>Delete the root to remove the max. We can use the exisiting delete method for it.</p>\n<pre><code>//Remove max val\n  this.deleteMax = () => {\n    this.delete(list[0]);\n  }\n</code></pre>\n<hr>\n<h3>Extract max from the heap</h3>\n<p>Store the max value in a variable and then delete it from the heap, after that return the value.</p>\n<pre><code>//Remove and return max value\n  this.extractMax = () => {\n    const max = list[0];\n    this.delete(max);\n    return max;\n  }\n</code></pre>\n<hr>\n<h3>Size of the heap</h3>\n<pre><code>//Size\n  this.size = () => list.length;\n</code></pre>\n<hr>\n<h3>IsEmpty check</h3>\n<pre><code>//IsEmpty\n  this.isEmpty = () => list.length === 0;\n</code></pre>\n<hr>\n<h3>Get the heap</h3>\n<pre><code>//Return head\n  this.getList = () => list;\n</code></pre>\n<hr>\n<h2>Complete code of binary heap data structure implemented in Javascript</h2>\n<pre><code>function BinaryHeap(){\n  let list = [];\n  \n  //Heapify\n  this.maxHeapify = (arr, n, i) => {\n    let largest = i;\n    let l = 2 * i + 1; //left child index\n    let r = 2 * i + 2; //right child index\n\n    //If left child is smaller than root\n     if (l &#x3C; n &#x26;&#x26; arr[l] > arr[largest]) {\n           largest = l; \n     }\n\n     // If right child is smaller than smallest so far \n     if (r &#x3C; n &#x26;&#x26; arr[r] > arr[largest]) {\n          largest = r; \n     }\n\n     // If smallest is not root \n     if (largest != i) { \n          let temp = arr[i]; \n          arr[i] = arr[largest]; \n          arr[largest] = temp; \n\n        // Recursively heapify the affected sub-tree \n        this.maxHeapify(arr, n, largest); \n      } \n  }\n  \n  //Insert Value\n  this.insert = (num) => {\n    const size = list.length;\n    \n    if(size === 0){\n      list.push(num);\n    }else{\n      list.push(num);\n\n      //Heapify\n      for (let i = parseInt(list.length / 2 - 1); i >= 0; i--) {\n         this.maxHeapify(list, list.length, i); \n      }\n    }\n  }\n  \n  //Remove value\n  this.delete = (num) => {\n    const size = list.length;\n    \n    //Get the index of the number to be removed\n    let i;\n    for(i = 0; i &#x3C; size; i++){\n      if(list[i] === num){\n        break;\n      }\n    }\n    \n    //Swap the number with last element\n    [list[i], list[size - 1]] = [list[size - 1], list[i]];\n\n    //Remove the last element\n    list.splice(size - 1);\n    \n    //Heapify the list again\n    for (let i = parseInt(list.length / 2 - 1); i >= 0; i--) {\n         this.maxHeapify(list, list.length, i); \n     }\n  }\n  \n  //Return max value\n  this.findMax = () => list[0];\n  \n  //Remove max val\n  this.deleteMax = () => {\n    this.delete(list[0]);\n  }\n  \n  //Remove and return max value\n  this.extractMax = () => {\n    const max = list[0];\n    this.delete(max);\n    return max;\n  }\n  \n  //Size\n  this.size = () => list.length;\n  \n  //IsEmpty\n  this.isEmpty = () => list.length === 0;\n  \n  //Return head\n  this.getList = () => list;\n}\n</code></pre>\n<pre><code>Input:\nconst heap = new BinaryHeap();\nheap.insert(3);\nheap.insert(4);\nheap.insert(9);\nheap.insert(5);\nheap.insert(2);\nconsole.log(heap.getList());\n\nheap.delete(9);\nconsole.log(heap.getList());\n\nheap.insert(7);\nconsole.log(heap.getList());\n\nOutput:\n[9, 5, 4, 3, 2]\n[5, 3, 4, 2]\n[7, 5, 4, 2, 3]\n</code></pre>\n<hr>\n<h2>Binary heap with Min-Heap</h2>\n<pre><code class=\"language-js\">function BinaryHeap(){\n  let list = [];\n  \n  //Heapify\n  this.minHeapify = (arr, n, i) => {\n    let smallest = i;\n    let l = 2 * i + 1; //left child index\n    let r = 2 * i + 2; //right child index\n\n    //If left child is smaller than root\n     if (l &#x3C; n &#x26;&#x26; arr[l] &#x3C; arr[smallest]) {\n           smallest = l; \n     }\n\n     // If right child is smaller than smallest so far \n     if (r &#x3C; n &#x26;&#x26; arr[r] &#x3C; arr[smallest]) {\n          smallest = r; \n     }\n\n     // If smallest is not root \n     if (smallest != i) { \n          let temp = arr[i]; \n          arr[i] = arr[smallest]; \n          arr[smallest] = temp; \n\n        // Recursively heapify the affected sub-tree \n        this.minHeapify(arr, n, smallest); \n      } \n  }\n  \n  //Insert Value\n  this.insert = (num) => {\n    const size = list.length;\n    \n    if(size === 0){\n      list.push(num);\n    }else{\n      list.push(num);\n      \n      //Heapify\n      for (let i = parseInt(list.length / 2 - 1); i >= 0; i--) {\n         this.minHeapify(list, list.length, i); \n      }\n    }\n  }\n  \n  //Remove value\n  this.delete = (num) => {\n    const size = list.length;\n    \n    //Get the index of the number to be removed\n    let i;\n    for(i = 0; i &#x3C; size; i++){\n      if(list[i] === num){\n        break;\n      }\n    }\n    \n    //Swap the number with last element\n    [list[i], list[size - 1]] = [list[size - 1], list[i]];\n\n    //Remove the last element\n    list.splice(size - 1);\n    \n    //Heapify the list again\n    for (let i = parseInt(list.length / 2 - 1); i >= 0; i--) {\n         this.minHeapify(list, list.length, i); \n     }\n  }\n  \n  //Return min value\n  this.findMin = () => list[0];\n  \n  //Remove min val\n  this.deleteMin = () => {\n    this.delete(list[0]);\n  }\n  \n  //Remove and return min value\n  this.extractMin = () => {\n    const min = list[0];\n    this.delete(min);\n    return min;\n  }\n  \n  //Size\n  this.size = () => list.length;\n  \n  //IsEmpty\n  this.isEmpty = () => list.length === 0;\n  \n  //Return head\n  this.getList = () => list;\n}\n</code></pre>\n<pre><code class=\"language-js\">Input:\nconst heap = new BinaryHeap();\nheap.insert(3);\nheap.insert(4);\nheap.insert(9);\nheap.insert(5);\nheap.insert(2);\n\nconsole.log(heap.getList());\n\nheap.delete(9);\nconsole.log(heap.getList());\n\nheap.insert(7);\nconsole.log(heap.getList());\n\nOutput:\n[2, 3, 9, 5, 4]\n[2, 3, 4, 5]\n[2, 3, 4, 5, 7]\n</code></pre>\n<hr>\n<h2>Class based implementation of binary heap in javascript</h2>\n<pre><code class=\"language-js\">class BinaryHeap{\n  constructor(){\n    this.list = [];\n  }\n  \n  //Heapify\n  maxHeapify = (arr, n, i) => {\n    let largest = i;\n    let l = 2 * i + 1; //left child index\n    let r = 2 * i + 2; //right child index\n\n    //If left child is smaller than root\n     if (l &#x3C; n &#x26;&#x26; arr[l] > arr[largest]) {\n           largest = l; \n     }\n\n     // If right child is smaller than smallest so far \n     if (r &#x3C; n &#x26;&#x26; arr[r] > arr[largest]) {\n          largest = r; \n     }\n\n     // If smallest is not root \n     if (largest != i) { \n          let temp = arr[i]; \n          arr[i] = arr[largest]; \n          arr[largest] = temp; \n\n        // Recursively heapify the affected sub-tree \n        this.maxHeapify(arr, n, largest); \n      } \n  }\n  \n  //Insert Value\n  insert = (num) => {\n    const size = this.list.length;\n    if(size === 0){\n      this.list.push(num);\n    }else{\n      this.list.push(num);\n      \n      //Heapify\n      for (let i = parseInt(this.list.length / 2 - 1); i >= 0; i--) {\n         this.maxHeapify(this.list, this.list.length, i); \n      }\n    }\n  }\n  \n  //Remove value\n  delete = (num) => {\n    const size = this.list.length;\n    \n    //Get the index of the number to be removed\n    let i;\n    for(i = 0; i &#x3C; size; i++){\n      if(num === this.list[i]){\n        break;\n      }\n    }\n    \n    //Swap the number with last element\n    [this.list[i], this.list[size - 1]] = [this.list[size - 1], this.list[i]];\n    \n    //Remove the last element\n    this.list.splice(size - 1);\n    \n    //Heapify the list again\n    for (let i = parseInt(this.list.length / 2 - 1); i >= 0; i--) {\n         this.maxHeapify(this.list, this.list.length, i); \n     }\n  }\n  \n  //Return max value\n  findMax = () => this.list[0];\n  \n  //Remove max val\n  deleteMax = () => {\n    this.delete(this.list[0]);\n  }\n  \n  //Remove and return max value\n  extractMax = () => {\n    const max = this.list[0];\n    this.delete(max);\n    return max;\n  }\n  \n  //Size\n  size = () => this.list.length;\n  \n  //IsEmpty\n  isEmpty = () => this.list.length === 0;\n  \n  //Return head\n  getList = () => this.list;\n}\n</code></pre>\n<h3>Time complexity of heap data structure</h3>\n<table>\n<thead>\n<tr>\n<th>#</th>\n<th>Access</th>\n<th>Search</th>\n<th>Insert</th>\n<th>Delete</th>\n<th>FindMax or (Min)</th>\n<th>DeleteMax or (Min)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Average</td>\n<td>Θ(N)</td>\n<td>Θ(N)</td>\n<td>ΘLog(N)</td>\n<td>ΘLog(N)</td>\n<td>Θ(1)</td>\n<td>ΘLog(N)</td>\n</tr>\n<tr>\n<td>Worst</td>\n<td>O(N)</td>\n<td>O(N)</td>\n<td>OLog(N)</td>\n<td>OLog(N)</td>\n<td>O(1)</td>\n<td>OLog(N)</td>\n</tr>\n</tbody>\n</table>\n<h3>Space complexity</h3>\n<hr>\n<h3>Applications</h3>\n<ul>\n<li>Implementing a priority queue.</li>\n<li>Dijkstra's Algorithm.</li>\n<li>Heap Sort.</li>\n</ul>"}