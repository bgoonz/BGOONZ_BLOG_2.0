{"expireTime":9007200908526791000,"key":"transformer-remark-markdown-html-eacd64d68506d2323da8885c19e7736a--","val":"<p>Use the File System Route API when you want to create dynamic pages e.g. to create individual blog post pages for your blog.</p>\n<p>You should be able to accomplish most common tasks with this file-based API. If you want more control over the page creation you should use the <a href=\"/docs/reference/config-files/gatsby-node#createPages\"><code>createPages</code></a> API.</p>\n<p>Dynamic pages can be created from collections in Gatsby's <a href=\"/docs/conceptual/graphql-concepts/\">GraphQL data layer</a> and to create <a href=\"/docs/how-to/routing/client-only-routes-and-user-authentication\">client-only routes</a>.</p>\n<p>A complete example showcasing all options can be found in <a href=\"https://github.com/gatsbyjs/gatsby/tree/master/examples/route-api\">Gatsby's examples folder</a>.</p>\n<h2>Collection routes</h2>\n<p>Imagine a Gatsby project that sources a <code>product.yaml</code> file and multiple Markdown blog posts. At build time, Gatsby will automatically <a href=\"/docs/glossary/#inference\">infer</a> the fields and create multiple <a href=\"/docs/glossary#node\">nodes</a> for both types (<code>Product</code> and <code>MarkdownRemark</code>).</p>\n<p>To create collection routes, use curly braces (<code>{ }</code>) in your filenames to signify dynamic URL segments that relate to a field within the node. Here are a few examples:</p>\n<ul>\n<li><code>src/pages/products/{Product.name}.js</code> will generate a route like <code>/products/burger</code></li>\n<li><code>src/pages/products/{Product.fields__sku}.js</code> will generate a route like <code>/products/001923</code></li>\n<li><code>src/pages/blog/{MarkdownRemark.parent__(File)__name}.js</code> will generate a route like <code>/blog/learning-gatsby</code></li>\n</ul>\n<p>Gatsby creates a page for each node in a collection route. So if you have three markdown files that are blog posts, Gatsby will create the three pages from a collection route. As you add and remove markdown files, Gatsby will add and remove pages.</p>\n<p>Collection routes can be created for any GraphQL data type. Creating new collection routes in Gatsby is a process\nof adding a source plugin, use GraphiQL to identify the type and field to construct the route file name, and then code the route component.</p>\n<h3>Syntax (collection routes)</h3>\n<p>There are some general syntax requirements when using collection routes:</p>\n<ul>\n<li>Dynamic segments of file paths must start and end with curly braces (<code>{ }</code>).</li>\n<li>Types are case-sensitive (e.g. <code>MarkdownRemark</code> or <code>contentfulMyContentType</code>). Check GraphiQL for the correct names.</li>\n<li>Dynamic segments must include both a type and a field e.g. <code>{Type.field}</code> or <code>{BlogPost.slug}</code>.</li>\n</ul>\n<h3>Nested routes</h3>\n<p>You can use dynamic segments multiple times in a path. For example, you might want to nest product names within its product category. For example:</p>\n<ul>\n<li><code>src/pages/products/{Product.category}/{Product.name}.js</code> will generate a route like <code>/products/toys/fidget-spinner</code></li>\n<li><code>src/pages/products/{Product.category}/{Product.name}/{Product.color}.js</code> will generate a route like <code>/products/toys/fidget-spinner/red</code></li>\n</ul>\n<h3>Field syntax</h3>\n<h4>Dot notation</h4>\n<p>Using <code>.</code> you signify that you want to access a field on a node of a type.</p>\n<p><code>src/pages/products/{Product.name}.js</code> generates the following query:</p>\n<pre><code class=\"language-javascript\">allProduct {\n  nodes {\n    id # Gatsby always queries for id\n    name\n  }\n}\n</code></pre>\n<h4>Underscore notation</h4>\n<p>Using <code>__</code> (double underscore) you signify that you want to access a nested field on a node.</p>\n<p><code>src/pages/products/{Product.fields__sku}.js</code> generates the following query:</p>\n<pre><code class=\"language-javascript\">allProduct {\n  nodes {\n    id # Gatsby always queries for id\n    fields {\n      sku\n    }\n  }\n}\n</code></pre>\n<p>You can nest as deep as necessary, e.g. <code>src/pages/products/{Product.fields__date__createdAt}.js</code> generates the following query:</p>\n<pre><code class=\"language-javascript\">allProduct {\n  nodes {\n    id # Gatsby always queries for id\n    fields {\n      date {\n        createdAt\n      }\n    }\n  }\n}\n</code></pre>\n<h4>Parentheses notation</h4>\n<p>Using <code>( )</code> you signify that you want to access a <a href=\"https://graphql.org/learn/schema/#union-types\">GraphQL union type</a>. This is often possible with types that Gatsby creates for you. For example, <code>MarkdownRemark</code> always has <code>File</code> as a parent type, and thus you can also access fields from the <code>File</code> node. You can use this multiple levels deep, too, e.g. <code>src/pages/blog/{Post.parent__(MarkdownRemark)__parent__(File)__name}.js</code>.</p>\n<p><code>src/pages/blog/{MarkdownRemark.parent__(File)__name}.js</code> generates the following query:</p>\n<pre><code class=\"language-graphql\">allMarkdownRemark {\n  nodes {\n    id # Gatsby always queries for id\n    parent {\n      … on File {\n        name\n      }\n    }\n  }\n}\n</code></pre>\n<h3>Collection Route Components</h3>\n<p>Collection route components are passed two dynamic variables. The <code>id</code> of each page's node and the\nURL path as <code>params</code>. The params is passed to the component as <code>props.params</code> and the id as <code>props.pageContext.id</code>.</p>\n<p>Both are also passed as variables to the component's GraphQL query so you can query fields from the node. Page querying, including the use of variables, is explained in more depth in <a href=\"/docs/how-to/querying-data/page-query/\">querying data in pages with GraphQL</a>.</p>\n<p>For example:</p>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport { graphql } from 'gatsby';\n\nexport default function Component(props) {\n    return props.data.fields.sku + props.params.name; // highlight-line\n}\n\n// This is the page query that connects the data to the actual component. Here you can query for any and all fields\n// you need access to within your code. Again, since Gatsby always queries for `id` in the collection, you can use that\n// to connect to this GraphQL query.\n\nexport const query = graphql`\n    query ($id: String) {\n        product(id: { eq: $id }) {\n            fields {\n                sku\n            }\n        }\n    }\n`;\n</code></pre>\n<p>For the page <code>src/pages/{Product.name}/{Product.coupon}.js</code> you'd have <code>props.params.name</code> and <code>props.params.coupon</code> available inside <code>{Product.coupon}.js</code>.</p>\n<p>If you need to want to create pages for only some nodes in a collection (e.g. filtering out any product of type <code>\"Food\"</code>) or customize the variables passed to the query, you should use the <a href=\"/docs/reference/config-files/gatsby-node#createPages\"><code>createPages</code></a> API instead as File System Route API doesn't support this at the moment.</p>\n<h3>Routing and linking</h3>\n<p>Gatsby \"slugifies\" every route that gets created from collection pages (by using <a href=\"https://github.com/sindresorhus/slugify\"><code>sindresorhus/slugify</code></a>). Or in other words: If you have a route called <code>src/pages/wholesome/{Animal.slogan}.js</code> where <code>slogan</code> is <code>I ♥ Dogs</code> the final URL will be <code>/wholesome/i-love-dogs</code>. Gatsby will convert the field into a human-readable URL format while stripping it of invalid characters.</p>\n<p>When you want to link to a collection route page, it may not always be clear how to construct the URL from scratch.</p>\n<p>To address this issue, Gatsby automatically includes a <code>gatsbyPath</code> field on every type used by collection pages. The <code>gatsbyPath</code> field must take an argument of the <code>filePath</code> it is trying to resolve. This is necessary because it’s possible that one type is used in multiple collection pages.</p>\n<p>There are some general syntax requirements when using the <code>filePath</code> argument:</p>\n<ul>\n<li>The path must be an absolute path (starting with a <code>/</code>).</li>\n<li>You must omit the file extension.</li>\n<li>You must omit the <code>src/pages</code> prefix.</li>\n<li>Your path must not include <code>index</code>.</li>\n</ul>\n<h4><code>gatsbyPath</code> example</h4>\n<p>Assume that a <code>Product</code> type is used in two pages:</p>\n<ul>\n<li><code>src/pages/products/{Product.name}.js</code></li>\n<li><code>src/pages/discounts/{Product.name}.js</code></li>\n</ul>\n<p>If you wanted to link to the <code>products/{Product.name}</code> and <code>discounts/{Product.name}</code> routes from your home page, you would have a component like this:</p>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport { Link, graphql } from 'gatsby';\n\nexport default function HomePage(props) {\n    return (\n        &#x3C;ul>\n            {props.data.allProduct.map((product) => (\n                &#x3C;li key={product.name}>\n                    &#x3C;Link to={product.productPath}>{product.name}&#x3C;/Link> (&#x3C;Link to={product.discountPath}>Discount&#x3C;/Link>) // highlight-line\n                &#x3C;/li>\n            ))}\n        &#x3C;/ul>\n    );\n}\n\nexport const query = graphql`\n  query {\n    allProduct {\n      name\n      productPath: gatsbyPath(filePath: \"/products/{Product.name}\") // highlight-line\n      discountPath: gatsbyPath(filePath: \"/discounts/{Product.name}\") // highlight-line\n    }\n  }\n`;\n</code></pre>\n<p>By using <a href=\"/docs/graphql-reference/#aliasing\">aliasing</a> you can use <code>gatsbyPath</code> multiple times.</p>\n<h2>Creating client-only routes</h2>\n<p>Use <a href=\"/docs/how-to/routing/client-only-routes-and-user-authentication\">client-only routes</a> if you have dynamic data that does not live in Gatsby. This might be something like a user settings page, or some other dynamic content that isn't known to Gatsby at build time. In these situations, you will usually create a route with one or more dynamic segments to query data from a server in order to render your page.</p>\n<h3>Syntax (client-only routes)</h3>\n<p>You can use square brackets (<code>[ ]</code>) in the file path to mark any dynamic segments of the URL. For example, in order to edit a user, you might want a route like <code>/user/:id</code> to fetch the data for whatever <code>id</code> is passed into the URL.</p>\n<ul>\n<li><code>src/pages/users/[id].js</code> will generate a route like <code>/users/:id</code></li>\n<li><code>src/pages/users/[id]/group/[groupId].js</code> will generate a route like <code>/users/:id/group/:groupId</code></li>\n</ul>\n<h4>Splat routes</h4>\n<p>Gatsby also supports <em>splat</em> (or wildcard) routes, which are routes that will match <em>anything</em> after the splat. These are less common, but still have use cases. Use three periods in square brackets (<code>[...]</code>) in a file path to mark a page as a splat route. You can also name the parameter your page receives by adding a name after the three periods (<code>[...myNameKey]</code>).</p>\n<p>As an example, suppose that you are rendering images from <a href=\"/docs/how-to/previews-deploys-hosting/deploying-to-s3-cloudfront/\">S3</a> and the URL is actually the key to the asset in AWS. Here is how you might create your file:</p>\n<ul>\n<li><code>src/pages/image/[...].js</code> will generate a route like <code>/image/*</code>. <code>*</code> is accessible in your page's received properties with the key name <code>*</code>.</li>\n<li><code>src/pages/image/[...awsKey].js</code> will generate a route like <code>/image/*awsKey</code>. <code>*awsKey</code> is accessible in your page's received properties with the key name <code>awsKey</code>.</li>\n</ul>\n<pre><code class=\"language-javascript\">export default function ImagePage({ params }) {\n    const param = params[`*`];\n\n    // When visiting a route like `image/hello/world`,\n    // the value of `param` is `hello/world`.\n}\n</code></pre>\n<pre><code class=\"language-javascript\">export default function ImagePage({ params }) {\n    const param = params[`awsKey`];\n\n    // When visiting a route like `image/hello/world`,\n    // the value of `param` is `hello/world`.\n}\n</code></pre>\n<p>Splat routes may not live in the same directory as regular client only routes.</p>\n<h3>Examples</h3>\n<p>The dynamic segment of the file name (the part between the square brackets) will be filled in and provided to your components on a <code>props.params</code> object. For example:</p>\n<pre><code class=\"language-js:title=src/pages/users/[name].js\">function UserPage(props) {\n  const name = props.params.name\n}\n</code></pre>\n<pre><code class=\"language-javascript\">function ProductsPage(props) {\n    const splat = props.params.awsKey;\n}\n</code></pre>\n<pre><code class=\"language-javascript\">function AppPage(props) {\n  const splat = props.params[‘*’]\n}\n</code></pre>\n<h2><code>config</code> function</h2>\n<p>Inside a File System Route template you can export an async function called <code>config</code>. You can use this function to:</p>\n<ul>\n<li>Mark the page as deferred or not (see <a href=\"/docs/reference/rendering-options/deferred-static-generation/\">Deferred Static Generation API reference</a>)</li>\n</ul>\n<p>Inside your template:</p>\n<pre><code class=\"language-javascript\">import { graphql } from 'gatsby';\n\n// The rest of your page, including imports, page component &#x26; page query etc.\n\nexport async function config() {\n    const { data } = graphql`\n    {\n      # Your GraphQL query\n    }\n  `;\n\n    return ({ params }) => {\n        return {\n            defer: params.name === data.someValue.name\n        };\n    };\n}\n</code></pre>\n<p>When you export an async <code>config</code> function Gatsby will evaluate the returned object and optionally run any GraphQL queries defined inside the outer function. You can't run GraphQL queries inside the inner function.</p>\n<p>The <code>params</code> parameter is an object that contains the URL path, see <a href=\"#collection-route-components\">explanation above</a>.</p>\n<p>The inner function of <code>config</code> can return an object with one key:</p>\n<ul>\n<li><code>defer</code>: Boolean of whether the page should be marked as deferred or not</li>\n</ul>\n<p>Read the <a href=\"/docs/how-to/rendering-options/using-deferred-static-generation/\">Deferred Static Generation guide</a> to see a real-world example.</p>\n<h2>Example use cases</h2>\n<p>Have a look at the <a href=\"https://github.com/gatsbyjs/gatsby/tree/master/examples/route-api/src/pages/products\">route-api example</a> for more detail.</p>\n<h3>Collection route + fallback</h3>\n<p>By using a combination of a collection route with a client-only route, you can create a seamless experience when a user tries to visit a URL from the collection route that doesn’t exist (yet) for the collection item. Consider these two file paths:</p>\n<ul>\n<li><code>src/pages/products/{Product.name}.js</code> (collection route)</li>\n<li><code>src/pages/products/[name].js</code> (client-only route, fallback)</li>\n</ul>\n<p>The collection route will create all available product pages at the time of the <a href=\"/docs/glossary/build/\">build</a>. If you're adding a new product you want to link to but only periodically building your site, you'll need a fallback. By using a client-only route as a fallback you then can load the necessary information for the product on the client until you re-built your site.</p>\n<p>Similarly, the fallback page could also be used for when a product doesn't exist and you want to show some helpful information (like a 404 page).</p>\n<h3>Using one template for multiple routes</h3>\n<p>By placing the template/view for your routes into a reusable component you can display the same information under different routes. Take this example:</p>\n<p>You want to display product information which is both accessible by name and SKU but has the same design. Create two file paths first:</p>\n<ul>\n<li><code>src/pages/products/{Product.name}.js</code></li>\n<li><code>src/pages/products/{Product.meta__sku}.js</code></li>\n</ul>\n<p>Create a view component at <code>src/view/product-view.js</code> that takes in a <code>product</code> prop. Use that component in both collection routes, e.g.:</p>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport { graphql } from 'gatsby';\nimport ProductView from '../../views/product-view';\n\nfunction Product(props) {\n    const { product } = props.data;\n    return &#x3C;ProductView product={product} />;\n}\n\nexport default Product;\n\nexport const query = graphql`\n    query ($id: String!) {\n        product(id: { eq: $id }) {\n            name\n            description\n            appearance\n            meta {\n                createdAt\n                id\n                sku\n            }\n        }\n    }\n`;\n</code></pre>\n<p>You can copy the same code to the <code>src/pages/products/{Product.meta__sku}.js</code> file.</p>\n<h3>Purely client-only app</h3>\n<p>If you want your Gatsby app to be 100% client-only, you can create a file at <code>src/pages/[...].js</code> to catch all requests. See the <a href=\"https://github.com/gatsbyjs/gatsby/tree/master/examples/client-only-paths\">client-only-paths example</a> for more detail.</p>"}