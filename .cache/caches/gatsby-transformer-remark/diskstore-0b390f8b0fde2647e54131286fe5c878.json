{"expireTime":9007200908525415000,"key":"transformer-remark-markdown-html-4dfd30ca591a69e56b0fd5be9f864f74--","val":"<h1>Object.create()</h1>\n<p>The <code>Object.create()</code> method creates a new object, using an existing object as the prototype of the newly created object.</p>\n<h2>Syntax</h2>\n<pre><code>Object.create(proto)\nObject.create(proto, propertiesObject)\n</code></pre>\n<h3>Parameters</h3>\n<p><code>proto</code>\nThe object which should be the prototype of the newly-created object.</p>\n<p><code>propertiesObject</code> <span class=\"badge inline optional\">Optional</span>\nIf specified and not <a href=\"../undefined\"><code>undefined</code></a>, an object whose enumerable own properties (that is, those properties defined upon itself and <em>not</em> enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of <a href=\"defineproperties\"><code>Object.defineProperties()</code></a>.</p>\n<h3>Return value</h3>\n<p>A new object with the specified prototype object and properties.</p>\n<h3>Exceptions</h3>\n<p>The <code>proto</code> parameter has to be either</p>\n<ul>\n<li><a href=\"../null\"><code>null</code></a> or</li>\n<li>an <a href=\"../object\"><code>Object</code></a> excluding <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Primitive#primitive_wrapper_objects_in_javascript\">primitive wrapper objects</a>.</li>\n</ul>\n<p>If <code>proto</code> is neither of these a <a href=\"../typeerror\"><code>TypeError</code></a> is thrown.</p>\n<h2>Custom and Null objects</h2>\n<p>A new object created from a completely custom object (especially one created from the <code>null</code> object, which is basically a custom object with NO members) can behave in unexpected ways. This is especially true when debugging, since common object-property converting/detecting utility functions may generate errors, or lose information (especially if using silent error-traps that ignore errors). For example, here are two objects:</p>\n<pre><code>oco = Object.create( {} );   // create a normal object\nocn = Object.create( null ); // create a \"null\" object\n\n> console.log(oco) // {} -- Seems normal\n> console.log(ocn) // {} -- Seems normal here too, so far\n\noco.p = 1; // create a simple property on normal obj\nocn.p = 0; // create a simple property on \"null\" obj\n\n> console.log(oco) // {p: 1} -- Still seems normal\n> console.log(ocn) // {p: 0} -- Still seems normal here too. BUT WAIT...\n</code></pre>\n<p>As shown above, all seems normal so far. However, when attempting to actually use these objects, their differences quickly become apparent:</p>\n<pre><code>> \"oco is: \" + oco // shows \"oco is: [object Object]\"\n\n> \"ocn is: \" + ocn // throws error: Cannot convert object to primitive value\n</code></pre>\n<p>Testing just a few of the many most basic built-in functions shows the magnitude of the problem more clearly:</p>\n<pre><code>> alert(oco) // shows [object Object]\n> alert(ocn) // throws error: Cannot convert object to primitive value\n\n> oco.toString() // shows [object Object]\n> ocn.toString() // throws error: ocn.toString is not a function\n\n> oco.valueOf() // shows {}\n> ocn.valueOf() // throws error: ocn.valueOf is not a function\n\n> oco.hasOwnProperty(\"p\") // shows \"true\"\n> ocn.hasOwnProperty(\"p\") // throws error: ocn.hasOwnProperty is not a function\n\n> oco.constructor // shows \"Object() { [native code] }\"\n> ocn.constructor // shows \"undefined\"\n</code></pre>\n<p>As said, these differences can make debugging even simple-seeming problems quickly go astray. For example:</p>\n<p><em>A simple common debugging function:</em></p>\n<pre><code>// display top-level property name:value pairs of given object\nfunction ShowProperties(obj){\n  for(var prop in obj){\n    console.log(prop + \": \" + obj[prop] + \"\\n\" );\n  }\n}\n</code></pre>\n<p><em>Not such simple results: (especially if silent error-trapping had hidden the error messages)</em></p>\n<pre><code>ob={}; ob.po=oco; ob.pn=ocn; // create a compound object using the test objects from above as property values\n\n> ShowProperties( ob ) // display top-level properties\n- po: [object Object]\n- Error: Cannot convert object to primitive value\n\nNote that only first property gets shown.\n</code></pre>\n<p><em>(But if the same object is created in a different order -- at least in some implementations...)</em></p>\n<pre><code>ob={}; ob.pn=ocn; ob.po=oco; // create same compound object again, but create same properties in different order\n\n> ShowProperties( ob ) // display top-level properties\n- Error: Cannot convert object to primitive value\n\nNote that neither property gets shown.\n</code></pre>\n<p>Note that such a different order may arise statically via disparate fixed codings such as here, but also dynamically via whatever the order any such property-adding code-branches actually get executed at runtime as depends on inputs and/or random-variables. Then again, the actual iteration order is not guaranteed no matter what the order members are added.</p>\n<p>Be aware of, also, that using Object.entries() on an object created via Object.create() will result in an empty array being returned.</p>\n<pre><code>var obj = Object.create({ a: 1, b: 2 });\n\n> console.log(Object.entries(obj)); // shows \"[]\"\n</code></pre>\n<h4>Some NON-solutions</h4>\n<p>A good solution for the missing object-methods is not immediately apparent.</p>\n<p>Adding the missing object-method directly from the standard-object does NOT work:</p>\n<pre><code>ocn = Object.create( null ); // create \"null\" object (same as before)\n\nocn.toString = Object.toString; // since new object lacks method then try assigning it directly from standard-object\n\n> ocn.toString // shows \"toString() { [native code] }\" -- missing method seems to be there now\n> ocn.toString == Object.toString // shows \"true\" -- method seems to be same as the standard object-method\n\n> ocn.toString() // error: Function.prototype.toString requires that 'this' be a Function\n</code></pre>\n<p>Adding the missing object-method directly to new object's \"prototype\" does not work either, since the new object does not have a real prototype (which is really the cause of ALL these problems) and one cannot be <strong>directly</strong> added:</p>\n<pre><code>ocn = Object.create( null ); // create \"null\" object (same as before)\n\nocn.prototype.toString = Object.toString; // Error: Cannot set property 'toString' of undefined\n\nocn.prototype = {};                       // try to create a prototype\nocn.prototype.toString = Object.toString; // since new object lacks method then try assigning it from standard-object\n\n> ocn.toString() // error: ocn.toString is not a function\n</code></pre>\n<p>Adding the missing object-method by using the standard-object as new object's prototype does not work either:</p>\n<pre><code>ocn = Object.create( null );        // create \"null\" object (same as before)\nObject.setPrototypeOf(ocn, Object); // set new object's prototype to the standard-object\n\n> ocn.toString() // error: Function.prototype.toString requires that 'this' be a Function\n</code></pre>\n<h4>Some OK solutions</h4>\n<p>Again, adding the missing object-method directly from the <strong>standard-object</strong> does NOT work. However, adding the <strong>generic</strong> method directly, DOES:</p>\n<pre><code>ocn = Object.create( null ); // create \"null\" object (same as before)\n\nocn.toString = toString; // since new object lacks method then assign it directly from generic version\n\n> ocn.toString() // shows \"[object Object]\"\n> \"ocn is: \" + ocn // shows \"ocn is: [object Object]\"\n\nob={}; ob.pn=ocn; ob.po=oco; // create a compound object (same as before)\n\n> ShowProperties(ob) // display top-level properties\n- po: [object Object]\n- pn: [object Object]\n</code></pre>\n<p>However, setting the generic <strong>prototype</strong> as the new object's prototype works even better:</p>\n<pre><code>ocn = Object.create( null );                  // create \"null\" object (same as before)\nObject.setPrototypeOf(ocn, Object.prototype); // set new object's prototype to the \"generic\" object (NOT standard-object)\n</code></pre>\n<p><em>(In addition to all the string-related functions shown above, this also adds:)</em></p>\n<pre><code>> ocn.valueOf() // shows {}\n> ocn.hasOwnProperty(\"x\") // shows \"false\"\n> ocn.constructor // shows \"Object() { [native code] }\"\n\n// ...and all the rest of the properties and methods of Object.prototype.\n</code></pre>\n<p>As shown, objects modified this way now look very much like ordinary objects.</p>\n<h2>Polyfill</h2>\n<p>This polyfill covers the main use case, which is creating a new object for which the prototype has been chosen but doesn't take the second argument into account.</p>\n<p>Note that while the setting of <code>null</code> as <code>[[Prototype]]</code> is supported in the real ES5 <code>Object.create</code>, this polyfill cannot support it due to a limitation inherent in versions of ECMAScript lower than 5.</p>\n<pre><code> if (typeof Object.create !== \"function\") {\n    Object.create = function (proto, propertiesObject) {\n        if (typeof proto !== 'object' &#x26;&#x26; typeof proto !== 'function') {\n            throw new TypeError('Object prototype may only be an Object: ' + proto);\n        } else if (proto === null) {\n            throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n        }\n\n        if (typeof propertiesObject != 'undefined') {\n            throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support a second argument.\");\n        }\n\n        function F() {}\n        F.prototype = proto;\n\n        return new F();\n    };\n}\n</code></pre>\n<h2>Examples</h2>\n<h3>Classical inheritance with <code>Object.create()</code></h3>\n<p>Below is an example of how to use <code>Object.create()</code> to achieve classical inheritance. This is for a single inheritance, which is all that JavaScript supports.</p>\n<pre><code>// Shape - superclass\nfunction Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\n// superclass method\nShape.prototype.move = function(x, y) {\n  this.x += x;\n  this.y += y;\n  console.info('Shape moved.');\n};\n\n// Rectangle - subclass\nfunction Rectangle() {\n  Shape.call(this); // call super constructor.\n}\n\n// subclass extends superclass\nRectangle.prototype = Object.create(Shape.prototype);\n\n//If you don't set Rectangle.prototype.constructor to Rectangle,\n//it will take the prototype.constructor of Shape (parent).\n//To avoid that, we set the prototype.constructor to Rectangle (child).\nRectangle.prototype.constructor = Rectangle;\n\nvar rect = new Rectangle();\n\nconsole.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // true\nconsole.log('Is rect an instance of Shape?', rect instanceof Shape); // true\nrect.move(1, 1); // Outputs, 'Shape moved.'\n</code></pre>\n<p>If you wish to inherit from multiple objects, then mixins are a possibility.</p>\n<pre><code>function MyClass() {\n  SuperClass.call(this);\n  OtherSuperClass.call(this);\n}\n\n// inherit one class\nMyClass.prototype = Object.create(SuperClass.prototype);\n// mixin another\nObject.assign(MyClass.prototype, OtherSuperClass.prototype);\n// re-assign constructor\nMyClass.prototype.constructor = MyClass;\n\nMyClass.prototype.myMethod = function() {\n  // do something\n};\n</code></pre>\n<p><a href=\"assign\"><code>Object.assign()</code></a> copies properties from the OtherSuperClass prototype to the MyClass prototype, making them available to all instances of MyClass. <code>Object.assign()</code> was introduced with ES2015 and <a href=\"assign#polyfill\">can be polyfilled</a>. If support for older browsers is necessary, <code>jQuery.extend()</code> or <code>_.assign()</code> can be used.</p>\n<h3>Using propertiesObject argument with Object.create()</h3>\n<pre><code>var o;\n\n// create an object with null as prototype\no = Object.create(null);\n\no = {};\n// is equivalent to:\no = Object.create(Object.prototype);\n\n// Example where we create an object with a couple of\n// sample properties. (Note that the second parameter\n// maps keys to *property descriptors*.)\no = Object.create(Object.prototype, {\n  // foo is a regular 'value property'\n  foo: {\n    writable: true,\n    configurable: true,\n    value: 'hello'\n  },\n  // bar is a getter-and-setter (accessor) property\n  bar: {\n    configurable: false,\n    get: function() { return 10; },\n    set: function(value) {\n      console.log('Setting `o.bar` to', value);\n    }\n/* with ES2015 Accessors our code can look like this\n    get() { return 10; },\n    set(value) {\n      console.log('Setting `o.bar` to', value);\n    } */\n  }\n});\n\nfunction Constructor() {}\no = new Constructor();\n// is equivalent to:\no = Object.create(Constructor.prototype);\n// Of course, if there is actual initialization code\n// in the Constructor function,\n// the Object.create() cannot reflect it\n\n// Create a new object whose prototype is a new, empty\n// object and add a single property 'p', with value 42.\no = Object.create({}, { p: { value: 42 } });\n\n// by default properties ARE NOT writable,\n// enumerable or configurable:\no.p = 24;\no.p;\n// 42\n\no.q = 12;\nfor (var prop in o) {\n  console.log(prop);\n}\n// 'q'\n\ndelete o.p;\n// false\n\n// to specify an ES3 property\no2 = Object.create({}, {\n  p: {\n    value: 42,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  }\n});\n/* is not equivalent to:\nThis will create an object with prototype : {p: 42 }\no2 = Object.create({p: 42}) */\n</code></pre>"}