{"expireTime":9007200908525415000,"key":"transformer-remark-markdown-html-d8d53c9209deca70083c1140f94b9100--","val":"<h1>Arrow function expressions</h1>\n<p>An <strong>arrow function expression</strong> is a compact alternative to a traditional <a href=\"../operators/function\">function expression</a>, but is limited and can't be used in all situations.</p>\n<p><strong>Differences &#x26; Limitations:</strong></p>\n<ul>\n<li>Does not have its own bindings to <code>this</code> or <code>super</code>, and should not be used as <code>methods</code>.</li>\n<li>Does not have <code>arguments</code>, or <code>new.target</code> keywords.</li>\n<li>Not suitable for <code>call</code>, <code>apply</code> and <a href=\"../global_objects/function/bind\"><code>bind</code></a> methods, which generally rely on establishing a <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Scope\">scope</a>.</li>\n<li>Can not be used as <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Constructor\">constructors</a>.</li>\n<li>Can not use <code>yield</code>, within its body.</li>\n</ul>\n<h3>Comparing traditional functions to arrow functions</h3>\n<p>Let's decompose a \"traditional function\" down to the simplest \"arrow function\" step-by-step:\nNOTE: Each step along the way is a valid \"arrow function\"</p>\n<pre><code>// Traditional Function\nfunction (a){\n  return a + 100;\n}\n\n// Arrow Function Break Down\n\n// 1. Remove the word \"function\" and place arrow between the argument and opening body bracket\n(a) => {\n  return a + 100;\n}\n\n// 2. Remove the body brackets and word \"return\" -- the return is implied.\n(a) => a + 100;\n\n// 3. Remove the argument parentheses\na => a + 100;\n</code></pre>\n<p><strong>Note:</strong> As shown above, the { brackets } and ( parentheses ) and \"return\" are optional, but may be required.</p>\n<p>For example, if you have <strong>multiple arguments</strong> or <strong>no arguments</strong>, you'll need to re-introduce parentheses around the arguments:</p>\n<pre><code>// Traditional Function\nfunction (a, b){\n  return a + b + 100;\n}\n\n// Arrow Function\n(a, b) => a + b + 100;\n\n// Traditional Function (no arguments)\nlet a = 4;\nlet b = 2;\nfunction (){\n  return a + b + 100;\n}\n\n// Arrow Function (no arguments)\nlet a = 4;\nlet b = 2;\n() => a + b + 100;\n</code></pre>\n<p>Likewise, if the body requires <strong>additional lines</strong> of processing, you'll need to re-introduce brackets <strong>PLUS the \"return\"</strong> (arrow functions do not magically guess what or when you want to \"return\"):</p>\n<pre><code>// Traditional Function\nfunction (a, b){\n  let chuck = 42;\n  return a + b + chuck;\n}\n\n// Arrow Function\n(a, b) => {\n  let chuck = 42;\n  return a + b + chuck;\n}\n</code></pre>\n<p>And finally, for <strong>named functions</strong> we treat arrow expressions like variables</p>\n<pre><code>// Traditional Function\nfunction bob (a){\n  return a + 100;\n}\n\n// Arrow Function\nlet bob = a => a + 100;\n</code></pre>\n<h2>Syntax</h2>\n<h3>Basic syntax</h3>\n<p>One param. With simple expression return is not needed:</p>\n<pre><code>param => expression\n</code></pre>\n<p>Multiple params require parentheses. With simple expression return is not needed:</p>\n<pre><code>(param1, paramN) => expression\n</code></pre>\n<p>Multiline statements require body brackets and return:</p>\n<pre><code>param => {\n  let a = 1;\n  return a + param;\n}\n</code></pre>\n<p>Multiple params require parentheses. Multiline statements require body brackets and return:</p>\n<pre><code>(param1, paramN) => {\n   let a = 1;\n   return a + param1 + paramN;\n}\n</code></pre>\n<h3>Advanced syntax</h3>\n<p>To return an object literal expression requires parentheses around expression:</p>\n<pre><code>params => ({foo: \"a\"}) // returning the object {foo: \"a\"}\n</code></pre>\n<p><a href=\"rest_parameters\">Rest parameters</a> are supported:</p>\n<pre><code>(a, b, ...r) => expression\n</code></pre>\n<p><a href=\"default_parameters\">Default parameters</a> are supported:</p>\n<pre><code>(a=400, b=20, c) => expression\n</code></pre>\n<p><a href=\"../operators/destructuring_assignment\">Destructuring</a> within params supported:</p>\n<pre><code>([a, b] = [10, 20]) => a + b;  // result is 30\n({ a, b } = { a: 10, b: 20 }) => a + b; // result is 30\n</code></pre>\n<h2>Description</h2>\n<h3>Arrow functions used as methods</h3>\n<p>As stated previously, arrow function expressions are best suited for non-method functions. Let's see what happens when we try to use them as methods:</p>\n<pre><code>'use strict';\n\nvar obj = { // does not create a new scope\n  i: 10,\n  b: () => console.log(this.i, this),\n  c: function() {\n    console.log(this.i, this);\n  }\n}\n\nobj.b(); // prints undefined, Window {...} (or the global object)\nobj.c(); // prints 10, Object {...}\n</code></pre>\n<p>Arrow functions do not have their own <code>this</code>. Another example involving <a href=\"../global_objects/object/defineproperty\"><code>Object.defineProperty()</code></a>:</p>\n<pre><code>'use strict';\n\nvar obj = {\n  a: 10\n};\n\nObject.defineProperty(obj, 'b', {\n  get: () => {\n    console.log(this.a, typeof this.a, this); // undefined 'undefined' Window {...} (or the global object)\n    return this.a + 10; // represents global object 'Window', therefore 'this.a' returns 'undefined'\n  }\n});\n</code></pre>\n<h3>call, apply and bind</h3>\n<p>The <code>call</code>, <code>apply</code> and <a href=\"../global_objects/function/bind\"><code>bind</code></a> methods are <strong>NOT suitable</strong> for Arrow functions -- as they were designed to allow methods to execute within different scopes -- because <strong>Arrow functions establish \"this\" based on the scope the Arrow function is defined within.</strong></p>\n<p>For example <code>call</code>, <code>apply</code> and <a href=\"../global_objects/function/bind\"><code>bind</code></a> work as expected with Traditional functions, because we establish the scope for each of the methods:</p>\n<pre><code>// ----------------------\n// Traditional Example\n// ----------------------\n// A simplistic object with its very own \"this\".\nvar obj = {\n    num: 100\n}\n\n// Setting \"num\" on window to show how it is NOT used.\nwindow.num = 2020; // yikes!\n\n// A simple traditional function to operate on \"this\"\nvar add = function (a, b, c) {\n  return this.num + a + b + c;\n}\n\n// call\nvar result = add.call(obj, 1, 2, 3) // establishing the scope as \"obj\"\nconsole.log(result) // result 106\n\n// apply\nconst arr = [1, 2, 3]\nvar result = add.apply(obj, arr) // establishing the scope as \"obj\"\nconsole.log(result) // result 106\n\n// bind\nvar result = add.bind(obj) // establishing the scope as \"obj\"\nconsole.log(result(1, 2, 3)) // result 106\n</code></pre>\n<p>With Arrow functions, since our <code>add</code> function is essentially created on the <code>window</code> (global) scope, it will assume <code>this</code> is the window.</p>\n<pre><code>// ----------------------\n// Arrow Example\n// ----------------------\n\n// A simplistic object with its very own \"this\".\nvar obj = {\n    num: 100\n}\n\n// Setting \"num\" on window to show how it gets picked up.\nwindow.num = 2020; // yikes!\n\n// Arrow Function\nvar add = (a, b, c) => this.num + a + b + c;\n\n// call\nconsole.log(add.call(obj, 1, 2, 3)) // result 2026\n\n// apply\nconst arr = [1, 2, 3]\nconsole.log(add.apply(obj, arr)) // result 2026\n\n// bind\nconst bound = add.bind(obj)\nconsole.log(bound(1, 2, 3)) // result 2026\n</code></pre>\n<p>Perhaps the greatest benefit of using Arrow functions is with DOM-level methods (setTimeout, setInterval, addEventListener) that usually required some kind of closure, call, apply or bind to ensure the function executed in the proper scope.</p>\n<p><strong>Traditional Example:</strong></p>\n<pre><code>var obj = {\n    count : 10,\n    doSomethingLater : function (){\n        setTimeout(function(){ // the function executes on the window scope\n            this.count++;\n            console.log(this.count);\n        }, 300);\n    }\n}\n\nobj.doSomethingLater(); // console prints \"NaN\", because the property \"count\" is not in the window scope.\n</code></pre>\n<p><strong>Arrow Example:</strong></p>\n<pre><code>var obj = {\n    count : 10,\n    doSomethingLater : function(){ // of course, arrow functions are not suited for methods\n        setTimeout( () => { // since the arrow function was created within the \"obj\", it assumes the object's \"this\"\n            this.count++;\n            console.log(this.count);\n        }, 300);\n    }\n}\n\nobj.doSomethingLater();\n</code></pre>\n<h3>No binding of <code>arguments</code></h3>\n<p>Arrow functions do not have their own <a href=\"arguments\"><code>arguments</code> object</a>. Thus, in this example, <code>arguments</code> is a reference to the arguments of the enclosing scope:</p>\n<pre><code>var arguments = [1, 2, 3];\nvar arr = () => arguments[0];\n\narr(); // 1\n\nfunction foo(n) {\n  var f = () => arguments[0] + n; // foo's implicit arguments binding. arguments[0] is n\n  return f();\n}\n\nfoo(3); // 3 + 3 = 6\n</code></pre>\n<p>In most cases, using <a href=\"rest_parameters\">rest parameters</a> is a good alternative to using an <code>arguments</code> object.</p>\n<pre><code>function foo(n) {\n  var f = (...args) => args[0] + n;\n  return f(10);\n}\n\nfoo(1); // 11\n</code></pre>\n<h3>Use of the <code>new</code> operator</h3>\n<p>Arrow functions cannot be used as constructors and will throw an error when used with <code>new</code>.</p>\n<pre><code>var Foo = () => {};\nvar foo = new Foo(); // TypeError: Foo is not a constructor\n</code></pre>\n<h3>Use of <code>prototype</code> property</h3>\n<p>Arrow functions do not have a <code>prototype</code> property.</p>\n<pre><code>var Foo = () => {};\nconsole.log(Foo.prototype); // undefined\n</code></pre>\n<h3>Use of the <code>yield</code> keyword</h3>\n<p>The <code>yield</code> keyword may not be used in an arrow function's body (except when permitted within functions further nested within it). As a consequence, arrow functions cannot be used as generators.</p>\n<h3>Function body</h3>\n<p>Arrow functions can have either a \"concise body\" or the usual \"block body\".</p>\n<p>In a concise body, only an expression is specified, which becomes the implicit return value. In a block body, you must use an explicit <code>return</code> statement.</p>\n<pre><code>var func = x => x * x;\n// concise body syntax, implied \"return\"\n\nvar func = (x, y) => { return x + y; };\n// with block body, explicit \"return\" needed\n</code></pre>\n<h3>Returning object literals</h3>\n<p>Keep in mind that returning object literals using the concise body syntax <code>params => {object:literal}</code> will not work as expected.</p>\n<pre><code>var func = () => { foo: 1 };\n// Calling func() returns undefined!\n\nvar func = () => { foo: function() {} };\n// SyntaxError: function statement requires a name\n</code></pre>\n<p>This is because the code inside braces ({}) is parsed as a sequence of statements (i.e. <code>foo</code> is treated like a label, not a key in an object literal).</p>\n<p>You must wrap the object literal in parentheses:</p>\n<pre><code>var func = () => ({ foo: 1 });\n</code></pre>\n<h3>Line breaks</h3>\n<p>An arrow function cannot contain a line break between its parameters and its arrow.</p>\n<pre><code>var func = (a, b, c)\n  => 1;\n// SyntaxError: expected expression, got '=>'\n</code></pre>\n<p>However, this can be amended by putting the line break after the arrow or using parentheses/braces as seen below to ensure that the code stays pretty and fluffy. You can also put line breaks between arguments.</p>\n<pre><code>var func = (a, b, c) =>\n  1;\n\nvar func = (a, b, c) => (\n  1\n);\n\nvar func = (a, b, c) => {\n  return 1\n};\n\nvar func = (\n  a,\n  b,\n  c\n) => 1;\n\n// no SyntaxError thrown\n</code></pre>\n<h3>Parsing order</h3>\n<p>Although the arrow in an arrow function is not an operator, arrow functions have special parsing rules that interact differently with <a href=\"../operators/operator_precedence\">operator precedence</a> compared to regular functions.</p>\n<pre><code class=\"language-js\">    let callback;\n\n    callback = callback || function() {}; // ok\n\n    callback = callback || () => {};\n    // SyntaxError: invalid arrow-function arguments\n\n    callback = callback || (() => {});    // ok\n</code></pre>\n<h2>Examples</h2>\n<h3>Basic usage</h3>\n<pre><code class=\"language-js\">    // An empty arrow function returns undefined\n    let empty = () => {};\n\n    (() => 'foobar')();\n    // Returns \"foobar\"\n    // (this is an Immediately Invoked Function Expression)\n\n    var simple = a => a > 15 ? 15 : a;\n    simple(16); // 15\n    simple(10); // 10\n\n    let max = (a, b) => a > b ? a : b;\n\n    // Easy array filtering, mapping, ...\n\n    var arr = [5, 6, 13, 0, 1, 18, 23];\n\n    var sum = arr.reduce((a, b) => a + b);\n    // 66\n\n    var even = arr.filter(v => v % 2 == 0);\n    // [6, 0, 18]\n\n    var double = arr.map(v => v * 2);\n    // [10, 12, 26, 0, 2, 36, 46]\n\n    // More concise promise chains\n    promise.then(a => {\n      // ...\n    }).then(b => {\n      // ...\n    });\n\n    // Parameterless arrow functions that are visually easier to parse\n    setTimeout( () => {\n      console.log('I happen sooner');\n      setTimeout( () => {\n        // deeper code\n        console.log('I happen later');\n      }, 1);\n    }, 1);\n</code></pre>"}