{"expireTime":9007200881132593000,"key":"transformer-remark-markdown-html-ast-667a637b0d4ea4e848c09153a0215651--","val":{"type":"root","children":[{"type":"raw","value":"<div class=\"note\">\n  <strong>Note:</strong> These are the gatsby plugins that power the file system of this website! <strong>See more in the Docs</strong> section.\n</div>","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":4,"column":7,"offset":171}}},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Code:","position":{"start":{"line":6,"column":5,"offset":177},"end":{"line":6,"column":10,"offset":182}}}],"position":{"start":{"line":6,"column":1,"offset":173},"end":{"line":6,"column":10,"offset":182}}},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Gatsby Source File System","position":{"start":{"line":8,"column":3,"offset":186},"end":{"line":8,"column":28,"offset":211}}}],"position":{"start":{"line":8,"column":3,"offset":186},"end":{"line":8,"column":28,"offset":211}}},{"type":"text","value":"\n"}],"position":{"start":{"line":8,"column":1,"offset":184},"end":{"line":8,"column":28,"offset":211}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"js\nconst path = require('path');\nconst fs = require('fs');\nconst { createFilePath } = require('gatsby-source-filesystem');\nconst _ = require('lodash');\n\nfunction findFileNode({ node, getNode }) {\n    let fileNode = node;\n    let ids = [fileNode.id];\n\n    while (fileNode && fileNode.internal.type !== `File` && fileNode.parent) {\n        fileNode = getNode(fileNode.parent);\n\n        if (!fileNode) {\n            break;\n        }\n\n        if (_.includes(ids, fileNode.id)) {\n            console.log(`found cyclic reference between nodes`);\n            break;\n        }\n\n        ids.push(fileNode.id);\n    }\n\n    if (!fileNode || fileNode.internal.type !== `File`) {\n        console.log('did not find ancestor File node');\n        return null;\n    }\n\n    return fileNode;\n}\n\nexports.onCreateNode = ({ node, getNode, actions }, options) => {\n    const { createNodeField } = actions;\n\n    if (node.internal.type === 'MarkdownRemark') {\n        let fileNode = findFileNode({ node, getNode });\n        if (!fileNode) {\n            throw new Error('could not find parent File node for MarkdownRemark node: ' + node);\n        }\n\n        let url;\n        if (node.frontmatter.url) {\n            url = node.frontmatter.url;\n        } else if (_.get(options, 'uglyUrls', false)) {\n            url = path.join(fileNode.relativeDirectory, fileNode.name + '.html');\n        } else {\n            url = createFilePath({ node, getNode });\n        }\n\n        createNodeField({ node, name: 'url', value: url });\n        createNodeField({\n            node,\n            name: 'absolutePath',\n            value: fileNode.absolutePath\n        });\n        createNodeField({\n            node,\n            name: 'relativePath',\n            value: fileNode.relativePath\n        });\n        createNodeField({ node, name: 'absoluteDir', value: fileNode.dir });\n        createNodeField({\n            node,\n            name: 'relativeDir',\n            value: fileNode.relativeDirectory\n        });\n        createNodeField({ node, name: 'base', value: fileNode.base });\n        createNodeField({ node, name: 'ext', value: fileNode.ext });\n        createNodeField({ node, name: 'name', value: fileNode.name });\n    }\n};\n\nexports.createPages = ({ graphql, getNode, actions, getNodesByType }) => {\n    const { createPage, deletePage } = actions;\n\n    // Use GraphQL to bring only the \"id\" and \"html\" (added by gatsby-transformer-remark)\n    // properties of the MarkdownRemark nodes. Don't bring additional fields\n    // such as \"relativePath\". Otherwise, Gatsby's GraphQL resolvers might infer\n    // types these fields as File and change their structure. For example, the\n    // \"html\" attribute exists only on a GraphQL node, but does not exist on the\n    // underlying node.\n    return graphql(`\n        {\n            allMarkdownRemark {\n                edges {\n                    node {\n                        id\n                        html\n                    }\n                }\n            }\n        }\n    `).then((result) => {\n        if (result.errors) {\n            return Promise.reject(result.errors);\n        }\n\n        const nodes = result.data.allMarkdownRemark.edges.map(({ node }) => node);\n        const siteNode = getNode('Site');\n        const siteDataNode = getNode('SiteData');\n        const sitePageNodes = getNodesByType('SitePage');\n        const sitePageNodesByPath = _.keyBy(sitePageNodes, 'path');\n        const siteData = _.get(siteDataNode, 'data', {});\n\n        const pages = nodes.map((graphQLNode) => {\n            // Use the node id to get the underlying node. It is not exactly the\n            // same node returned by GraphQL, because GraphQL resolvers might\n            // transform node fields.\n            const node = getNode(graphQLNode.id);\n            return {\n                url: node.fields.url,\n                relativePath: node.fields.relativePath,\n                relativeDir: node.fields.relativeDir,\n                base: node.fields.base,\n                name: node.fields.name,\n                frontmatter: node.frontmatter,\n                html: graphQLNode.html\n            };\n        });\n\n        nodes.forEach((graphQLNode) => {\n            const node = getNode(graphQLNode.id);\n            const url = node.fields.url;\n\n            const template = node.frontmatter.template;\n            if (!template) {\n                console.error(`Error: undefined template for ${url}`);\n                return;\n            }\n\n            const component = path.resolve(`./src/templates/${template}.js`);\n            if (!fs.existsSync(component)) {\n                console.error(`Error: component \"src/templates/${template}.js\" missing for ${url}`);\n                return;\n            }\n\n            const existingPageNode = _.get(sitePageNodesByPath, url);\n\n            const page = {\n                path: url,\n                component: component,\n                context: {\n                    url: url,\n                    relativePath: node.fields.relativePath,\n                    relativeDir: node.fields.relativeDir,\n                    base: node.fields.base,\n                    name: node.fields.name,\n                    frontmatter: node.frontmatter,\n                    html: graphQLNode.html,\n                    pages: pages,\n                    site: {\n                        siteMetadata: _.get(siteData, 'site-metadata', {}),\n                        pathPrefix: siteNode.pathPrefix,\n                        data: _.omit(siteData, 'site-metadata')\n                    }\n                }\n            };\n\n            if (existingPageNode && !_.get(page, 'context.menus')) {\n                page.context.menus = _.get(existingPageNode, 'context.menus');\n            }\n\n            createPage(page);\n        });\n    });\n};\n\n```\n</pre>\n"}],"position":{"start":{"line":10,"column":1,"offset":213},"end":{"line":180,"column":11,"offset":6575}}}],"position":{"start":{"line":10,"column":1,"offset":213},"end":{"line":180,"column":11,"offset":6575}}},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{},"children":[{"type":"text","value":"Gatsby Source Data","position":{"start":{"line":182,"column":7,"offset":6583},"end":{"line":182,"column":25,"offset":6601}}}],"position":{"start":{"line":182,"column":1,"offset":6577},"end":{"line":182,"column":25,"offset":6601}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"<pre>\n```javascript\n"}],"position":{"start":{"line":184,"column":1,"offset":6603},"end":{"line":189,"column":5,"offset":6634}}}],"position":{"start":{"line":184,"column":1,"offset":6603},"end":{"line":189,"column":5,"offset":6634}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"const path = require('path');\nconst yaml = require('js-yaml');\nconst fse = require('fs-extra');\nconst chokidar = require('chokidar');\nconst _ = require('lodash');\n\nconst metadataFileName = 'site-metadata.json';\n\nconst parsers = {\n    yaml: (data) => yaml.safeLoad(data, { schema: yaml.JSON_SCHEMA }),\n    json: (data) => JSON.parse(data)\n};\n\nconst supportedExtensions = {\n    yaml: parsers.yaml,\n    yml: parsers.yaml,\n    json: parsers.json\n};\n\nexports.sourceNodes = (props, pluginOptions = {}) => {\n    const createContentDigest = props.createContentDigest;\n    const { createNode } = props.actions;\n    const reporter = props.reporter;\n\n    if (!_.get(pluginOptions, 'path')) {\n        pluginOptions.path = 'src/data';\n    }\n\n    if (!path.isAbsolute(pluginOptions.path)) {\n        pluginOptions.path = path.resolve(process.cwd(), pluginOptions.path);\n    }\n\n    reporter.info(`[gatsby-source-data] setup file watcher and create site data`);\n\n    const dataPath = pluginOptions.path;\n    const createSiteDataFromFilesPartial = _.partial(createSiteDataFromFiles, {\n        dataPath,\n        createNode,\n        createContentDigest,\n        reporter\n    });\n    const watcher = chokidar.watch([dataPath, metadataFileName], {\n        cwd: '.',\n        ignoreInitial: true\n    });\n    watcher.on('add', createSiteDataFromFilesPartial);\n    watcher.on('change', createSiteDataFromFilesPartial);\n    watcher.on('unlink', createSiteDataFromFilesPartial);\n\n    return createSiteDataFromFiles({ dataPath, createNode, createContentDigest, reporter }, null);\n};\n\nasync function createSiteDataFromFiles({ dataPath, createNode, createContentDigest, reporter }, changedFile) {\n    reporter.info(`[gatsby-source-data] create site data from files, updated path: ${changedFile}`);\n    let dataFiles = [];\n\n    const dataPathExists = await fse.pathExists(dataPath);\n    if (dataPathExists) {\n        dataFiles = await readDirRecursively(dataPath);\n    }\n\n    const metadataPath = path.resolve(metadataFileName);\n    const metadataExists = await fse.pathExists(metadataPath);\n    if (metadataExists) {\n        dataFiles.push(metadataFileName);\n    }\n\n    const sortedDataFiles = dataFiles.slice().sort();\n    const data = await convertDataFilesToJSON(sortedDataFiles, dataPath, reporter);\n\n    createNode({\n        id: 'SiteData',\n        parent: null,\n        children: [],\n        data: data,\n        internal: {\n            type: 'SiteData',\n            contentDigest: createContentDigest(JSON.stringify(data)),\n            description: `Site data from ${path.relative(process.cwd(), dataPath)}`\n        }\n    });\n}\n\nasync function readDirRecursively(dir, options) {\n    const rootDir = _.get(options, 'rootDir', dir);\n    const files = await fse.readdir(dir);\n    const promises = _.map(files, async (file) => {\n        const filePath = path.join(dir, file);\n        const stats = await fse.stat(filePath);\n        if (stats.isDirectory()) {\n            return readDirRecursively(filePath, { rootDir });\n        } else if (stats.isFile()) {\n            return path.relative(rootDir, filePath);\n        } else {\n            return null;\n        }\n    });\n    const recFiles = await Promise.all(promises);\n    return _.chain(recFiles).compact().flatten().value();\n}\n\nfunction convertDataFilesToJSON(dataFiles, dataDirPath, reporter) {\n    let promises = _.map(dataFiles, (filePath) => {\n        const pathObject = path.parse(filePath);\n        const absFilePath = pathObject.base === metadataFileName ? metadataFileName : path.join(dataDirPath, filePath);\n        const relPath = pathObject.base === metadataFileName ? metadataFileName : filePath;\n        const relDir = pathObject.base === metadataFileName ? '' : pathObject.dir;\n        const ext = pathObject.ext.substring(1);\n        if (!_.has(supportedExtensions, ext)) {\n            return null;\n        }\n        return fse.readFile(absFilePath).then((data) => {\n            const propPath = _.compact(relDir.split(path.sep).concat(pathObject.name));\n            const res = {};\n            try {\n                const parsedData = supportedExtensions[ext](data);\n                _.set(res, propPath, parsedData);\n            } catch (err) {\n                reporter.warn(`[gatsby-source-data] could not parse file: ${relPath}`);\n            }\n            return res;\n        });\n    });\n    return Promise.all(promises).then((results) => {\n        return _.reduce(results, (data, res) => _.merge(data, res), {});\n    });\n}\n"}],"position":{"start":{"line":191,"column":1,"offset":6636},"end":{"line":319,"column":4,"offset":11121}}}],"position":{"start":{"line":191,"column":1,"offset":6636},"end":{"line":319,"column":4,"offset":11121}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"</pre>\n"}],"position":{"start":{"line":321,"column":1,"offset":11123},"end":{"line":323,"column":4,"offset":11147}}}],"position":{"start":{"line":321,"column":1,"offset":11123},"end":{"line":323,"column":4,"offset":11147}}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":324,"column":1,"offset":11148}}}}