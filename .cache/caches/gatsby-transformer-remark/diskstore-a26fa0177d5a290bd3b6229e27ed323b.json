{"expireTime":9007200911206587000,"key":"transformer-remark-markdown-html-6094ca5094bb91de7464e599b2d0c718-gatsby-remark-prismjs-","val":"<h1>async function</h1>\n<p>An async function is a function declared with the <code class=\"language-text\">async</code> keyword, and the <code class=\"language-text\">await</code> keyword is permitted within them. The <code class=\"language-text\">async</code> and <code class=\"language-text\">await</code> keywords enable asynchronous, promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains.</p>\n<p>Async functions may also be defined <a href=\"../operators/async_function\">as expressions</a>.</p>\n<h2>Syntax</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">async function name([param[, param[, ...param]]]) {\n   statements\n}</code></pre></div>\n<h3>Parameters</h3>\n<p><code class=\"language-text\">name</code>\nThe function's name.</p>\n<p><code class=\"language-text\">param</code>\nThe name of an argument to be passed to the function.</p>\n<p><code class=\"language-text\">statements</code>\nThe statements comprising the body of the function. The <code class=\"language-text\">await</code> mechanism may be used.</p>\n<h3>Return value</h3>\n<p>A <a href=\"../global_objects/promise\"><code class=\"language-text\">Promise</code></a> which will be resolved with the value returned by the async function, or rejected with an exception thrown from, or uncaught within, the async function.</p>\n<h2>Description</h2>\n<p>Async functions can contain zero or more <a href=\"../operators/await\"><code class=\"language-text\">await</code></a> expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of <code class=\"language-text\">async</code> and <code class=\"language-text\">await</code> enables the use of ordinary <code class=\"language-text\">try</code> / <code class=\"language-text\">catch</code> blocks around asynchronous code.</p>\n<p><strong>Note:</strong> The <code class=\"language-text\">await</code> keyword is only valid inside async functions within regular JavaScript code. If you use it outside of an async function's body, you will get a <a href=\"../global_objects/syntaxerror\"><code class=\"language-text\">SyntaxError</code></a>.</p>\n<p><code class=\"language-text\">await</code> can be used on its own with <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\">JavaScript modules.</a></p>\n<p><strong>Note:</strong> The purpose of <code class=\"language-text\">async</code>/<code class=\"language-text\">await</code> is to simplify the syntax necessary to consume promise-based APIs. The behavior of <code class=\"language-text\">async</code>/<code class=\"language-text\">await</code> is similar to combining <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\">generators</a> and promises.</p>\n<p>Async functions always return a promise. If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise.</p>\n<p>For example, the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">async function foo() {\n   return 1\n}</code></pre></div>\n<p>...is similar to:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function foo() {\n   return Promise.resolve(1)\n}</code></pre></div>\n<p><strong>Checking equality with <code class=\"language-text\">Promise.resolve</code> vs <code class=\"language-text\">async</code> return</strong></p>\n<p>Even though the return value of an async function behaves as if it's wrapped in a <code class=\"language-text\">Promise.resolve</code>, they are not equivalent.</p>\n<p>An async function will return a different <em>reference</em>, whereas <code class=\"language-text\">Promise.resolve</code> returns the same reference if the given value is a promise.</p>\n<p>It can be a problem when you want to check the equality of a promise and a return value of an async function.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const p = new Promise((res, rej) => {\n  res(1);\n})\n\nasync function asyncReturn() {\n  return p;\n}\n\nfunction basicReturn() {\n  return Promise.resolve(p);\n}\n\nconsole.log(p === basicReturn()); // true\nconsole.log(p === asyncReturn()); // false</code></pre></div>\n<p>The body of an async function can be thought of as being split by zero or more await expressions. Top-level code, up to and including the first await expression (if there is one), is run synchronously. In this way, an async function without an await expression will run synchronously. If there is an await expression inside the function body, however, the async function will always complete asynchronously.</p>\n<p>For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">async function foo() {\n   await 1\n}</code></pre></div>\n<p>...is equivalent to:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function foo() {\n   return Promise.resolve(1).then(() => undefined)\n}</code></pre></div>\n<p>Code after each await expression can be thought of as existing in a <code class=\"language-text\">.then</code> callback. In this way a promise chain is progressively constructed with each reentrant step through the function. The return value forms the final link in the chain.</p>\n<p>In the following example, we successively await two promises. Progress moves through function <code class=\"language-text\">foo</code> in three stages.</p>\n<ol>\n<li>The first line of the body of function <code class=\"language-text\">foo</code> is executed synchronously, with the await expression configured with the pending promise. Progress through <code class=\"language-text\">foo</code> is then suspended and control is yielded back to the function that called <code class=\"language-text\">foo</code>.</li>\n<li>Some time later, when the first promise has either been fulfilled or rejected, control moves back into <code class=\"language-text\">foo</code>. The result of the first promise fulfillment (if it was not rejected) is returned from the await expression. Here <code class=\"language-text\">1</code> is assigned to <code class=\"language-text\">result1</code>. Progress continues, and the second await expression is evaluated. Again, progress through <code class=\"language-text\">foo</code> is suspended and control is yielded.</li>\n<li>Some time later, when the second promise has either been fulfilled or rejected, control re-enters <code class=\"language-text\">foo</code>. The result of the second promise resolution is returned from the second await expression. Here <code class=\"language-text\">2</code> is assigned to <code class=\"language-text\">result2</code>. Control moves to the return expression (if any). The default return value of <code class=\"language-text\">undefined</code> is returned as the resolution value of the current promise.</li>\n</ol>\n<!-- -->\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">async function foo() {\n   const result1 = await new Promise((resolve) => setTimeout(() => resolve('1')))\n   const result2 = await new Promise((resolve) => setTimeout(() => resolve('2')))\n}\nfoo()</code></pre></div>\n<p>Note how the promise chain is not built-up in one go. Instead, the promise chain is constructed in stages as control is successively yielded from and returned to the async function. As a result, we must be mindful of error handling behavior when dealing with concurrent asynchronous operations.</p>\n<p>For example, in the following code an unhandled promise rejection error will be thrown, even if a <code class=\"language-text\">.catch</code> handler has been configured further along the promise chain. This is because <code class=\"language-text\">p2</code> will not be \"wired into\" the promise chain until control returns from <code class=\"language-text\">p1</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">async function foo() {\n   const p1 = new Promise((resolve) => setTimeout(() => resolve('1'), 1000))\n   const p2 = new Promise((_,reject) => setTimeout(() => reject('2'), 500))\n   const results = [await p1, await p2] // Do not do this! Use Promise.all or Promise.allSettled instead.\n}\nfoo().catch(() => {}) // Attempt to swallow all errors...</code></pre></div>\n<h2>Examples</h2>\n<h3>Async functions and execution order</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function resolveAfter2Seconds() {\n  console.log(\"starting slow promise\")\n  return new Promise(resolve => {\n    setTimeout(function() {\n      resolve(\"slow\")\n      console.log(\"slow promise is done\")\n    }, 2000)\n  })\n}\n\nfunction resolveAfter1Second() {\n  console.log(\"starting fast promise\")\n  return new Promise(resolve => {\n    setTimeout(function() {\n      resolve(\"fast\")\n      console.log(\"fast promise is done\")\n    }, 1000)\n  })\n}\n\nasync function sequentialStart() {\n  console.log('==SEQUENTIAL START==')\n\n  // 1. Execution gets here almost instantly\n  const slow = await resolveAfter2Seconds()\n  console.log(slow) // 2. this runs 2 seconds after 1.\n\n  const fast = await resolveAfter1Second()\n  console.log(fast) // 3. this runs 3 seconds after 1.\n}\n\nasync function concurrentStart() {\n  console.log('==CONCURRENT START with await==');\n  const slow = resolveAfter2Seconds() // starts timer immediately\n  const fast = resolveAfter1Second() // starts timer immediately\n\n  // 1. Execution gets here almost instantly\n  console.log(await slow) // 2. this runs 2 seconds after 1.\n  console.log(await fast) // 3. this runs 2 seconds after 1., immediately after 2., since fast is already resolved\n}\n\nfunction concurrentPromise() {\n  console.log('==CONCURRENT START with Promise.all==')\n  return Promise.all([resolveAfter2Seconds(), resolveAfter1Second()]).then((messages) => {\n    console.log(messages[0]) // slow\n    console.log(messages[1]) // fast\n  })\n}\n\nasync function parallel() {\n  console.log('==PARALLEL with await Promise.all==')\n\n  // Start 2 \"jobs\" in parallel and wait for both of them to complete\n  await Promise.all([\n      (async()=>console.log(await resolveAfter2Seconds()))(),\n      (async()=>console.log(await resolveAfter1Second()))()\n  ])\n}\n\nsequentialStart() // after 2 seconds, logs \"slow\", then after 1 more second, \"fast\"\n\n// wait above to finish\nsetTimeout(concurrentStart, 4000) // after 2 seconds, logs \"slow\" and then \"fast\"\n\n// wait again\nsetTimeout(concurrentPromise, 7000) // same as concurrentStart\n\n// wait again\nsetTimeout(parallel, 10000) // truly parallel: after 1 second, logs \"fast\", then after 1 more second, \"slow\"</code></pre></div>\n<h4>await and parallelism</h4>\n<p>In <code class=\"language-text\">sequentialStart</code>, execution suspends 2 seconds for the first <code class=\"language-text\">await</code>, and then another second for the second <code class=\"language-text\">await</code>. The second timer is not created until the first has already fired, so the code finishes after 3 seconds.</p>\n<p>In <code class=\"language-text\">concurrentStart</code>, both timers are created and then <code class=\"language-text\">await</code>ed. The timers run concurrently, which means the code finishes in 2 rather than 3 seconds, i.e. the slowest timer.\nHowever, the <code class=\"language-text\">await</code> calls still run in series, which means the second <code class=\"language-text\">await</code> will wait for the first one to finish. In this case, the result of the fastest timer is processed after the slowest.</p>\n<p>If you wish to safely perform two or more jobs in parallel, you must await a call to <code class=\"language-text\">Promise.all</code>, or <code class=\"language-text\">Promise.allSettled</code>.</p>\n<p><strong>Warning:</strong> The functions <code class=\"language-text\">concurrentStart</code> and <code class=\"language-text\">concurrentPromise</code> are not functionally equivalent.</p>\n<p>In <code class=\"language-text\">concurrentStart</code>, if promise <code class=\"language-text\">fast</code> rejects before promise <code class=\"language-text\">slow</code> is fulfilled, then an unhandled promise rejection error will be raised, regardless of whether the caller has configured a catch clause.</p>\n<p>In <code class=\"language-text\">concurrentPromise,</code> <code class=\"language-text\">Promise.all</code> wires up the promise chain in one go, meaning that the operation will fail-fast regardless of the order of rejection of the promises, and the error will always occur within the configured promise chain, enabling it to be caught in the normal way.</p>\n<h3>Rewriting a Promise chain with an async function</h3>\n<p>An API that returns a <a href=\"../global_objects/promise\"><code class=\"language-text\">Promise</code></a> will result in a promise chain, and it splits the function into many parts. Consider the following code:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getProcessedData(url) {\n  return downloadData(url) // returns a promise\n    .catch(e => {\n      return downloadFallbackData(url)  // returns a promise\n    })\n    .then(v => {\n      return processDataInWorker(v)  // returns a promise\n    })\n}</code></pre></div>\n<p>it can be rewritten with a single async function as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">async function getProcessedData(url) {\n  let v\n  try {\n    v = await downloadData(url)\n  } catch(e) {\n    v = await downloadFallbackData(url)\n  }\n  return processDataInWorker(v)\n}</code></pre></div>\n<p>In the above example, notice there is no <code class=\"language-text\">await</code> statement after the <code class=\"language-text\">return</code> keyword, although that would be valid too: The return value of an <code class=\"language-text\">async function</code> is implicitly wrapped in <a href=\"../global_objects/promise/resolve\"><code class=\"language-text\">Promise.resolve</code></a> - if it's not already a promise itself (as in this example).</p>\n<p><strong>Note:</strong> The implicit wrapping of return values in <a href=\"../global_objects/promise/resolve\"><code class=\"language-text\">Promise.resolve</code></a> does not imply that <code class=\"language-text\">return await promiseValue</code> is functionally equivalent to <code class=\"language-text\">return promiseValue</code>.</p>\n<p>Consider the following rewrite of the above code. It returns <code class=\"language-text\">null</code> if <code class=\"language-text\">processDataInWorker</code> rejects with an error:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">async function getProcessedData(url) {\n  let v\n  try {\n    v = await downloadData(url)\n  } catch(e) {\n    v = await downloadFallbackData(url)\n  }\n  try {\n    return await processDataInWorker(v)  // Note the `return await` vs. just `return`\n  } catch (e) {\n    return null\n  }\n}</code></pre></div>\n<p>Writing <code class=\"language-text\">return processDataInWorker(v)</code> would have caused the <a href=\"../global_objects/promise\"><code class=\"language-text\">Promise</code></a> returned by the function to reject, instead of resolving to <code class=\"language-text\">null</code> if <code class=\"language-text\">processDataInWorker(v)</code> rejects.</p>\n<p>This highlights the subtle difference between <code class=\"language-text\">return foo;</code> and <code class=\"language-text\">return await foo;</code> â€” <code class=\"language-text\">return foo</code> immediately returns <code class=\"language-text\">foo</code> and never throws, even if <code class=\"language-text\">foo</code> is a Promise that rejects. <code class=\"language-text\">return await foo</code> will <em>wait</em> for <code class=\"language-text\">foo</code> to resolve or reject if it's a Promise, and throws <strong>before returning</strong> if it rejects.</p>"}