{"expireTime":9007200911206577000,"key":"transformer-remark-markdown-ast-1316c3a4b36398e1e583ecf4a4a73729-gatsby-remark-prismjs-","val":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Regular expressions make light work of ","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":40,"offset":41},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"single-character delimiters","position":{"start":{"line":3,"column":42,"offset":43},"end":{"line":3,"column":69,"offset":70},"indent":[]}}],"position":{"start":{"line":3,"column":40,"offset":41},"end":{"line":3,"column":71,"offset":72},"indent":[]}},{"type":"text","value":", which is why it's so easy to remove markup from a string:","position":{"start":{"line":3,"column":71,"offset":72},"end":{"line":3,"column":130,"offset":131},"indent":[]}}],"position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":130,"offset":131},"indent":[]}},{"type":"html","lang":null,"meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">str = str.replace(/(&lt;[\\/]?[^>]+>)/g, '');</code></pre></div>","position":{"start":{"line":5,"column":1,"offset":133},"end":{"line":7,"column":4,"offset":182},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"It's the negation in the character class that does the real work:","position":{"start":{"line":9,"column":1,"offset":184},"end":{"line":9,"column":66,"offset":249},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":184},"end":{"line":9,"column":66,"offset":249},"indent":[]}},{"type":"html","lang":null,"meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[^>]</code></pre></div>","position":{"start":{"line":11,"column":1,"offset":251},"end":{"line":13,"column":4,"offset":263},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Which means ","position":{"start":{"line":15,"column":1,"offset":265},"end":{"line":15,"column":13,"offset":277},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"\"anything except ","position":{"start":{"line":15,"column":14,"offset":278},"end":{"line":15,"column":31,"offset":295},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">&lt;</code>","position":{"start":{"line":15,"column":31,"offset":295},"end":{"line":15,"column":34,"offset":298},"indent":[]}},{"type":"text","value":"\"","position":{"start":{"line":15,"column":34,"offset":298},"end":{"line":15,"column":35,"offset":299},"indent":[]}}],"position":{"start":{"line":15,"column":13,"offset":277},"end":{"line":15,"column":36,"offset":300},"indent":[]}},{"type":"text","value":". So the expression looks for the starting tag-delimiter and possible slash, then anything except the closing tag-delimiter, and then the delimiter itself. Easy.","position":{"start":{"line":15,"column":36,"offset":300},"end":{"line":15,"column":197,"offset":461},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":265},"end":{"line":15,"column":197,"offset":461},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"However comments are not so simple, because comment delimiters are comprised of ","position":{"start":{"line":17,"column":1,"offset":463},"end":{"line":17,"column":81,"offset":543},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"more than one character","position":{"start":{"line":17,"column":83,"offset":545},"end":{"line":17,"column":106,"offset":568},"indent":[]}}],"position":{"start":{"line":17,"column":81,"offset":543},"end":{"line":17,"column":108,"offset":570},"indent":[]}},{"type":"text","value":". Multi-line comments in CSS and JavaScript, for example, start with ","position":{"start":{"line":17,"column":108,"offset":570},"end":{"line":17,"column":177,"offset":639},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">/*</code>","position":{"start":{"line":17,"column":177,"offset":639},"end":{"line":17,"column":181,"offset":643},"indent":[]}},{"type":"text","value":" and end with ","position":{"start":{"line":17,"column":181,"offset":643},"end":{"line":17,"column":195,"offset":657},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">*/</code>","position":{"start":{"line":17,"column":195,"offset":657},"end":{"line":17,"column":199,"offset":661},"indent":[]}},{"type":"text","value":", but between those two delimiters there could be ","position":{"start":{"line":17,"column":199,"offset":661},"end":{"line":17,"column":249,"offset":711},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"any number of unrelated stars","position":{"start":{"line":17,"column":251,"offset":713},"end":{"line":17,"column":280,"offset":742},"indent":[]}}],"position":{"start":{"line":17,"column":249,"offset":711},"end":{"line":17,"column":282,"offset":744},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":17,"column":282,"offset":744},"end":{"line":17,"column":283,"offset":745},"indent":[]}}],"position":{"start":{"line":17,"column":1,"offset":463},"end":{"line":17,"column":283,"offset":745},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"I often use multiple stars in comments, to indicate the severity of a bug I've just noticed, for example:","position":{"start":{"line":19,"column":1,"offset":747},"end":{"line":19,"column":106,"offset":852},"indent":[]}}],"position":{"start":{"line":19,"column":1,"offset":747},"end":{"line":19,"column":106,"offset":852},"indent":[]}},{"type":"html","lang":null,"meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/*** this is a bug with 3-star severity ***/</code></pre></div>","position":{"start":{"line":21,"column":1,"offset":854},"end":{"line":23,"column":4,"offset":906},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"But if we tried to parse that with a single negation character, it would fail:","position":{"start":{"line":25,"column":1,"offset":908},"end":{"line":25,"column":79,"offset":986},"indent":[]}}],"position":{"start":{"line":25,"column":1,"offset":908},"end":{"line":25,"column":79,"offset":986},"indent":[]}},{"type":"html","lang":null,"meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">str = str.replace(/(\\/\\*[^\\*]+\\*\\/)/g, '');</code></pre></div>","position":{"start":{"line":27,"column":1,"offset":988},"end":{"line":29,"column":4,"offset":1039},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Yet it's not possible with regular expressions to say: ","position":{"start":{"line":31,"column":1,"offset":1041},"end":{"line":31,"column":56,"offset":1096},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"\"anything except ","position":{"start":{"line":31,"column":57,"offset":1097},"end":{"line":31,"column":74,"offset":1114},"indent":[]}},{"type":"text","value":"[","position":{"start":{"line":31,"column":74,"offset":1114},"end":{"line":31,"column":76,"offset":1116},"indent":[]}},{"type":"text","value":"this sequence of characters","position":{"start":{"line":31,"column":76,"offset":1116},"end":{"line":31,"column":103,"offset":1143},"indent":[]}},{"type":"text","value":"]","position":{"start":{"line":31,"column":103,"offset":1143},"end":{"line":31,"column":105,"offset":1145},"indent":[]}},{"type":"text","value":"\"","position":{"start":{"line":31,"column":105,"offset":1145},"end":{"line":31,"column":106,"offset":1146},"indent":[]}}],"position":{"start":{"line":31,"column":56,"offset":1096},"end":{"line":31,"column":107,"offset":1147},"indent":[]}},{"type":"text","value":", we can only say: ","position":{"start":{"line":31,"column":107,"offset":1147},"end":{"line":31,"column":126,"offset":1166},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"\"anything except ","position":{"start":{"line":31,"column":127,"offset":1167},"end":{"line":31,"column":144,"offset":1184},"indent":[]}},{"type":"text","value":"[","position":{"start":{"line":31,"column":144,"offset":1184},"end":{"line":31,"column":146,"offset":1186},"indent":[]}},{"type":"text","value":"one of these single characters","position":{"start":{"line":31,"column":146,"offset":1186},"end":{"line":31,"column":176,"offset":1216},"indent":[]}},{"type":"text","value":"]","position":{"start":{"line":31,"column":176,"offset":1216},"end":{"line":31,"column":178,"offset":1218},"indent":[]}},{"type":"text","value":"\"","position":{"start":{"line":31,"column":178,"offset":1218},"end":{"line":31,"column":179,"offset":1219},"indent":[]}}],"position":{"start":{"line":31,"column":126,"offset":1166},"end":{"line":31,"column":180,"offset":1220},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":31,"column":180,"offset":1220},"end":{"line":31,"column":181,"offset":1221},"indent":[]}}],"position":{"start":{"line":31,"column":1,"offset":1041},"end":{"line":31,"column":181,"offset":1221},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"So here's the regular expression we need instead:","position":{"start":{"line":33,"column":1,"offset":1223},"end":{"line":33,"column":50,"offset":1272},"indent":[]}}],"position":{"start":{"line":33,"column":1,"offset":1223},"end":{"line":33,"column":50,"offset":1272},"indent":[]}},{"type":"html","lang":null,"meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">str = str.replace(/(\\/\\*([^*]|(\\*+[^*\\/]))*\\*+\\/)/gm, '');</code></pre></div>","position":{"start":{"line":35,"column":1,"offset":1274},"end":{"line":37,"column":4,"offset":1340},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The expression handles unrelated characters by ","position":{"start":{"line":39,"column":1,"offset":1342},"end":{"line":39,"column":48,"offset":1389},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"looking at what comes after them","position":{"start":{"line":39,"column":50,"offset":1391},"end":{"line":39,"column":82,"offset":1423},"indent":[]}}],"position":{"start":{"line":39,"column":48,"offset":1389},"end":{"line":39,"column":84,"offset":1425},"indent":[]}},{"type":"text","value":" — stars are allowed as long as they're not followed by a slash, until we find one that is, and that's the end of the comment.","position":{"start":{"line":39,"column":84,"offset":1425},"end":{"line":39,"column":210,"offset":1551},"indent":[]}}],"position":{"start":{"line":39,"column":1,"offset":1342},"end":{"line":39,"column":210,"offset":1551},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"So it says: \"","position":{"start":{"line":41,"column":1,"offset":1553},"end":{"line":41,"column":14,"offset":1566},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">/</code>","position":{"start":{"line":41,"column":14,"offset":1566},"end":{"line":41,"column":17,"offset":1569},"indent":[]}},{"type":"text","value":" then ","position":{"start":{"line":41,"column":17,"offset":1569},"end":{"line":41,"column":23,"offset":1575},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">*</code>","position":{"start":{"line":41,"column":23,"offset":1575},"end":{"line":41,"column":26,"offset":1578},"indent":[]}},{"type":"text","value":" (then anything except ","position":{"start":{"line":41,"column":26,"offset":1578},"end":{"line":41,"column":49,"offset":1601},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">*</code>","position":{"start":{"line":41,"column":49,"offset":1601},"end":{"line":41,"column":52,"offset":1604},"indent":[]}},{"type":"text","value":" OR any number of ","position":{"start":{"line":41,"column":52,"offset":1604},"end":{"line":41,"column":70,"offset":1622},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">*</code>","position":{"start":{"line":41,"column":70,"offset":1622},"end":{"line":41,"column":73,"offset":1625},"indent":[]}},{"type":"text","value":" followed by anything except ","position":{"start":{"line":41,"column":73,"offset":1625},"end":{"line":41,"column":102,"offset":1654},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">/</code>","position":{"start":{"line":41,"column":102,"offset":1654},"end":{"line":41,"column":105,"offset":1657},"indent":[]}},{"type":"text","value":")(and any number of instances of that) then any number of ","position":{"start":{"line":41,"column":105,"offset":1657},"end":{"line":41,"column":163,"offset":1715},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">*</code>","position":{"start":{"line":41,"column":163,"offset":1715},"end":{"line":41,"column":166,"offset":1718},"indent":[]}},{"type":"text","value":" then ","position":{"start":{"line":41,"column":166,"offset":1718},"end":{"line":41,"column":172,"offset":1724},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">/</code>","position":{"start":{"line":41,"column":172,"offset":1724},"end":{"line":41,"column":175,"offset":1727},"indent":[]}},{"type":"text","value":"\".","position":{"start":{"line":41,"column":175,"offset":1727},"end":{"line":41,"column":177,"offset":1729},"indent":[]}}],"position":{"start":{"line":41,"column":1,"offset":1553},"end":{"line":41,"column":177,"offset":1729},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"(The syntax looks particular convoluted, because ","position":{"start":{"line":43,"column":1,"offset":1731},"end":{"line":43,"column":50,"offset":1780},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">*</code>","position":{"start":{"line":43,"column":50,"offset":1780},"end":{"line":43,"column":53,"offset":1783},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":43,"column":53,"offset":1783},"end":{"line":43,"column":58,"offset":1788},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">/</code>","position":{"start":{"line":43,"column":58,"offset":1788},"end":{"line":43,"column":61,"offset":1791},"indent":[]}},{"type":"text","value":" are both special characters in regular expressions, so the ambiguous literal ones have to be escaped. Also note the ","position":{"start":{"line":43,"column":61,"offset":1791},"end":{"line":43,"column":178,"offset":1908},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">m</code>","position":{"start":{"line":43,"column":178,"offset":1908},"end":{"line":43,"column":181,"offset":1911},"indent":[]}},{"type":"text","value":" flag at the end of the expression, which means ","position":{"start":{"line":43,"column":181,"offset":1911},"end":{"line":43,"column":229,"offset":1959},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"multi-line","position":{"start":{"line":43,"column":231,"offset":1961},"end":{"line":43,"column":241,"offset":1971},"indent":[]}}],"position":{"start":{"line":43,"column":229,"offset":1959},"end":{"line":43,"column":243,"offset":1973},"indent":[]}},{"type":"text","value":", and specifies that the regular expression should search across more than one line of text.)","position":{"start":{"line":43,"column":243,"offset":1973},"end":{"line":43,"column":336,"offset":2066},"indent":[]}}],"position":{"start":{"line":43,"column":1,"offset":1731},"end":{"line":43,"column":336,"offset":2066},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Using the same principle then, we can adapt the expression to search for any kind of complex delimiters. Here's another one that matches HTML comments:","position":{"start":{"line":45,"column":1,"offset":2068},"end":{"line":45,"column":152,"offset":2219},"indent":[]}}],"position":{"start":{"line":45,"column":1,"offset":2068},"end":{"line":45,"column":152,"offset":2219},"indent":[]}},{"type":"html","lang":null,"meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">str = str.replace(/(&lt;!\\-\\-([^\\-]|(\\-+[^>]))*\\-+>)/gm, '');</code></pre></div>","position":{"start":{"line":47,"column":1,"offset":2221},"end":{"line":49,"column":4,"offset":2287},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"And here's one for ","position":{"start":{"line":51,"column":1,"offset":2289},"end":{"line":51,"column":20,"offset":2308},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">CDATA</code>","position":{"start":{"line":51,"column":20,"offset":2308},"end":{"line":51,"column":27,"offset":2315},"indent":[]}},{"type":"text","value":" sections:","position":{"start":{"line":51,"column":27,"offset":2315},"end":{"line":51,"column":37,"offset":2325},"indent":[]}}],"position":{"start":{"line":51,"column":1,"offset":2289},"end":{"line":51,"column":37,"offset":2325},"indent":[]}},{"type":"html","lang":null,"meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">str = str.replace(/(&lt;\\!\\[CDATA\\[([^\\]]|(\\]+[^>]))*\\]+>)/gm, '');</code></pre></div>","position":{"start":{"line":53,"column":1,"offset":2327},"end":{"line":55,"column":4,"offset":2399},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"2","position":{"start":{"line":57,"column":4,"offset":2404},"end":{"line":57,"column":5,"offset":2405},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":57,"column":5,"offset":2405},"end":{"line":57,"column":7,"offset":2407},"indent":[]}},{"type":"text","value":" Using Replacement Callbacks","position":{"start":{"line":57,"column":7,"offset":2407},"end":{"line":57,"column":35,"offset":2435},"indent":[]}}],"position":{"start":{"line":57,"column":1,"offset":2401},"end":{"line":57,"column":35,"offset":2435},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":59,"column":1,"offset":2437},"end":{"line":59,"column":5,"offset":2441},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">replace</code>","position":{"start":{"line":59,"column":5,"offset":2441},"end":{"line":59,"column":14,"offset":2450},"indent":[]}},{"type":"text","value":" function can also be ","position":{"start":{"line":59,"column":14,"offset":2450},"end":{"line":59,"column":36,"offset":2472},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"passed a callback","position":{"start":{"line":59,"column":38,"offset":2474},"end":{"line":59,"column":55,"offset":2491},"indent":[]}}],"position":{"start":{"line":59,"column":36,"offset":2472},"end":{"line":59,"column":57,"offset":2493},"indent":[]}},{"type":"text","value":" as its second parameter, and this is invaluable in cases where the replacement you want can't be described in a simple expression. For example:","position":{"start":{"line":59,"column":57,"offset":2493},"end":{"line":59,"column":201,"offset":2637},"indent":[]}}],"position":{"start":{"line":59,"column":1,"offset":2437},"end":{"line":59,"column":201,"offset":2637},"indent":[]}},{"type":"html","lang":"js","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">//</span>\nisocode <span class=\"token operator\">=</span> isocode<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^([a-z]+)(\\-[a-z]+)?$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">i</span></span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">match<span class=\"token punctuation\">,</span> lang<span class=\"token punctuation\">,</span> country</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> lang<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>country <span class=\"token operator\">?</span> country<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","position":{"start":{"line":61,"column":1,"offset":2639},"end":{"line":66,"column":4,"offset":2813},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"That example normalizes the capitalisation in language codes — so ","position":{"start":{"line":68,"column":1,"offset":2815},"end":{"line":68,"column":67,"offset":2881},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">\"EN\"</code>","position":{"start":{"line":68,"column":67,"offset":2881},"end":{"line":68,"column":73,"offset":2887},"indent":[]}},{"type":"text","value":" would become ","position":{"start":{"line":68,"column":73,"offset":2887},"end":{"line":68,"column":87,"offset":2901},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">\"en\"</code>","position":{"start":{"line":68,"column":87,"offset":2901},"end":{"line":68,"column":93,"offset":2907},"indent":[]}},{"type":"text","value":", while ","position":{"start":{"line":68,"column":93,"offset":2907},"end":{"line":68,"column":101,"offset":2915},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">\"en-us\"</code>","position":{"start":{"line":68,"column":101,"offset":2915},"end":{"line":68,"column":110,"offset":2924},"indent":[]}},{"type":"text","value":" would become ","position":{"start":{"line":68,"column":110,"offset":2924},"end":{"line":68,"column":124,"offset":2938},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">\"en-US\"</code>","position":{"start":{"line":68,"column":124,"offset":2938},"end":{"line":68,"column":133,"offset":2947},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":68,"column":133,"offset":2947},"end":{"line":68,"column":134,"offset":2948},"indent":[]}}],"position":{"start":{"line":68,"column":1,"offset":2815},"end":{"line":68,"column":134,"offset":2948},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The first argument that's passed to the callback is always the complete match, then each subsequent argument corresponds with the backreferences (i.e. ","position":{"start":{"line":70,"column":1,"offset":2950},"end":{"line":70,"column":152,"offset":3101},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">arguments[1]</code>","position":{"start":{"line":70,"column":152,"offset":3101},"end":{"line":70,"column":166,"offset":3115},"indent":[]}},{"type":"text","value":" is what a string replacement would refer to as ","position":{"start":{"line":70,"column":166,"offset":3115},"end":{"line":70,"column":214,"offset":3163},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">$1</code>","position":{"start":{"line":70,"column":214,"offset":3163},"end":{"line":70,"column":218,"offset":3167},"indent":[]}},{"type":"text","value":", and so on).","position":{"start":{"line":70,"column":218,"offset":3167},"end":{"line":70,"column":231,"offset":3180},"indent":[]}}],"position":{"start":{"line":70,"column":1,"offset":2950},"end":{"line":70,"column":231,"offset":3180},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"So taking ","position":{"start":{"line":72,"column":1,"offset":3182},"end":{"line":72,"column":11,"offset":3192},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">\"en-us\"</code>","position":{"start":{"line":72,"column":11,"offset":3192},"end":{"line":72,"column":20,"offset":3201},"indent":[]}},{"type":"text","value":" as the input, we'd get the three arguments:","position":{"start":{"line":72,"column":20,"offset":3201},"end":{"line":72,"column":64,"offset":3245},"indent":[]}}],"position":{"start":{"line":72,"column":1,"offset":3182},"end":{"line":72,"column":64,"offset":3245},"indent":[]}},{"type":"list","ordered":true,"start":0,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"html","value":"<code class=\"language-text\">\"en-us\"</code>","position":{"start":{"line":74,"column":5,"offset":3251},"end":{"line":74,"column":14,"offset":3260},"indent":[]}}],"position":{"start":{"line":74,"column":5,"offset":3251},"end":{"line":74,"column":14,"offset":3260},"indent":[]}}],"position":{"start":{"line":74,"column":1,"offset":3247},"end":{"line":74,"column":14,"offset":3260},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"html","value":"<code class=\"language-text\">\"en\"</code>","position":{"start":{"line":75,"column":5,"offset":3265},"end":{"line":75,"column":11,"offset":3271},"indent":[]}}],"position":{"start":{"line":75,"column":5,"offset":3265},"end":{"line":75,"column":11,"offset":3271},"indent":[]}}],"position":{"start":{"line":75,"column":1,"offset":3261},"end":{"line":75,"column":11,"offset":3271},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"html","value":"<code class=\"language-text\">\"-us\"</code>","position":{"start":{"line":76,"column":5,"offset":3276},"end":{"line":76,"column":12,"offset":3283},"indent":[]}}],"position":{"start":{"line":76,"column":5,"offset":3276},"end":{"line":76,"column":12,"offset":3283},"indent":[]}}],"position":{"start":{"line":76,"column":1,"offset":3272},"end":{"line":76,"column":12,"offset":3283},"indent":[]}}],"position":{"start":{"line":74,"column":1,"offset":3247},"end":{"line":76,"column":12,"offset":3283},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Then all the function has to do is enforce the appropriate cases, re-combine the parts and return them. Whatever the callback returns is what the replacement itself returns.","position":{"start":{"line":78,"column":1,"offset":3285},"end":{"line":78,"column":174,"offset":3458},"indent":[]}}],"position":{"start":{"line":78,"column":1,"offset":3285},"end":{"line":78,"column":174,"offset":3458},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"But we don't actually have to assign the return value (or return at all), and if we don't, then the original string will be unaffected. This means we can use ","position":{"start":{"line":80,"column":1,"offset":3460},"end":{"line":80,"column":159,"offset":3618},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">replace</code>","position":{"start":{"line":80,"column":159,"offset":3618},"end":{"line":80,"column":168,"offset":3627},"indent":[]}},{"type":"text","value":" as a ","position":{"start":{"line":80,"column":168,"offset":3627},"end":{"line":80,"column":174,"offset":3633},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"general-purpose string processor","position":{"start":{"line":80,"column":176,"offset":3635},"end":{"line":80,"column":208,"offset":3667},"indent":[]}}],"position":{"start":{"line":80,"column":174,"offset":3633},"end":{"line":80,"column":210,"offset":3669},"indent":[]}},{"type":"text","value":" — to extract data from a string without changing it.","position":{"start":{"line":80,"column":210,"offset":3669},"end":{"line":80,"column":263,"offset":3722},"indent":[]}}],"position":{"start":{"line":80,"column":1,"offset":3460},"end":{"line":80,"column":263,"offset":3722},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Here's another example, that combines the multi-line comment expression from the previous section, with a callback that extracts and saves the text of each comment:","position":{"start":{"line":82,"column":1,"offset":3724},"end":{"line":82,"column":165,"offset":3888},"indent":[]}}],"position":{"start":{"line":82,"column":1,"offset":3724},"end":{"line":82,"column":165,"offset":3888},"indent":[]}},{"type":"html","lang":null,"meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let comments = [];\nstr.replace(/(\\/\\*([^*]|(\\*+[^*\\/]))*\\*+\\/)/gm,\n  function(match)\n  {\n    comments.push(match);\n  });</code></pre></div>","position":{"start":{"line":84,"column":1,"offset":3890},"end":{"line":91,"column":4,"offset":4018},"indent":[1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Since nothing is returned, the original string remains unchanged. Although if we wanted to extract ","position":{"start":{"line":93,"column":1,"offset":4020},"end":{"line":93,"column":100,"offset":4119},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"and","position":{"start":{"line":93,"column":101,"offset":4120},"end":{"line":93,"column":104,"offset":4123},"indent":[]}}],"position":{"start":{"line":93,"column":100,"offset":4119},"end":{"line":93,"column":105,"offset":4124},"indent":[]}},{"type":"text","value":" remove the comments, we could simply return and assign an empty-string:","position":{"start":{"line":93,"column":105,"offset":4124},"end":{"line":93,"column":177,"offset":4196},"indent":[]}}],"position":{"start":{"line":93,"column":1,"offset":4020},"end":{"line":93,"column":177,"offset":4196},"indent":[]}},{"type":"html","lang":"js","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">//</span>\n<span class=\"token keyword\">let</span> comments <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nstr <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(\\/\\*([^*]|(\\*+[^*\\/]))*\\*+\\/)</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">gm</span></span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">match</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    comments<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","position":{"start":{"line":95,"column":1,"offset":4198},"end":{"line":102,"column":4,"offset":4347},"indent":[1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"3","position":{"start":{"line":104,"column":4,"offset":4352},"end":{"line":104,"column":5,"offset":4353},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":104,"column":5,"offset":4353},"end":{"line":104,"column":7,"offset":4355},"indent":[]}},{"type":"text","value":" Working With Invisible Delimiters","position":{"start":{"line":104,"column":7,"offset":4355},"end":{"line":104,"column":41,"offset":4389},"indent":[]}}],"position":{"start":{"line":104,"column":1,"offset":4349},"end":{"line":104,"column":41,"offset":4389},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Extracting content is all very well when it uses standard delimiters, but what if you're using ","position":{"start":{"line":106,"column":1,"offset":4391},"end":{"line":106,"column":96,"offset":4486},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"custom delimiters","position":{"start":{"line":106,"column":98,"offset":4488},"end":{"line":106,"column":115,"offset":4505},"indent":[]}}],"position":{"start":{"line":106,"column":96,"offset":4486},"end":{"line":106,"column":117,"offset":4507},"indent":[]}},{"type":"text","value":" that only your program knows about? The problem there is that ","position":{"start":{"line":106,"column":117,"offset":4507},"end":{"line":106,"column":180,"offset":4570},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"the string might already contain your delimiter","position":{"start":{"line":106,"column":182,"offset":4572},"end":{"line":106,"column":229,"offset":4619},"indent":[]}}],"position":{"start":{"line":106,"column":180,"offset":4570},"end":{"line":106,"column":231,"offset":4621},"indent":[]}},{"type":"text","value":", literally character for character, and then what do you?","position":{"start":{"line":106,"column":231,"offset":4621},"end":{"line":106,"column":289,"offset":4679},"indent":[]}}],"position":{"start":{"line":106,"column":1,"offset":4391},"end":{"line":106,"column":289,"offset":4679},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Well, recently I came up with a very cute trick, that not only avoids this problem, it's also as simple to use as the single-character class we saw at the start! The trick is to use ","position":{"start":{"line":108,"column":1,"offset":4681},"end":{"line":108,"column":183,"offset":4863},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"unicode characters that the document can't contain","position":{"start":{"line":108,"column":185,"offset":4865},"end":{"line":108,"column":235,"offset":4915},"indent":[]}}],"position":{"start":{"line":108,"column":183,"offset":4863},"end":{"line":108,"column":237,"offset":4917},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":108,"column":237,"offset":4917},"end":{"line":108,"column":238,"offset":4918},"indent":[]}}],"position":{"start":{"line":108,"column":1,"offset":4681},"end":{"line":108,"column":238,"offset":4918},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Originally I tried this with ","position":{"start":{"line":110,"column":1,"offset":4920},"end":{"line":110,"column":30,"offset":4949},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"undefined","position":{"start":{"line":110,"column":31,"offset":4950},"end":{"line":110,"column":40,"offset":4959},"indent":[]}}],"position":{"start":{"line":110,"column":30,"offset":4949},"end":{"line":110,"column":41,"offset":4960},"indent":[]}},{"type":"text","value":" characters, and that certainly worked, but it's not safe to assume that any such character will always be undefined (or that the document won't already contain it anyway). Then I discovered that Unicode actually reserves a set of code-points specifically for this kind of thing — so-called ","position":{"start":{"line":110,"column":41,"offset":4960},"end":{"line":110,"column":332,"offset":5251},"indent":[]}},{"type":"link","title":"Mapping of Unicode Characters (wikipedia.org)","url":"http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Noncharacters","children":[{"type":"text","value":"noncharacters","position":{"start":{"line":110,"column":333,"offset":5252},"end":{"line":110,"column":346,"offset":5265},"indent":[]}}],"position":{"start":{"line":110,"column":332,"offset":5251},"end":{"line":110,"column":469,"offset":5388},"indent":[]}},{"type":"text","value":", which will never be used to define actual characters. A valid Unicode document is not allowed to contain noncharacters, but a program can use them internally for its own purposes.","position":{"start":{"line":110,"column":469,"offset":5388},"end":{"line":110,"column":650,"offset":5569},"indent":[]}}],"position":{"start":{"line":110,"column":1,"offset":4920},"end":{"line":110,"column":650,"offset":5569},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"I was working on CSS processor, and I needed to remove all the comments before parsing the selectors, so they wouldn't confuse the selector-matching expressions. But they had to be replaced in the source with something that took up the same number of lines, so that the line-numbers would remain accurate. Then later they would have to be added back to the source, for final output.","position":{"start":{"line":112,"column":1,"offset":5571},"end":{"line":112,"column":383,"offset":5953},"indent":[]}}],"position":{"start":{"line":112,"column":1,"offset":5571},"end":{"line":112,"column":383,"offset":5953},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"So first we use a regex callback to extract and save the comments. The callback returns a copy of the match in which all non-whitespace is converted to space, and which is delimited with a noncharacter either side:","position":{"start":{"line":114,"column":1,"offset":5955},"end":{"line":114,"column":215,"offset":6169},"indent":[]}}],"position":{"start":{"line":114,"column":1,"offset":5955},"end":{"line":114,"column":215,"offset":6169},"indent":[]}},{"type":"html","lang":null,"meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let comments = [];\ncsstext = csstext.replace(/(\\/\\*([^*]|(\\*+([^*\\/])))*\\*+\\/)/gm,\n  function(match)\n  {\n    comments.push(match);\n    return '\\ufddf' + match.replace(/[\\S]/gim, ' ') + '\\ufddf';\n  });</code></pre></div>","position":{"start":{"line":116,"column":1,"offset":6171},"end":{"line":124,"column":4,"offset":6379},"indent":[1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"That creates an array of comments in the same source-order as the spaces they leave behind, while the spaces themselves take-up as many lines as the original comment.","position":{"start":{"line":126,"column":1,"offset":6381},"end":{"line":126,"column":167,"offset":6547},"indent":[]}}],"position":{"start":{"line":126,"column":1,"offset":6381},"end":{"line":126,"column":167,"offset":6547},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Then the originals can be restored simply by replacing each delimited space with its corresponding saved comment — and since the delimiters are single characters, we only need a ","position":{"start":{"line":128,"column":1,"offset":6549},"end":{"line":128,"column":179,"offset":6727},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"simple character class","position":{"start":{"line":128,"column":181,"offset":6729},"end":{"line":128,"column":203,"offset":6751},"indent":[]}}],"position":{"start":{"line":128,"column":179,"offset":6727},"end":{"line":128,"column":205,"offset":6753},"indent":[]}},{"type":"text","value":" to match each pair:","position":{"start":{"line":128,"column":205,"offset":6753},"end":{"line":128,"column":225,"offset":6773},"indent":[]}}],"position":{"start":{"line":128,"column":1,"offset":6549},"end":{"line":128,"column":225,"offset":6773},"indent":[]}},{"type":"html","lang":null,"meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">csstext = csstext.replace(/(\\ufddf[^\\ufddf]+\\ufddf)/gim,\n  function()\n  {\n    return comments.shift();\n  });</code></pre></div>","position":{"start":{"line":130,"column":1,"offset":6775},"end":{"line":136,"column":4,"offset":6891},"indent":[1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"How easy is that!","position":{"start":{"line":138,"column":1,"offset":6893},"end":{"line":138,"column":18,"offset":6910},"indent":[]}}],"position":{"start":{"line":138,"column":1,"offset":6893},"end":{"line":138,"column":18,"offset":6910},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":139,"column":1,"offset":6911}}}}