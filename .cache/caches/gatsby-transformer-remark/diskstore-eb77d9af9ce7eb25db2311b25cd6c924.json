{"expireTime":9007200908525415000,"key":"transformer-remark-markdown-html-709a80058a53f7e454d49e30fa38d06e--","val":"<h2><a href=\"https://leetcode.com/problems/regular-expression-matching/description/\">10. Regular Expression Matching</a></h2>\n<h3>Problem:</h3>\n<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>'.'</code> and <code>'*'</code>.</p>\n<pre><code>'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n</code></pre>\n<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>\n<p><strong>Note:</strong></p>\n<p><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.\n<code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</p>\n<p><strong>Example 1:</strong></p>\n<pre><code>Input:\ns = \"aa\"\np = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n</code></pre>\n<p><strong>Example 2:</strong></p>\n<pre><code>Input:\ns = \"aa\"\np = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n</code></pre>\n<p><strong>Example 3:</strong></p>\n<pre><code>Input:\ns = \"ab\"\np = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n</code></pre>\n<p><strong>Example 4:</strong></p>\n<pre><code>Input:\ns = \"aab\"\np = \"c*a*b\"\nOutput: true\nExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches \"aab\".\n</code></pre>\n<p><strong>Example 5:</strong></p>\n<pre><code>Input:\ns = \"mississippi\"\np = \"mis*is*p*.\"\nOutput: false\n</code></pre>\n<h3>Solution:</h3>\n<h4>ONE</h4>\n<p>Cheating with real RegExp matching.</p>\n<pre><code class=\"language-js\">/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nlet isMatch = function (s, p) {\n    if (p[0] === '*') {\n        return false;\n    }\n    return new RegExp(`^${p}$`).test(s);\n};\n</code></pre>\n<h4>TWO</h4>\n<p>Let f(i, j) be the matching result of s[0...i) and p[0...j).</p>\n<pre><code class=\"language-js\">f(0, j) =\n    j == 0 || // empty\n    p[j-1] == '*' &#x26;&#x26; f(i, j-2) // matches 0 time, which matches empty string\n\nf(i, 0) = false // pattern must cover the entire input string\n\nf(i, j) =\n    if p[j-1] == '.'\n        f(i-1, j-1)\n    else if p[j-1] == '*'\n        f(i, j-2) || // matches 0 time\n        f(i-1, j) &#x26;&#x26; (s[i-1] == p[j-2] || p[j-2] == '.') // matches 1 or multiple times\n    else\n        f(i-1, j-1) &#x26;&#x26; s[i-1] == p[j-1]\n</code></pre>\n<pre><code class=\"language-js\">/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nlet isMatch = function (s, p) {\n    if (p[0] === '*') {\n        return false;\n    }\n\n    const dp = [[true]];\n\n    for (let j = 2; j &#x3C;= p.length; j++) {\n        dp[0][j] = p[j - 1] === '*' &#x26;&#x26; dp[0][j - 2];\n    }\n\n    for (let i = 1; i &#x3C;= s.length; i++) {\n        dp[i] = [];\n        for (let j = 1; j &#x3C;= p.length; j++) {\n            switch (p[j - 1]) {\n                case '.':\n                    dp[i][j] = dp[i - 1][j - 1];\n                    break;\n                case '*':\n                    dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] &#x26;&#x26; (p[j - 2] === '.' || s[i - 1] === p[j - 2]));\n                    break;\n                default:\n                    dp[i][j] = dp[i - 1][j - 1] &#x26;&#x26; s[i - 1] === p[j - 1];\n            }\n        }\n    }\n\n    return !!dp[s.length][p.length];\n};\n</code></pre>\n<hr>\n<p>☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆</p>\n<hr>\n<hr>\n<p>☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆☆<em>: .｡. o(≧▽≦)o .｡.:</em>☆</p>\n<hr>"}