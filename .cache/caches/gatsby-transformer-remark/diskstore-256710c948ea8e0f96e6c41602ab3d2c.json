{"expireTime":9007200908525415000,"key":"transformer-remark-markdown-html-63e0dc06f51409b9f58514f12d10ed66--","val":"<h2><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#including_keyboard_users\" title=\"Permalink to Including keyboard users\">Including keyboard users</a></h2>\n<p>At this point, we've accomplished all of the features we set out to implement. A user can add a new task, check and uncheck tasks, delete tasks, or edit task names. And they can filter their task list by all, active, or completed tasks.</p>\n<p>Or, at least: they can do all of these things with a mouse. Unfortunately, these features are not very accessible to keyboard-only users. Let's explore this now.</p>\n<h2><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#exploring_the_keyboard_usability_problem\" title=\"Permalink to Exploring the keyboard usability problem\">Exploring the keyboard usability problem</a></h2>\n<p>Start by clicking on the input at the top of our app, as if you're going to add a new task. You'll see a thick, dashed outline around that input. This outline is your visual indicator that the browser is currently focused on this element. Press the Tab key, and you will see the outline appear around the \"Add\" button beneath the input. This shows you that the browser's focus has moved.</p>\n<p>Press Tab a few more times, and you will see this dashed focus indicator move between each of the filter buttons. Keep going until the focus indicator is around the first \"Edit\" button. Press Enter.</p>\n<p>The <code>&#x3C;Todo /></code> component will switch templates, as we designed, and you'll see a form that lets us edit the name of the task.</p>\n<p>But where did our focus indicator go?</p>\n<p>When we switch between templates in our <code>&#x3C;Todo /></code> component, we completely remove the elements that were there before to replace them with something else. That means the element that we were focused on vanishes, and nothing is in focus at all. This could confuse a wide variety of users — particularly users who rely on the keyboard, or users who use a screen reader.</p>\n<p>To improve the experience for keyboard and screen-reader users, we should manage the browser's focus ourselves.</p>\n<h2><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#focusing_between_templates\" title=\"Permalink to Focusing between templates\">Focusing between templates</a></h2>\n<p>When a user toggles a <code>&#x3C;Todo/></code> template from viewing to editing, we should focus on the <code>&#x3C;input></code> used to rename it; when they toggle back from editing to viewing, we should move focus back to the \"Edit\" button.</p>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#targeting_our_elements\" title=\"Permalink to Targeting our elements\">Targeting our elements</a></h3>\n<p>In order to focus on an element in our DOM, we need to tell React which element we want to focus on and how to find it. React's <a href=\"https://reactjs.org/docs/hooks-reference.html#useref\"><code>useRef</code></a> hook creates an object with a single property: <code>current</code>. This property can be a reference to anything we want and look that reference up later. It's particularly useful for referring to DOM elements.</p>\n<p>Change the <code>import</code> statement at the top of <code>Todo.js</code> so that it includes <code>useRef</code>:</p>\n<pre><code>import React, { useRef, useState } from \"react\";\n</code></pre>\n<p>Then, create two new constants beneath the hooks in your <code>Todo()</code> function. Each should be a ref - one for the \"Edit\" button in the view template and one for the edit field in the editing template.</p>\n<pre><code>const editFieldRef = useRef(null);\nconst editButtonRef = useRef(null);\n</code></pre>\n<p>These refs have a default value of <code>null</code> because they will not have value until we attach them to their respective elements. To do that, we'll add an attribute of <code>ref</code> to each element, and set their values to the appropriately named <code>ref</code> objects.</p>\n<p>The textbox <code>&#x3C;input></code> in your editing template should be updated like this:</p>\n<pre><code>&#x3C;input\n  id={props.id}\n  className=\"todo-text\"\n  type=\"text\"\n  value={newName}\n  onChange={handleChange}\n  ref={editFieldRef}\n/>\n</code></pre>\n<p>The \"Edit\" button in your view template should read like this:</p>\n<pre><code>&#x3C;button\n  type=\"button\"\n  className=\"btn\"\n  onClick={() => setEditing(true)}\n  ref={editButtonRef}\n>\n  Edit &#x3C;span className=\"visually-hidden\">{props.name}&#x3C;/span>\n&#x3C;/button>\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#focusing_on_our_refs_with_useeffect\" title=\"Permalink to Focusing on our refs with useEffect\">Focusing on our refs with useEffect</a></h3>\n<p>To use our refs for their intended purpose, we need to import another React hook: <a href=\"https://reactjs.org/docs/hooks-reference.html#useeffect\"><code>useEffect()</code></a>. <code>useEffect()</code> is so named because it runs after React renders a given component, and will run any side-effects that we'd like to add to the render process, which we can't run inside the main function body. <code>useEffect()</code> is useful in the current situation because we cannot focus on an element until after the <code>&#x3C;Todo /></code> component renders and React knows where our refs are.</p>\n<p>Change the import statement of <code>Todo.js</code> again to add <code>useEffect</code>:</p>\n<pre><code>import React, { useEffect, useRef, useState } from \"react\";\n</code></pre>\n<p><code>useEffect()</code> takes a function as an argument; this function is executed after the component renders. Let's see this in action; put the following <code>useEffect()</code> call just above the <code>return</code> statement in the body of <code>Todo()</code>, and pass into it a function that logs the words \"side effect\" to your console:</p>\n<pre><code>useEffect(() => {\n  console.log(\"side effect\");\n});\n</code></pre>\n<p>To illustrate the difference between the main render process and code run inside <code>useEffect()</code>, add another log - put this one below the previous addition:</p>\n<pre><code>console.log(\"main render\");\n</code></pre>\n<p>Now, open the app in your browser. You should see both messages in your console, with each one repeating three times. Note how \"main render\" logged first, and \"side effect\" logged second, even though the \"side effect\" log appears first in the code.</p>\n<pre><code>main render (3)                                     Todo.js:100\nside effect (3)                                     Todo.js:98\n</code></pre>\n<p>That's it for our experimentation for now. Delete <code>console.log(\"main render\")</code> now, and lets move on to implementing our focus management.</p>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#focusing_on_our_editing_field\" title=\"Permalink to Focusing on our editing field\">Focusing on our editing field</a></h3>\n<p>Now that we know our <code>useEffect()</code> hook works, we can manage focus with it. As a reminder, we want to focus on the editing field when we switch to the editing template.</p>\n<p>Update your existing <code>useEffect()</code> hook so that it reads like this:</p>\n<pre><code>useEffect(() => {\n  if (isEditing) {\n    editFieldRef.current.focus();\n  }\n}, [isEditing]);\n</code></pre>\n<p>These changes make it so that, if <code>isEditing</code> is true, React reads the current value of the <code>editFieldRef</code> and moves browser focus to it. We also pass an array into <code>useEffect()</code> as a second argument. This array is a list of values <code>useEffect()</code> should depend on. With these values included, <code>useEffect()</code> will only run when one of those values changes. We only want to change focus when the value of <code>isEditing</code> changes.</p>\n<p>Try it now, and you'll see that when you click an \"Edit\" button, focus moves to the corresponding edit <code>&#x3C;input></code>!</p>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#moving_focus_back_to_the_edit_button\" title=\"Permalink to Moving focus back to the edit button\">Moving focus back to the edit button</a></h3>\n<p>At first glance, getting React to move focus back to our \"Edit\" button when the edit is saved or cancelled appears deceptively easy. Surely we could add a condition to our <code>useEffect</code> to focus on the edit button if <code>isEditing</code> is <code>false</code>? Let's try it now — update your <code>useEffect()</code> call like so:</p>\n<pre><code>useEffect(() => {\n  if (isEditing) {\n    editFieldRef.current.focus();\n  } else {\n    editButtonRef.current.focus();\n  }\n}, [isEditing]);\n</code></pre>\n<p>This kind of mostly works. Head back to your browser and you'll see that your focus moves between Edit <code>&#x3C;input></code> and \"Edit\" button as you start and end an edit. However, you may have noticed a new problem — the \"Edit\" button in the final <code>&#x3C;Todo /></code> component is focussed immediately on page load, before we even interact with the app!</p>\n<p>Our <code>useEffect()</code> hook is behaving exactly as we designed it: it runs as soon as the component renders, sees that <code>isEditing</code> is <code>false</code>, and focuses the \"Edit\" button. Because there are three instances of <code>&#x3C;Todo /></code>, we see focus on the last \"Edit\" button.</p>\n<p>We need to refactor our approach so that focus changes only when <code>isEditing</code> changes from one value to another.</p>\n<h2><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#more_robust_focus_management\" title=\"Permalink to More robust focus management\">More robust focus management</a></h2>\n<p>In order to meet our refined criteria, we need to know not just the value of <code>isEditing</code>, but also <em>when that value has changed</em>. In order to do that, we need to be able to read the previous value of the <code>isEditing</code> constant. Using pseudocode, our logic should be something like this:</p>\n<pre><code>if (wasNotEditingBefore &#x26;&#x26; isEditingNow) {\n  focusOnEditField()\n}\nif (wasEditingBefore &#x26;&#x26; isNotEditingNow) {\n  focusOnEditButton()\n}\n</code></pre>\n<p>The React team had discussed <a href=\"https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state\">ways to get a component's previous state</a>, and has provided an example custom hook we can use for the job.</p>\n<p>Paste the following code near the top of <code>Todo.js</code>, above your <code>Todo()</code> function.</p>\n<pre><code>function usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n</code></pre>\n<p>Now we'll define a <code>wasEditing</code> constant beneath the hooks at the top of <code>Todo()</code>. We want this constant to track the previous value of <code>isEditing</code>, so we call <code>usePrevious</code> with <code>isEditing</code> as an argument:</p>\n<pre><code>const wasEditing = usePrevious(isEditing);\n</code></pre>\n<p>With this constant, we can update our <code>useEffect()</code> hook to implement the pseudocode we discussed before — update it as follows:</p>\n<pre><code>useEffect(() => {\n  if (!wasEditing &#x26;&#x26; isEditing) {\n    editFieldRef.current.focus();\n  }\n  if (wasEditing &#x26;&#x26; !isEditing) {\n    editButtonRef.current.focus();\n  }\n}, [wasEditing, isEditing]);\n</code></pre>\n<p>Note that the logic of <code>useEffect()</code> now depends on <code>wasEditing</code>, so we provide it in the array of dependencies.</p>\n<p>Again try using the \"Edit\" and \"Cancel\" buttons to toggle between the templates of your <code>&#x3C;Todo /></code> component; you'll see the browser focus indicator move appropriately, without the problem we discussed at the start of this section.</p>\n<h2><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#focusing_when_the_user_deletes_a_task\" title=\"Permalink to Focusing when the user deletes a task\">Focusing when the user deletes a task</a></h2>\n<p>There's one last keyboard experience gap: when a user deletes a task from the list, the focus vanishes. We're going to follow a pattern similar to our previous changes: we'll make a new ref, and utilize our <code>usePrevious()</code> hook, so that we can focus on the list heading whenever a user deletes a task.</p>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#why_the_list_heading\" title=\"Permalink to Why the list heading?\">Why the list heading?</a></h3>\n<p>Sometimes, the place we want to send our focus to is obvious: when we toggled our <code>&#x3C;Todo /></code> templates, we had an origin point to \"go back\" to — the \"Edit\" button. In this case however, since we're completely removing elements from the DOM, we have no place to go back to. The next best thing is an intuitive location somewhere nearby. The list heading is our best choice because it's close to the list item the user will delete, and focusing on it will tell the user how many tasks are left.</p>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#creating_our_ref\" title=\"Permalink to Creating our ref\">Creating our ref</a></h3>\n<p>Import the <code>useRef()</code> and <code>useEffect()</code> hooks into <code>App.js</code> — you'll need them both below:</p>\n<pre><code>import React, { useState, useRef, useEffect } from \"react\";\n</code></pre>\n<p>Then declare a new ref inside the <code>App()</code> function. Just above the <code>return</code> statement is a good place:</p>\n<pre><code>const listHeadingRef = useRef(null);\n</code></pre>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#prepare_the_heading\" title=\"Permalink to Prepare the heading\">Prepare the heading</a></h3>\n<p>Heading elements like our <code>&#x3C;h2></code> are not usually focusable. This isn't a problem — we can make any element programmatically focusable by adding the attribute <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\"><code>tabindex=\"-1\"</code></a> to it. This means <em>only focusable with JavaScript</em>. You can't press Tab to focus on an element with a tabindex of <code>-1</code> the same way you could do with a <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button\"><code>&#x3C;button></code></a> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a\"><code>&#x3C;a></code></a> element (this can be done using <code>tabindex=\"0\"</code>, but that's not really appropriate in this case).</p>\n<p>Let's add the <code>tabindex</code> attribute — written as <code>tabIndex</code> in JSX — to the heading above our list of tasks, along with our <code>headingRef</code>:</p>\n<pre><code>&#x3C;h2 id=\"list-heading\" tabIndex=\"-1\" ref={listHeadingRef}>\n  {headingText}\n&#x3C;/h2>\n</code></pre>\n<p><strong>Note:</strong> The <code>tabindex</code> attribute is great for accessibility edge-cases, but you should take <strong>great care</strong> to not overuse it. Only apply a <code>tabindex</code> to an element when you're absolutely sure that making it focusable will benefit your user in some way. In most cases, you should be utilizing elements that can naturally take focus, such as buttons, anchors, and inputs. Irresponsible usage of <code>tabindex</code> could have a profoundly negative impact on keyboard and screen-reader users!</p>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#getting_previous_state\" title=\"Permalink to Getting previous state\">Getting previous state</a></h3>\n<p>We want to focus on the element associated with our ref (via the <code>ref</code> attribute) only when our user deletes a task from their list. That's going to require the <code>usePrevious()</code> hook we already used earlier on. Add it to the top of your <code>App.js</code> file, just below the imports:</p>\n<pre><code>function usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n</code></pre>\n<p>Now add the following, above the <code>return</code> statement inside the <code>App()</code> function:</p>\n<pre><code>const prevTaskLength = usePrevious(tasks.length);\n</code></pre>\n<p>Here we are invoking <code>usePrevious()</code> to track the length of the tasks state, like so:</p>\n<p><strong>Note:</strong> Since we're now utilizing <code>usePrevious()</code> in two files, a good efficiency refactor would be to move the <code>usePrevious()</code> function into its own file, export it from that file, and import it where you need it. Try doing this as an exercise once you've got to the end.</p>\n<h3><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#using_useeffect_to_control_our_heading_focus\" title=\"Permalink to Using useEffect() to control our heading focus\">Using <code>useEffect()</code> to control our heading focus</a></h3>\n<p>Now that we've stored how many tasks we previously had, we can set up a <code>useEffect()</code> hook to run when our number of tasks changes, which will focus the heading if the number of tasks we have now is less than with it previously was — i.e. we deleted a task!</p>\n<p>Add the following into the body of your <code>App()</code> function, just below your previous additions:</p>\n<pre><code>useEffect(() => {\n  if (tasks.length - prevTaskLength === -1) {\n    listHeadingRef.current.focus();\n  }\n}, [tasks.length, prevTaskLength]);\n</code></pre>\n<p>We only try to focus on our list heading if we have fewer tasks now than we did before. The dependencies passed into this hook ensure it will only try to re-run when either of those values (the number of current tasks, or the number of previous tasks) changes.</p>\n<p>Now, when you delete a task in your browser, you will see our dashed focus outline appear around the heading above the list.</p>\n<h2><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility#finished!\" title=\"Permalink to Finished!\">Finished!</a></h2>\n<p>You've just finished building a React app from the ground up! Congratulations! The skills you've learned here will be a great foundation to build on as you continue working with React.</p>\n<p>Most of the time, you can be an effective contributor to a React project even if all you do is think carefully about components and their state and props. Remember to always write the best HTML you can.</p>\n<p><code>useRef()</code> and <code>useEffect()</code> are somewhat advanced features, and you should be proud of yourself for using them! Look out for opportunities to practice them more, because doing so will allow you to create inclusive experiences for users. Remember: our app would have been inaccessible to keyboard users without them!</p>"}