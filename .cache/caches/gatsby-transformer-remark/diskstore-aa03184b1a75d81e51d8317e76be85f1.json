{"expireTime":9007200908525415000,"key":"transformer-remark-markdown-html-9f86405cf172377b347d0ce94578e673--","val":"<h1>A Very Quick Guide To Calculating Big O Computational Complexity\n\n</h1>\n<p><strong>Big O</strong>: big picture, broad strokes, not details</p>\n<p><img src=\"https://miro.medium.com/max/630/0*lte81mEvgEPYXodB.png\" alt=\"medium blog image\"></p>\n<p><img src=\"https://miro.medium.com/max/304/1*5t2u8n1uKhioIzZIXX2zbg.png\" alt=\"medium blog image\"></p>\n<p><img src=\"https://miro.medium.com/max/563/1*HhXmG2cNdg8y4ZCCQGTyuQ.png\" alt=\"medium blog image\"></p>\n<p><img src=\"https://miro.medium.com/max/630/1*ULeXxVCDkF73GwhsxyM_2g.png\" alt=\"medium blog image\"><img src=\"https://miro.medium.com/max/900/1*hkZWlUgFyOSaLD5Uskv0tQ.png\" alt=\"medium blog image\"><img src=\"https://miro.medium.com/max/1115/1*COjzunj0-FsMJ0d7v7Z-6g.png\" alt=\"medium blog image\"></p>\n<p>For a more complete guideâ€¦ checkout :</p>\n<ul>\n<li>way we analyze how efficient algorithms are without getting too mired in details</li>\n<li></li>\n<li>can model how much time any function will take given n inputs</li>\n<li></li>\n<li>interested in order of magnitude of number of the exact figure</li>\n<li>O absorbs all fluff and n = biggest term</li>\n<li>Big O of 3x^2 +x + 1 = O(n^2)</li>\n</ul>\n<h1>Time Complexity</h1>\n<p>no loops or exit &#x26; return = O(1)</p>\n<p>0 nested loops = O(n)\n1 nested loops = O(n^2)\n2 nested loops = O(n^3)\n3 nested loops = O(n^4)</p>\n<p><strong>recursive</strong>: as you add more terms, increase in time as you add input diminishes\n<strong>recursion</strong>: when you define something in terms of itself, a function that calls itself</p>\n<ul>\n<li>used because of ability to maintain state at diffferent levels of recursion</li>\n<li></li>\n<li>inherently carries large footprint</li>\n<li>every time function called, you add call to stack</li>\n</ul>\n<p><strong>iterative</strong>: use loops instead of recursion (preferred)\n- favor readability over performance</p>\n<p>O(n log(n)) &#x26; O(log(n)): dividing/halving</p>\n<ul>\n<li>if code employs recursion/divide-and-conquer strategy</li>\n<li></li>\n<li>what power do i need to power my base to get n</li>\n</ul>\n<h1>Time Definitions</h1>\n<ul>\n<li><strong>constant</strong>: does not scale with input, will take same amount of time</li>\n<li></li>\n<li>for any input size n, constant time performs same number of operations every time</li>\n<li></li>\n<li>**logarit</li>\n<li></li>\n<li>function log n grows very slowly, so as n gets longer, number of operations the algorithm needs to perform</li>\n<li></li>\n<li>halving</li>\n<li></li>\n<li><strong>linear</strong>: increases number of operations it performs as linear function of input size n</li>\n<li></li>\n<li>number of additional operations needed to perform grows in direct proportion to increase in</li>\n<li></li>\n<li><strong>log-linear</strong>: increases number of operations it performs as log-linear function of input size n</li>\n<li>looking over every element and doing work on each one</li>\n<li><strong>quadratic</strong>: increases number of operations it performs as quadratic function of input size n</li>\n<li><strong>exponential</strong>: increases number of operations it performs as exponential function of input size n</li>\n<li>number of nested loops increases as function of n</li>\n<li><strong>polynomial</strong>: as size of input increases, runtime/space used will grow at a faster rate</li>\n<li><strong>factorial</strong>: as size of input increases, runtime/space used will grow astronomically even with relatively small inputs</li>\n<li><strong>rate of growth</strong>: how fast a function grows with input size</li>\n</ul>\n<h1>Space Complexity</h1>\n<ul>\n<li>How does the space usage scale/change as input gets very large?</li>\n<li></li>\n<li>What auxiliary space does your algorithm use or is it in place (constant)?</li>\n<li>Runtime stack space counts as part of space complexity unless told otherwise.</li>\n</ul>\n<h1>Data Structures &#x26; Algos In JS</h1>\n<hr>"}