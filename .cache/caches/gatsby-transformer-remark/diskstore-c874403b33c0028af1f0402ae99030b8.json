{"expireTime":9007200908525415000,"key":"transformer-remark-markdown-html-b274d0a0cbbfb8d362596ee78e368b5c--","val":"<p>Regular expressions make light work of <strong>single-character delimiters</strong>, which is why it's so easy to remove markup from a string:</p>\n<pre><code>str = str.replace(/(&#x3C;[\\/]?[^>]+>)/g, '');\n</code></pre>\n<p>It's the negation in the character class that does the real work:</p>\n<pre><code>[^>]\n</code></pre>\n<p>Which means <em>\"anything except <code>&#x3C;</code>\"</em>. So the expression looks for the starting tag-delimiter and possible slash, then anything except the closing tag-delimiter, and then the delimiter itself. Easy.</p>\n<p>However comments are not so simple, because comment delimiters are comprised of <strong>more than one character</strong>. Multi-line comments in CSS and JavaScript, for example, start with <code>/*</code> and end with <code>*/</code>, but between those two delimiters there could be <strong>any number of unrelated stars</strong>.</p>\n<p>I often use multiple stars in comments, to indicate the severity of a bug I've just noticed, for example:</p>\n<pre><code>/*** this is a bug with 3-star severity ***/\n</code></pre>\n<p>But if we tried to parse that with a single negation character, it would fail:</p>\n<pre><code>str = str.replace(/(\\/\\*[^\\*]+\\*\\/)/g, '');\n</code></pre>\n<p>Yet it's not possible with regular expressions to say: <em>\"anything except [this sequence of characters]\"</em>, we can only say: <em>\"anything except [one of these single characters]\"</em>.</p>\n<p>So here's the regular expression we need instead:</p>\n<pre><code>str = str.replace(/(\\/\\*([^*]|(\\*+[^*\\/]))*\\*+\\/)/gm, '');\n</code></pre>\n<p>The expression handles unrelated characters by <strong>looking at what comes after them</strong> — stars are allowed as long as they're not followed by a slash, until we find one that is, and that's the end of the comment.</p>\n<p>So it says: \"<code>/</code> then <code>*</code> (then anything except <code>*</code> OR any number of <code>*</code> followed by anything except <code>/</code>)(and any number of instances of that) then any number of <code>*</code> then <code>/</code>\".</p>\n<p>(The syntax looks particular convoluted, because <code>*</code> and <code>/</code> are both special characters in regular expressions, so the ambiguous literal ones have to be escaped. Also note the <code>m</code> flag at the end of the expression, which means <strong>multi-line</strong>, and specifies that the regular expression should search across more than one line of text.)</p>\n<p>Using the same principle then, we can adapt the expression to search for any kind of complex delimiters. Here's another one that matches HTML comments:</p>\n<pre><code>str = str.replace(/(&#x3C;!\\-\\-([^\\-]|(\\-+[^>]))*\\-+>)/gm, '');\n</code></pre>\n<p>And here's one for <code>CDATA</code> sections:</p>\n<pre><code>str = str.replace(/(&#x3C;\\!\\[CDATA\\[([^\\]]|(\\]+[^>]))*\\]+>)/gm, '');\n</code></pre>\n<h2>2. Using Replacement Callbacks</h2>\n<p>The <code>replace</code> function can also be <strong>passed a callback</strong> as its second parameter, and this is invaluable in cases where the replacement you want can't be described in a simple expression. For example:</p>\n<pre><code class=\"language-js\">isocode = isocode.replace(/^([a-z]+)(\\-[a-z]+)?$/i, function (match, lang, country) {\n    return lang.toLowerCase() + (country ? country.toUpperCase() : '');\n});\n</code></pre>\n<p>That example normalizes the capitalisation in language codes — so <code>\"EN\"</code> would become <code>\"en\"</code>, while <code>\"en-us\"</code> would become <code>\"en-US\"</code>.</p>\n<p>The first argument that's passed to the callback is always the complete match, then each subsequent argument corresponds with the backreferences (i.e. <code>arguments[1]</code> is what a string replacement would refer to as <code>$1</code>, and so on).</p>\n<p>So taking <code>\"en-us\"</code> as the input, we'd get the three arguments:</p>\n<ol start=\"0\">\n<li><code>\"en-us\"</code></li>\n<li><code>\"en\"</code></li>\n<li><code>\"-us\"</code></li>\n</ol>\n<p>Then all the function has to do is enforce the appropriate cases, re-combine the parts and return them. Whatever the callback returns is what the replacement itself returns.</p>\n<p>But we don't actually have to assign the return value (or return at all), and if we don't, then the original string will be unaffected. This means we can use <code>replace</code> as a <strong>general-purpose string processor</strong> — to extract data from a string without changing it.</p>\n<p>Here's another example, that combines the multi-line comment expression from the previous section, with a callback that extracts and saves the text of each comment:</p>\n<pre><code>let comments = [];\nstr.replace(/(\\/\\*([^*]|(\\*+[^*\\/]))*\\*+\\/)/gm,\n  function(match)\n  {\n    comments.push(match);\n  });\n</code></pre>\n<p>Since nothing is returned, the original string remains unchanged. Although if we wanted to extract <em>and</em> remove the comments, we could simply return and assign an empty-string:</p>\n<pre><code class=\"language-js\">let comments = [];\nstr = str.replace(/(\\/\\*([^*]|(\\*+[^*\\/]))*\\*+\\/)/gm, function (match) {\n    comments.push(match);\n    return '';\n});\n</code></pre>\n<h2>3. Working With Invisible Delimiters</h2>\n<p>Extracting content is all very well when it uses standard delimiters, but what if you're using <strong>custom delimiters</strong> that only your program knows about? The problem there is that <strong>the string might already contain your delimiter</strong>, literally character for character, and then what do you?</p>\n<p>Well, recently I came up with a very cute trick, that not only avoids this problem, it's also as simple to use as the single-character class we saw at the start! The trick is to use <strong>unicode characters that the document can't contain</strong>.</p>\n<p>Originally I tried this with <em>undefined</em> characters, and that certainly worked, but it's not safe to assume that any such character will always be undefined (or that the document won't already contain it anyway). Then I discovered that Unicode actually reserves a set of code-points specifically for this kind of thing — so-called <a href=\"http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Noncharacters\" title=\"Mapping of Unicode Characters (wikipedia.org)\">noncharacters</a>, which will never be used to define actual characters. A valid Unicode document is not allowed to contain noncharacters, but a program can use them internally for its own purposes.</p>\n<p>I was working on CSS processor, and I needed to remove all the comments before parsing the selectors, so they wouldn't confuse the selector-matching expressions. But they had to be replaced in the source with something that took up the same number of lines, so that the line-numbers would remain accurate. Then later they would have to be added back to the source, for final output.</p>\n<p>So first we use a regex callback to extract and save the comments. The callback returns a copy of the match in which all non-whitespace is converted to space, and which is delimited with a noncharacter either side:</p>\n<pre><code>let comments = [];\ncsstext = csstext.replace(/(\\/\\*([^*]|(\\*+([^*\\/])))*\\*+\\/)/gm,\n  function(match)\n  {\n    comments.push(match);\n    return '\\ufddf' + match.replace(/[\\S]/gim, ' ') + '\\ufddf';\n  });\n</code></pre>\n<p>That creates an array of comments in the same source-order as the spaces they leave behind, while the spaces themselves take-up as many lines as the original comment.</p>\n<p>Then the originals can be restored simply by replacing each delimited space with its corresponding saved comment — and since the delimiters are single characters, we only need a <strong>simple character class</strong> to match each pair:</p>\n<pre><code>csstext = csstext.replace(/(\\ufddf[^\\ufddf]+\\ufddf)/gim,\n  function()\n  {\n    return comments.shift();\n  });\n</code></pre>\n<p>How easy is that!</p>"}