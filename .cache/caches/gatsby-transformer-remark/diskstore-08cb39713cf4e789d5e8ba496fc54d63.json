{"expireTime":9007200908525415000,"key":"transformer-remark-markdown-html-31d9d1dd4147a06fb50e6d48268ae786--","val":"<h1>Object</h1>\n<p>The <code>Object</code> class represents one of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures\">JavaScript's data types</a>. It is used to store various keyed collections and more complex entities. Objects can be created using the <a href=\"object/object\"><code>Object()</code></a> constructor or the <a href=\"../operators/object_initializer\">object initializer / literal syntax</a>.</p>\n<h2>Description</h2>\n<p>Nearly all objects in JavaScript are instances of <a href=\"object\"><code>Object</code></a>; a typical object inherits properties (including methods) from <code>Object.prototype</code>, although these properties may be shadowed (a.k.a. overridden). However, an <code>Object</code> may be deliberately created for which this is not true (e.g. by <a href=\"object/create\"><code>Object.create(null)</code></a>), or it may be altered so that this is no longer true (e.g. with <a href=\"object/setprototypeof\"><code>Object.setPrototypeOf</code></a>).</p>\n<p>Changes to the <code>Object</code> prototype object are seen by <strong>all</strong> objects through prototype chaining, unless the properties and methods subject to those changes are overridden further along the prototype chain. This provides a very powerful although potentially dangerous mechanism to override or extend object behavior.</p>\n<p>The <code>Object</code> constructor creates an object wrapper for the given value.</p>\n<ul>\n<li>If the value is <a href=\"null\"><code>null</code></a> or <a href=\"undefined\"><code>undefined</code></a>, it will create and return an empty object.</li>\n<li>Otherwise, it will return an object of a Type that corresponds to the given value.</li>\n<li>If the value is an object already, it will return the value.</li>\n</ul>\n<p>When called in a non-constructor context, <code>Object</code> behaves identically to <code>new Object()</code>.</p>\n<p>See also the <a href=\"../operators/object_initializer\">object initializer / literal syntax</a>.</p>\n<h3>Deleting a property from an object</h3>\n<p>There isn't any method in an Object itself to delete its own properties (such as <a href=\"map/delete\"><code>Map.prototype.delete()</code></a>). To do so, one must use the <a href=\"../operators/delete\">delete operator</a>.</p>\n<h2>Constructor</h2>\n<p><a href=\"object/object\"><code>Object()</code></a>\nCreates a new <code>Object</code> object. It is a wrapper for the given value.</p>\n<h2>Static methods</h2>\n<p><a href=\"object/assign\"><code>Object.assign()</code></a>\nCopies the values of all enumerable own properties from one or more source objects to a target object.</p>\n<p><a href=\"object/create\"><code>Object.create()</code></a>\nCreates a new object with the specified prototype object and properties.</p>\n<p><a href=\"object/defineproperty\"><code>Object.defineProperty()</code></a>\nAdds the named property described by a given descriptor to an object.</p>\n<p><a href=\"object/defineproperties\"><code>Object.defineProperties()</code></a>\nAdds the named properties described by the given descriptors to an object.</p>\n<p><a href=\"object/entries\"><code>Object.entries()</code></a>\nReturns an array containing all of the <code>[key, value]</code> pairs of a given object's <strong>own</strong> enumerable string properties.</p>\n<p><a href=\"object/freeze\"><code>Object.freeze()</code></a>\nFreezes an object. Other code cannot delete or change its properties.</p>\n<p><a href=\"object/fromentries\"><code>Object.fromEntries()</code></a>\nReturns a new object from an iterable of <code>[key, value]</code> pairs. (This is the reverse of <a href=\"object/entries\"><code>Object.entries</code></a>).</p>\n<p><a href=\"object/getownpropertydescriptor\"><code>Object.getOwnPropertyDescriptor()</code></a>\nReturns a property descriptor for a named property on an object.</p>\n<p><a href=\"object/getownpropertydescriptors\"><code>Object.getOwnPropertyDescriptors()</code></a>\nReturns an object containing all own property descriptors for an object.</p>\n<p><a href=\"object/getownpropertynames\"><code>Object.getOwnPropertyNames()</code></a>\nReturns an array containing the names of all of the given object's <strong>own</strong> enumerable and non-enumerable properties.</p>\n<p><a href=\"object/getownpropertysymbols\"><code>Object.getOwnPropertySymbols()</code></a>\nReturns an array of all symbol properties found directly upon a given object.</p>\n<p><a href=\"object/getprototypeof\"><code>Object.getPrototypeOf()</code></a>\nReturns the prototype (internal <code>[[Prototype]]</code> property) of the specified object.</p>\n<p><a href=\"object/is\"><code>Object.is()</code></a>\nCompares if two values are the same value. Equates all <code>NaN</code> values (which differs from both Abstract Equality Comparison and Strict Equality Comparison).</p>\n<p><a href=\"object/isextensible\"><code>Object.isExtensible()</code></a>\nDetermines if extending of an object is allowed.</p>\n<p><a href=\"object/isfrozen\"><code>Object.isFrozen()</code></a>\nDetermines if an object was frozen.</p>\n<p><a href=\"object/issealed\"><code>Object.isSealed()</code></a>\nDetermines if an object is sealed.</p>\n<p><a href=\"object/keys\"><code>Object.keys()</code></a>\nReturns an array containing the names of all of the given object's <strong>own</strong> enumerable string properties.</p>\n<p><a href=\"object/preventextensions\"><code>Object.preventExtensions()</code></a>\nPrevents any extensions of an object.</p>\n<p><a href=\"object/seal\"><code>Object.seal()</code></a>\nPrevents other code from deleting properties of an object.</p>\n<p><a href=\"object/setprototypeof\"><code>Object.setPrototypeOf()</code></a>\nSets the object's prototype (its internal <code>[[Prototype]]</code> property).</p>\n<p><a href=\"object/values\"><code>Object.values()</code></a>\nReturns an array containing the values that correspond to all of a given object's <strong>own</strong> enumerable string properties.</p>\n<h2>Instance properties</h2>\n<p><a href=\"object/constructor\"><code>Object.prototype.constructor</code></a>\nSpecifies the function that creates an object's prototype.</p>\n<p><a href=\"object/proto\"><code>Object/proto</code></a>\nPoints to the object which was used as prototype when the object was instantiated.</p>\n<h2>Instance methods</h2>\n<p><a href=\"object/__definegetter__\"><code>Object.prototype.__defineGetter__()</code></a>\nAssociates a function with a property that, when accessed, executes that function and returns its return value.</p>\n<p><a href=\"object/__definesetter__\"><code>Object.prototype.__defineSetter__()</code></a>\nAssociates a function with a property that, when set, executes that function which modifies the property.</p>\n<p><a href=\"object/__lookupgetter__\"><code>Object.prototype.__lookupGetter__()</code></a>\nReturns the function associated with the specified property by the <a href=\"object/__definegetter__\"><code>__defineGetter__()</code></a> method.</p>\n<p><a href=\"object/__lookupsetter__\"><code>Object.prototype.__lookupSetter__()</code></a>\nReturns the function associated with the specified property by the <a href=\"object/__definesetter__\"><code>__defineSetter__()</code></a> method.</p>\n<p><a href=\"object/hasownproperty\"><code>Object.prototype.hasOwnProperty()</code></a>\nReturns a boolean indicating whether an object contains the specified property as a direct property of that object and not inherited through the prototype chain.</p>\n<p><a href=\"object/isprototypeof\"><code>Object.prototype.isPrototypeOf()</code></a>\nReturns a boolean indicating whether the object this method is called upon is in the prototype chain of the specified object.</p>\n<p><a href=\"object/propertyisenumerable\"><code>Object.prototype.propertyIsEnumerable()</code></a>\nReturns a boolean indicating if the internal <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#properties\">ECMAScript [[Enumerable]] attribute</a> is set.</p>\n<p><a href=\"object/tolocalestring\"><code>Object.prototype.toLocaleString()</code></a>\nCalls <a href=\"object/tostring\"><code>toString()</code></a>.</p>\n<p><a href=\"object/tostring\"><code>Object.prototype.toString()</code></a>\nReturns a string representation of the object.</p>\n<p><a href=\"object/valueof\"><code>Object.prototype.valueOf()</code></a>\nReturns the primitive value of the specified object.</p>\n<h2>Examples</h2>\n<h3>Using <code>Object</code> given <code>undefined</code> and <code>null</code> types</h3>\n<p>The following examples store an empty <code>Object</code> object in <code>o</code>:</p>\n<pre><code>let o = new Object()\n\nlet o = new Object(undefined)\n\nlet o = new Object(null)\n</code></pre>\n<h3>Using <code>Object</code> to create <code>Boolean</code> objects</h3>\n<p>The following examples store <a href=\"boolean\"><code>Boolean</code></a> objects in <code>o</code>:</p>\n<pre><code>// equivalent to o = new Boolean(true)\nlet o = new Object(true)\n\n// equivalent to o = new Boolean(false)\nlet o = new Object(Boolean())\n</code></pre>\n<h3>Object prototypes</h3>\n<p>When altering the behavior of existing <code>Object.prototype</code> methods, consider injecting code by wrapping your extension before or after the existing logic. For example, this (untested) code will pre-conditionally execute custom logic before the built-in logic or someone else's extension is executed.</p>\n<p>When a function is called, the arguments to the call are held in the array-like \"variable\" <a href=\"../functions/arguments\">arguments</a>. For example, in the call <code>myFn(a, b, c)</code>, the arguments within <code>myFn</code>'s body will contain 3 array-like elements corresponding to <code>(a, b, c)</code>.</p>\n<p>When modifying prototypes with hooks, pass <code>this</code> and the arguments (the call state) to the current behavior by calling <code>apply()</code> on the function. This pattern can be used for any prototype, such as <code>Node.prototype</code>, <code>Function.prototype</code>, etc.</p>\n<pre><code>var current = Object.prototype.valueOf;\n\n// Since my property \"-prop-value\" is cross-cutting and isn't always\n// on the same prototype chain, I want to modify Object.prototype:\nObject.prototype.valueOf = function() {\n  if (this.hasOwnProperty('-prop-value')) {\n    return this['-prop-value'];\n  } else {\n    // It doesn't look like one of my objects, so let's fall back on\n    // the default behavior by reproducing the current behavior as best we can.\n    // The apply behaves like \"super\" in some other languages.\n    // Even though valueOf() doesn't take arguments, some other hook may.\n    return current.apply(this, arguments);\n  }\n}\n</code></pre>\n<p>Since JavaScript doesn't exactly have sub-class objects, prototype is a useful workaround to make a \"base class\" object of certain functions that act as objects. For example:</p>\n<pre><code class=\"language-js\">    var Person = function(name) {\n      this.name = name;\n      this.canTalk = true;\n    };\n\n    Person.prototype.greet = function() {\n      if (this.canTalk) {\n        console.log('Hi, I am ' + this.name);\n      }\n    };\n\n    var Employee = function(name, title) {\n      Person.call(this, name);\n      this.title = title;\n    };\n\n    Employee.prototype = Object.create(Person.prototype);\n    Employee.prototype.constructor = Employee; //If you don't set Object.prototype.constructor to Employee,\n                                               //it will take prototype.constructor of Person (parent).\n                                               //To avoid that, we set the prototype.constructor to Employee (child).\n\n    Employee.prototype.greet = function() {\n      if (this.canTalk) {\n        console.log('Hi, I am ' + this.name + ', the ' + this.title);\n      }\n    };\n\n    var Customer = function(name) {\n      Person.call(this, name);\n    };\n\n    Customer.prototype = Object.create(Person.prototype);\n    Customer.prototype.constructor = Customer; //If you don't set Object.prototype.constructor to Customer,\n                                               //it will take prototype.constructor of Person (parent).\n                                               //To avoid that, we set the prototype.constructor to Customer (child).\n\n    var Mime = function(name) {\n      Person.call(this, name);\n      this.canTalk = false;\n    };\n\n    Mime.prototype = Object.create(Person.prototype);\n    Mime.prototype.constructor = Mime; //If you don't set Object.prototype.constructor to Mime,\n                                       //it will take prototype.constructor of Person (parent).\n                                       //To avoid that, we set the prototype.constructor to Mime (child).\n\n    var bob = new Employee('Bob', 'Builder');\n    var joe = new Customer('Joe');\n    var rg = new Employee('Red Green', 'Handyman');\n    var mike = new Customer('Mike');\n    var mime = new Mime('Mime');\n\n    bob.greet();\n    // Hi, I am Bob, the Builder\n\n    joe.greet();\n    // Hi, I am Joe\n\n    rg.greet();\n    // Hi, I am Red Green, the Handyman\n\n    mike.greet();\n    // Hi, I am Mike\n\n    mime.greet();\n</code></pre>"}