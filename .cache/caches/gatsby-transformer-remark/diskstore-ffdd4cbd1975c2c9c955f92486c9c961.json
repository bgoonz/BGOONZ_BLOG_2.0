{"expireTime":9007200908525415000,"key":"transformer-remark-markdown-html-31de394c4ec4690ed8029a894194e64f--","val":"<h2>JS Fat Arrow Functions</h2>\n<p>Classical JavaScript function syntax doesn't provide for any flexibility, be that a 1 statement function or an unfortunate multi-page function. Every time you need a function you have to type out the dreaded <code>function () {}</code>. More concise function syntax was one of the many reasons why <a href=\"http://coffeescript.org/\">CoffeeScript</a> gained so much momentum back in the day. This is especially pronounced in the case of tiny callback functions. Lets look at a Promise chain:</p>\n<pre><code>function getVerifiedToken(selector) {\n  return getUsers(selector)\n    .then(function (users) { return users[0]; })\n    .then(verifyUser)\n    .then(function (user, verifiedToken) { return verifiedToken; })\n    .catch(function (err) { log(err.stack); });\n}\n</code></pre>\n<p>Above is more or less plausible piece of code written using classical JavaScript <code>function</code> syntax. Here is what the same code could look like rewritten using the arrow syntax:</p>\n<pre><code>function getVerifiedToken(selector) {\n  return getUsers(selector)\n    .then(users => users[0])\n    .then(verifyUser)\n    .then((user, verifiedToken) => verifiedToken)\n    .catch(err => log(err.stack));\n}\n</code></pre>\n<p>A few important things to notice here:</p>\n<ol>\n<li>We've lost <code>function</code> and <code>{}</code> because all of our callback functions are one liners.</li>\n<li>We've lost <code>()</code> around the argument list when there's just one argument (rest arguments are an exception, eg <code>(...args) => ...</code>)</li>\n<li>We've lost the <code>return</code> keyword because when omitting <code>{}</code>, single line arrow functions perform an implicit return (these functions are often referred to as lambda functions in other languages).</li>\n</ol>\n<p>It's important to reinforce the last point. Implicit return only happens for single statement arrow functions. When arrow function is declared with <code>{}</code>, even if it's a single statement, implicit return does not happen:</p>\n<pre><code>const getVerifiedToken = selector => {\n  return getUsers()\n    .then(users => users[0])\n    .then(verifyUser)\n    .then((user, verifiedToken) => verifiedToken)\n    .catch(err => log(err.stack));\n}\n</code></pre>\n<p>Here's the really fun bit. Because our function has only one statement, we can still get rid of the <code>{}</code> and it will look almost exactly like <a href=\"http://coffeescript.org/\">CoffeeScript</a> syntax:</p>\n<pre><code>const getVerifiedToken = selector =>\n  getUsers()\n    .then(users => users[0])\n    .then(verifyUser)\n    .then((user, verifiedToken) => verifiedToken)\n    .catch(err => log(err.stack));\n</code></pre>\n<p>Yep, the example above is completely valid ES2015 syntax (I was also surprised that it <a href=\"http://babeljs.io/repl/#?\">compiles fine</a>). When we talk about single statement arrow functions, it doesn't mean the statement can't be spread out to multiple lines for better comprehension.</p>\n<p>There's one caveat, however, with omitting <code>{}</code> from arrow functions -- how do you return an empty object, eg <code>{}</code>?</p>\n<pre><code>const emptyObject = () => {};\nemptyObject(); // ?\n</code></pre>\n<p>Unfortunately there's no way to distinguish between empty block <code>{}</code> and an object <code>{}</code>. Because of that <code>emptyObject()</code> evaluates to <code>undefined</code> and <code>{}</code> interpreted as empty block. To return an empty object from fat arrow functions you have to surround it with brackets like so <code>({})</code>:</p>\n<pre><code>const emptyObject = () => ({});\nemptyObject(); // {}\n</code></pre>\n<p>Here's all of the above together:</p>\n<pre><code>function () { return 1; }\n() => { return 1; }\n() => 1\n\nfunction (a) { return a * 2; }\n(a) => { return a * 2; }\n(a) => a * 2\na => a * 2\n\nfunction (a, b) { return a * b; }\n(a, b) => { return a * b; }\n(a, b) => a * b\n\nfunction () { return arguments[0]; }\n(...args) => args[0]\n\n() => {} // undefined\n() => ({}) // {}\n</code></pre>\n<h2>Lexical <code>this</code></h2>\n<p>The story of clobbering <code>this</code> in JavaScript is a really old one. Each <code>function</code> in JavaScript defines its own <code>this</code> context, which is as easy to get around as it is annoying. The example below tries to display a clock that updates every second using jQuery:</p>\n<pre><code>$('.current-time').each(function () {\n  setInterval(function () {\n    $(this).text(Date.now());\n  }, 1000);\n});\n</code></pre>\n<p>When attempting to reference the DOM element <code>this</code> set by <code>each</code> in the <code>setInterval</code> callback, we unfortunately get a brand new <code>this</code> that belongs to the callback itself. A common way around this is to declare <code>that</code> or <code>self</code> variable:</p>\n<pre><code>$('.current-time').each(function () {\n  var self = this;\n\n  setInterval(function () {\n    $(self).text(Date.now());\n  }, 1000);\n});\n</code></pre>\n<p>The fat arrow functions allow you to solve this problem because they don't introduce their own <code>this</code>:</p>\n<pre><code>$('.current-time').each(function () {\n  setInterval(() => $(this).text(Date.now()), 1000);\n});\n</code></pre>\n<h2>What about arguments?</h2>\n<p>One of the caveats with arrow functions is that they also don't have their own <code>arguments</code> variable like regular functions:</p>\n<pre><code>function log(msg) {\n  const print = () => console.log(arguments[0]);\n  print(`LOG: ${msg}`);\n}\n\nlog('hello'); // hello\n</code></pre>\n<p>To reiterate, fat arrow functions don't have their own <code>this</code> and <code>arguments</code>. Having said that, you can still get all arguments passed into the arrow functions using rest parameters (also known as spread operator):</p>\n<pre><code>function log(msg) {\n  const print = (...args) => console.log(args[0]);\n  print(`LOG: ${msg}`);\n}\n\nlog('hello'); // LOG: hello\n</code></pre>\n<h2>What about yield?</h2>\n<p>Fat arrow functions can't be used as generators. That's it -- no exceptions, no caveats and no workarounds.</p>\n<h2>Bottom Line</h2>\n<p>Fat arrow functions are one of my favorite additions to JavaScript. It might be very tempting to just start using <code>=></code> instead of <code>function</code> everywhere. I've seen whole libraries written just using <code>=></code> and I don't think it's the right thing to do because of the special features that <code>=></code> introduces. I recommend using arrow functions only in places where you explicitly want to use the new features:</p>\n<ul>\n<li>Single statement functions that immediately return (lambdas)</li>\n<li>Functions that need to work with parent scope <code>this</code></li>\n</ul>"}