{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import axios, {\n  AxiosError,\n  AxiosInstance,\n  AxiosRequestConfig,\n  AxiosResponse,\n} from 'axios';\n\n/**\n * Configuration for the Axios `request` method.\n */\nexport interface RetryConfig {\n  /**\n   * The number of times to retry the request.  Defaults to 3.\n   */\n  retry?: number;\n\n  /**\n   * The number of retries already attempted.\n   */\n  currentRetryAttempt?: number;\n\n  /**\n   * The amount of time to initially delay the retry.  Defaults to 100.\n   */\n  retryDelay?: number;\n\n  /**\n   * The instance of the axios object to which the interceptor is attached.\n   */\n  instance?: AxiosInstance;\n\n  /**\n   * The HTTP Methods that will be automatically retried.\n   * Defaults to ['GET','PUT','HEAD','OPTIONS','DELETE']\n   */\n  httpMethodsToRetry?: string[];\n\n  /**\n   * The HTTP response status codes that will automatically be retried.\n   * Defaults to: [[100, 199], [429, 429], [500, 599]]\n   */\n  statusCodesToRetry?: number[][];\n\n  /**\n   * Function to invoke when a retry attempt is made.\n   */\n  onRetryAttempt?: (err: AxiosError) => void;\n\n  /**\n   * Function to invoke which determines if you should retry\n   */\n  shouldRetry?: (err: AxiosError) => boolean;\n\n  /**\n   * When there is no response, the number of retries to attempt. Defaults to 2.\n   */\n  noResponseRetries?: number;\n\n  /**\n   * Backoff Type; 'linear', 'static' or 'exponential'.\n   */\n  backoffType?: 'linear' | 'static' | 'exponential';\n}\n\nexport type RaxConfig = {\n  raxConfig: RetryConfig;\n} & AxiosRequestConfig;\n\n/**\n * Attach the interceptor to the Axios instance.\n * @param instance The optional Axios instance on which to attach the\n * interceptor.\n * @returns The id of the interceptor attached to the axios instance.\n */\nexport function attach(instance?: AxiosInstance) {\n  instance = instance || axios;\n  return instance.interceptors.response.use(onFulfilled, onError);\n}\n\n/**\n * Eject the Axios interceptor that is providing retry capabilities.\n * @param interceptorId The interceptorId provided in the config.\n * @param instance The axios instance using this interceptor.\n */\nexport function detach(interceptorId: number, instance?: AxiosInstance) {\n  instance = instance || axios;\n  instance.interceptors.response.eject(interceptorId);\n}\n\nfunction onFulfilled(res: AxiosResponse) {\n  return res;\n}\n\n/**\n * Some versions of axios are converting arrays into objects during retries.\n * This will attempt to convert an object with the following structure into\n * an array, where the keys correspond to the indices:\n * {\n *   0: {\n *     // some property\n *   },\n *   1: {\n *     // another\n *   }\n * }\n * @param obj The object that (may) have integers that correspond to an index\n * @returns An array with the pucked values\n */\nfunction normalizeArray<T>(obj?: T[]): T[] | undefined {\n  const arr: T[] = [];\n  if (!obj) {\n    return undefined;\n  }\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  if (typeof obj === 'object') {\n    Object.keys(obj).forEach(key => {\n      if (typeof key === 'number') {\n        arr[key] = obj[key];\n      }\n    });\n  }\n  return arr;\n}\n\nfunction onError(err: AxiosError) {\n  if (axios.isCancel(err)) {\n    return Promise.reject(err);\n  }\n\n  const config = getConfig(err) || {};\n  config.currentRetryAttempt = config.currentRetryAttempt || 0;\n  config.retry = typeof config.retry === 'number' ? config.retry : 3;\n  config.retryDelay =\n    typeof config.retryDelay === 'number' ? config.retryDelay : 100;\n  config.instance = config.instance || axios;\n  config.backoffType = config.backoffType || 'exponential';\n  config.httpMethodsToRetry = normalizeArray(config.httpMethodsToRetry) || [\n    'GET',\n    'HEAD',\n    'PUT',\n    'OPTIONS',\n    'DELETE',\n  ];\n  config.noResponseRetries =\n    typeof config.noResponseRetries === 'number' ? config.noResponseRetries : 2;\n\n  // If this wasn't in the list of status codes where we want\n  // to automatically retry, return.\n  const retryRanges = [\n    // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n    // 1xx - Retry (Informational, request still processing)\n    // 2xx - Do not retry (Success)\n    // 3xx - Do not retry (Redirect)\n    // 4xx - Do not retry (Client errors)\n    // 429 - Retry (\"Too Many Requests\")\n    // 5xx - Retry (Server errors)\n    [100, 199],\n    [429, 429],\n    [500, 599],\n  ];\n  config.statusCodesToRetry =\n    normalizeArray(config.statusCodesToRetry) || retryRanges;\n\n  // Put the config back into the err\n  err.config = err.config || {}; // allow for wider range of errors\n  (err.config as RaxConfig).raxConfig = {...config};\n\n  // Determine if we should retry the request\n  const shouldRetryFn = config.shouldRetry || shouldRetryRequest;\n  if (!shouldRetryFn(err)) {\n    return Promise.reject(err);\n  }\n\n  // Create a promise that invokes the retry after the backOffDelay\n  const onBackoffPromise = new Promise(resolve => {\n    // Calculate time to wait with exponential backoff.\n    // Formula: (2^c - 1 / 2) * 1000\n    let delay: number;\n    if (config.backoffType === 'linear') {\n      delay = config.currentRetryAttempt! * 1000;\n    } else if (config.backoffType === 'static') {\n      delay = config.retryDelay!;\n    } else {\n      delay = ((Math.pow(2, config.currentRetryAttempt!) - 1) / 2) * 1000;\n    }\n\n    // We're going to retry!  Incremenent the counter.\n    (err.config as RaxConfig).raxConfig!.currentRetryAttempt! += 1;\n    setTimeout(resolve, delay);\n  });\n\n  // Notify the user if they added an `onRetryAttempt` handler\n  const onRetryAttemptPromise = config.onRetryAttempt\n    ? Promise.resolve(config.onRetryAttempt(err))\n    : Promise.resolve();\n\n  // Return the promise in which recalls axios to retry the request\n  return Promise.resolve()\n    .then(() => onBackoffPromise)\n    .then(() => onRetryAttemptPromise)\n    .then(() => config.instance!.request(err.config));\n}\n\n/**\n * Determine based on config if we should retry the request.\n * @param err The AxiosError passed to the interceptor.\n */\nexport function shouldRetryRequest(err: AxiosError) {\n  const config = (err.config as RaxConfig).raxConfig;\n\n  // If there's no config, or retries are disabled, return.\n  if (!config || config.retry === 0) {\n    return false;\n  }\n\n  // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)\n  if (\n    !err.response &&\n    (config.currentRetryAttempt || 0) >= config.noResponseRetries!\n  ) {\n    return false;\n  }\n\n  // Only retry with configured HttpMethods.\n  if (\n    !err.config.method ||\n    config.httpMethodsToRetry!.indexOf(err.config.method.toUpperCase()) < 0\n  ) {\n    return false;\n  }\n\n  // If this wasn't in the list of status codes where we want\n  // to automatically retry, return.\n  if (err.response && err.response.status) {\n    let isInRange = false;\n    for (const [min, max] of config.statusCodesToRetry!) {\n      const status = err.response.status;\n      if (status >= min && status <= max) {\n        isInRange = true;\n        break;\n      }\n    }\n    if (!isInRange) {\n      return false;\n    }\n  }\n\n  // If we are out of retry attempts, return\n  config.currentRetryAttempt = config.currentRetryAttempt || 0;\n  if (config.currentRetryAttempt >= config.retry!) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Acquire the raxConfig object from an AxiosError if available.\n * @param err The Axios error with a config object.\n */\nexport function getConfig(err: AxiosError) {\n  if (err && err.config) {\n    return (err.config as RaxConfig).raxConfig;\n  }\n  return;\n}\n\n// Include this so `config.raxConfig` works easily.\n// See https://github.com/JustinBeckwith/retry-axios/issues/64.\ndeclare module 'axios' {\n  export interface AxiosRequestConfig {\n    raxConfig?: RetryConfig;\n  }\n}\n"],"names":["onFulfilled","res","normalizeArray","obj","arr","Array","isArray","Object","keys","forEach","key","onError","err","axios","isCancel","Promise","reject","config","getConfig","currentRetryAttempt","retry","retryDelay","instance","backoffType","httpMethodsToRetry","noResponseRetries","statusCodesToRetry","raxConfig","shouldRetry","shouldRetryRequest","onBackoffPromise","resolve","delay","Math","pow","setTimeout","onRetryAttemptPromise","onRetryAttempt","then","request","response","method","indexOf","toUpperCase","status","isInRange","const","interceptors","use","interceptorId","eject"],"mappings":"4EAyFA,SAASA,EAAYC,UACZA,EAkBT,SAASC,EAAkBC,OACnBC,EAAW,MACZD,SAGDE,MAAMC,QAAQH,GACTA,GAEU,iBAARA,GACTI,OAAOC,KAAKL,GAAKM,iBAAQC,GACJ,iBAARA,IACTN,EAAIM,GAAOP,EAAIO,MAIdN,GAGT,SAASO,EAAQC,MACXC,EAAMC,SAASF,UACVG,QAAQC,OAAOJ,OAGlBK,EAASC,EAAUN,IAAQ,MACjCK,EAAOE,oBAAsBF,EAAOE,qBAAuB,EAC3DF,EAAOG,MAAgC,iBAAjBH,EAAOG,MAAqBH,EAAOG,MAAQ,EACjEH,EAAOI,WACwB,iBAAtBJ,EAAOI,WAA0BJ,EAAOI,WAAa,IAC9DJ,EAAOK,SAAWL,EAAOK,UAAYT,EACrCI,EAAOM,YAAcN,EAAOM,aAAe,cAC3CN,EAAOO,mBAAqBtB,EAAee,EAAOO,qBAAuB,CACvE,MACA,OACA,MACA,UACA,UAEFP,EAAOQ,kBAC+B,iBAA7BR,EAAOQ,kBAAiCR,EAAOQ,kBAAoB,EAgB5ER,EAAOS,mBACLxB,EAAee,EAAOS,qBAbJ,EAQjB,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,MAMRd,EAAIK,OAASL,EAAIK,QAAU,GAC1BL,EAAIK,OAAqBU,UAAYpB,iBAAIU,KAGpBA,EAAOW,aAAeC,GACzBjB,UACVG,QAAQC,OAAOJ,OAIlBkB,EAAmB,IAAIf,iBAAQgB,OAG/BC,EAEFA,EADyB,WAAvBf,EAAOM,YAC6B,IAA9BN,EAAOE,oBACiB,WAAvBF,EAAOM,YACRN,EAAOI,YAELY,KAAKC,IAAI,EAAGjB,EAAOE,qBAAwB,GAAK,EAAK,IAIhEP,EAAIK,OAAqBU,UAAWR,qBAAwB,EAC7DgB,WAAWJ,EAASC,KAIhBI,EAAwBnB,EAAOoB,eACjCtB,QAAQgB,QAAQd,EAAOoB,eAAezB,IACtCG,QAAQgB,iBAGLhB,QAAQgB,UACZO,uBAAWR,IACXQ,uBAAWF,IACXE,uBAAWrB,EAAOK,SAAUiB,QAAQ3B,EAAIK,mBAO7BY,EAAmBjB,OAC3BK,EAAUL,EAAIK,OAAqBU,cAGpCV,GAA2B,IAAjBA,EAAOG,aACb,MAKNR,EAAI4B,WACJvB,EAAOE,qBAAuB,IAAMF,EAAOQ,yBAErC,MAKNb,EAAIK,OAAOwB,QACZxB,EAAOO,mBAAoBkB,QAAQ9B,EAAIK,OAAOwB,OAAOE,eAAiB,SAE/D,KAKL/B,EAAI4B,UAAY5B,EAAI4B,SAASI,OAAQ,SACnCC,GAAY,QACS5B,EAAOS,mCAAqB,CAAhDoB,WACGF,EAAShC,EAAI4B,SAASI,UACxBA,SAAiBA,QAAe,CAClCC,GAAY,aAIXA,SACI,SAKX5B,EAAOE,oBAAsBF,EAAOE,qBAAuB,IACvDF,EAAOE,qBAAuBF,EAAOG,gBAW3BF,EAAUN,MACpBA,GAAOA,EAAIK,cACLL,EAAIK,OAAqBU,kCA9LdL,UACrBA,EAAWA,GAAYT,GACPkC,aAAaP,SAASQ,IAAIhD,EAAaW,4BAQlCsC,EAAuB3B,IAC5CA,EAAWA,GAAYT,GACdkC,aAAaP,SAASU,MAAMD"}